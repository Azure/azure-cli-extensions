# --------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
#
# Code generated by aaz-dev-tools
# --------------------------------------------------------------------------------------------

# pylint: skip-file
# flake8: noqa

from azure.cli.core.aaz import *


@register_command(
    "networkfabric taprule create",
)
class Create(AAZCommand):
    """Create a Network Tap Rule resource

    :example: Create a Network Tap Rule with Configuration type as "File".
        az networkfabric taprule create --resource-group "example-rg" --location "westus3" --resource-name "example-networktaprule" --polling-interval-in-seconds 30 --configuration-type "File" --tap-rules-url "https://microsoft.com/<FileName>"

    :example: Create a Network Tap Rule with Configuration type as "Inline".
        az networkfabric taprule create --resource-group "example-rg" --location "westus3" --resource-name "example-networktaprule" --configuration-type "Inline" --match-configurations "[{matchConfigurationName:config1,sequenceNumber:10,ipAddressType:IPv4,matchConditions:[{encapsulationType:None,portCondition:{portType:SourcePort,layer4Protocol:TCP,ports:[100],portGroupNames:['example-portGroup1']},protocolTypes:[TCP],vlanMatchCondition:{vlans:['10'],innerVlans:['11-20']},ipCondition:{type:SourceIP,prefixType:Prefix,ipPrefixValues:['10.10.10.10/20']}}],actions:[{type:Drop,truncate:100,isTimestampEnabled:True,destinationId:'/subscriptions/xxxxx-xxxx-xxxx-xxxx-xxxxx/resourcegroups/example-rg/providers/Microsoft.ManagedNetworkFabric/neighborGroups/example-neighborGroup',matchConfigurationName:match1}]}]" --dynamic-match-configurations "[{ipGroups:[{name:'example-ipGroup1',ipAddressType:IPv4,ipPrefixes:['10.10.10.10/30']}],vlanGroups:[{name:'exmaple-vlanGroup',vlans:['10']}],portGroups:[{name:'example-portGroup1',ports:['100-200']}]}]"

    :example: Help text for sub parameters under the specific parent can be viewed by using the shorthand syntax '??'. See https://github.com/Azure/azure-cli/tree/dev/doc/shorthand_syntax.md for more about shorthand syntax.
        az networkfabric taprule create --match-configurations "??"
    """

    _aaz_info = {
        "version": "2023-06-15",
        "resources": [
            ["mgmt-plane", "/subscriptions/{}/resourcegroups/{}/providers/microsoft.managednetworkfabric/networktaprules/{}", "2023-06-15"],
        ]
    }

    AZ_SUPPORT_NO_WAIT = True

    def _handler(self, command_args):
        super()._handler(command_args)
        return self.build_lro_poller(self._execute_operations, self._output)

    _args_schema = None

    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        if cls._args_schema is not None:
            return cls._args_schema
        cls._args_schema = super()._build_arguments_schema(*args, **kwargs)

        # define Arg Group ""

        _args_schema = cls._args_schema
        _args_schema.resource_name = AAZStrArg(
            options=["--resource-name"],
            help="Name of the Network Tap Rule.",
            required=True,
        )
        _args_schema.resource_group = AAZResourceGroupNameArg(
            help="Name of the resource group",
            required=True,
        )

        # define Arg Group "Body"

        _args_schema = cls._args_schema
        _args_schema.location = AAZResourceLocationArg(
            arg_group="Body",
            help="Location of Azure region",
            required=True,
            fmt=AAZResourceLocationArgFormat(
                resource_group_arg="resource_group",
            ),
        )
        _args_schema.tags = AAZDictArg(
            options=["--tags"],
            arg_group="Body",
            help="Resource tags.",
        )

        tags = cls._args_schema.tags
        tags.Element = AAZStrArg()

        # define Arg Group "Properties"

        _args_schema = cls._args_schema
        _args_schema.annotation = AAZStrArg(
            options=["--annotation"],
            arg_group="Properties",
            help="Description for underlying resource.",
        )
        _args_schema.configuration_type = AAZStrArg(
            options=["--configuration-type"],
            arg_group="Properties",
            help="Input method to configure Network Tap Rule. Example: File.",
            required=True,
            enum={"File": "File", "Inline": "Inline"},
        )
        _args_schema.dynamic_match_configurations = AAZListArg(
            options=["--dynamic-match-configurations"],
            arg_group="Properties",
            help="List of dynamic match configurations.",
        )
        _args_schema.match_configurations = AAZListArg(
            options=["--match-configurations"],
            arg_group="Properties",
            help="List of match configurations.",
        )
        _args_schema.polling_interval_in_seconds = AAZIntArg(
            options=["--polling-interval-in-seconds"],
            arg_group="Properties",
            help="Polling interval in seconds. Default value is 30. Example: 60.",
            enum={"120": 120, "30": 30, "60": 60, "90": 90},
        )
        _args_schema.tap_rules_url = AAZStrArg(
            options=["--tap-rules-url"],
            arg_group="Properties",
            help="Network Tap Rules file URL.",
            fmt=AAZStrArgFormat(
                min_length=1,
            ),
        )

        dynamic_match_configurations = cls._args_schema.dynamic_match_configurations
        dynamic_match_configurations.Element = AAZObjectArg()

        _element = cls._args_schema.dynamic_match_configurations.Element
        _element.ip_groups = AAZListArg(
            options=["ip-groups"],
            help="List of IP Groups.",
        )
        _element.port_groups = AAZListArg(
            options=["port-groups"],
            help="List of the port group.",
        )
        _element.vlan_groups = AAZListArg(
            options=["vlan-groups"],
            help="List of vlan groups.",
        )

        ip_groups = cls._args_schema.dynamic_match_configurations.Element.ip_groups
        ip_groups.Element = AAZObjectArg()

        _element = cls._args_schema.dynamic_match_configurations.Element.ip_groups.Element
        _element.ip_address_type = AAZStrArg(
            options=["ip-address-type"],
            help="IP Address type. Example: IPv4.",
            enum={"IPv4": "IPv4", "IPv6": "IPv6"},
            fmt=AAZStrArgFormat(
                min_length=1,
            ),
        )
        _element.ip_prefixes = AAZListArg(
            options=["ip-prefixes"],
            help="List of IP Prefixes.",
        )
        _element.name = AAZStrArg(
            options=["name"],
            help="IP Group name.",
            fmt=AAZStrArgFormat(
                min_length=1,
            ),
        )

        ip_prefixes = cls._args_schema.dynamic_match_configurations.Element.ip_groups.Element.ip_prefixes
        ip_prefixes.Element = AAZStrArg(
            fmt=AAZStrArgFormat(
                min_length=1,
            ),
        )

        port_groups = cls._args_schema.dynamic_match_configurations.Element.port_groups
        port_groups.Element = AAZObjectArg()

        _element = cls._args_schema.dynamic_match_configurations.Element.port_groups.Element
        _element.name = AAZStrArg(
            options=["name"],
            help="The name of the port group.",
            fmt=AAZStrArgFormat(
                min_length=1,
            ),
        )
        _element.ports = AAZListArg(
            options=["ports"],
            help="List of the ports that needs to be matched.",
        )

        ports = cls._args_schema.dynamic_match_configurations.Element.port_groups.Element.ports
        ports.Element = AAZStrArg(
            fmt=AAZStrArgFormat(
                min_length=1,
            ),
        )

        vlan_groups = cls._args_schema.dynamic_match_configurations.Element.vlan_groups
        vlan_groups.Element = AAZObjectArg()

        _element = cls._args_schema.dynamic_match_configurations.Element.vlan_groups.Element
        _element.name = AAZStrArg(
            options=["name"],
            help="Vlan group name.",
            fmt=AAZStrArgFormat(
                min_length=1,
            ),
        )
        _element.vlans = AAZListArg(
            options=["vlans"],
            help="List of vlans.",
        )

        vlans = cls._args_schema.dynamic_match_configurations.Element.vlan_groups.Element.vlans
        vlans.Element = AAZStrArg(
            fmt=AAZStrArgFormat(
                min_length=1,
            ),
        )

        match_configurations = cls._args_schema.match_configurations
        match_configurations.Element = AAZObjectArg()

        _element = cls._args_schema.match_configurations.Element
        _element.actions = AAZListArg(
            options=["actions"],
            help="List of actions that need to be performed for the matched conditions.",
        )
        _element.ip_address_type = AAZStrArg(
            options=["ip-address-type"],
            help="Type of IP Address. Example: IPv4.",
            enum={"IPv4": "IPv4", "IPv6": "IPv6"},
            fmt=AAZStrArgFormat(
                min_length=1,
            ),
        )
        _element.match_conditions = AAZListArg(
            options=["match-conditions"],
            help="List of the match conditions.",
        )
        _element.match_configuration_name = AAZStrArg(
            options=["match-configuration-name"],
            help="The name of the match configuration.",
            fmt=AAZStrArgFormat(
                min_length=1,
            ),
        )
        _element.sequence_number = AAZIntArg(
            options=["sequence-number"],
            help="Sequence Number of the match configuration.",
            fmt=AAZIntArgFormat(
                maximum=4294967295,
                minimum=1,
            ),
        )

        actions = cls._args_schema.match_configurations.Element.actions
        actions.Element = AAZObjectArg()

        _element = cls._args_schema.match_configurations.Element.actions.Element
        _element.destination_id = AAZResourceIdArg(
            options=["destination-id"],
            help="Destination Id. The ARM resource Id may be either Network To Network Interconnect or NeighborGroup.",
        )
        _element.is_timestamp_enabled = AAZStrArg(
            options=["is-timestamp-enabled"],
            help="The parameter to enable or disable the timestamp. Example: False.",
            enum={"False": "False", "True": "True"},
        )
        _element.match_configuration_name = AAZStrArg(
            options=["match-configuration-name"],
            help="The name of the match configuration. This is used when Goto type is provided. If Goto type is selected and no match configuration name is provided. It goes to next configuration.",
            fmt=AAZStrArgFormat(
                min_length=1,
            ),
        )
        _element.truncate = AAZStrArg(
            options=["truncate"],
            help="Truncate. 0 indicates do not truncate.",
            fmt=AAZStrArgFormat(
                min_length=1,
            ),
        )
        _element.type = AAZStrArg(
            options=["type"],
            help="Type of actions that can be performed. Example: Log.",
            enum={"Count": "Count", "Drop": "Drop", "Goto": "Goto", "Log": "Log", "Mirror": "Mirror", "Redirect": "Redirect", "Replicate": "Replicate"},
            fmt=AAZStrArgFormat(
                min_length=1,
            ),
        )

        match_conditions = cls._args_schema.match_configurations.Element.match_conditions
        match_conditions.Element = AAZObjectArg()

        _element = cls._args_schema.match_configurations.Element.match_conditions.Element
        _element.encapsulation_type = AAZStrArg(
            options=["encapsulation-type"],
            help="Encapsulation Type that needs to be matched. Example: None.",
            enum={"GTPv1": "GTPv1", "None": "None"},
            fmt=AAZStrArgFormat(
                min_length=1,
            ),
        )
        _element.ip_condition = AAZObjectArg(
            options=["ip-condition"],
            help="IP conditions that need to be matched.",
        )
        _element.port_condition = AAZObjectArg(
            options=["port-condition"],
            help="Port conditions that need to be matched.",
        )
        _element.protocol_types = AAZListArg(
            options=["protocol-types"],
            help="List of the protocols that need to be matched.",
        )
        _element.vlan_match_condition = AAZObjectArg(
            options=["vlan-match-condition"],
            help="Vlan match conditions that need to be matched.",
        )

        ip_condition = cls._args_schema.match_configurations.Element.match_conditions.Element.ip_condition
        ip_condition.ip_group_names = AAZListArg(
            options=["ip-group-names"],
            help="The List of IP Group Names that need to be matched.",
        )
        ip_condition.ip_prefix_values = AAZListArg(
            options=["ip-prefix-values"],
            help="The list of IP Prefixes.",
        )
        ip_condition.prefix_type = AAZStrArg(
            options=["prefix-type"],
            help="IP Prefix Type. Example: SourcePort.",
            enum={"LongestPrefix": "LongestPrefix", "Prefix": "Prefix"},
            fmt=AAZStrArgFormat(
                min_length=1,
            ),
        )
        ip_condition.type = AAZStrArg(
            options=["type"],
            help="IP Address type. Example: DestinationIP.",
            enum={"DestinationIP": "DestinationIP", "SourceIP": "SourceIP"},
            fmt=AAZStrArgFormat(
                min_length=1,
            ),
        )

        ip_group_names = cls._args_schema.match_configurations.Element.match_conditions.Element.ip_condition.ip_group_names
        ip_group_names.Element = AAZStrArg(
            fmt=AAZStrArgFormat(
                min_length=1,
            ),
        )

        ip_prefix_values = cls._args_schema.match_configurations.Element.match_conditions.Element.ip_condition.ip_prefix_values
        ip_prefix_values.Element = AAZStrArg(
            fmt=AAZStrArgFormat(
                min_length=1,
            ),
        )

        port_condition = cls._args_schema.match_configurations.Element.match_conditions.Element.port_condition
        port_condition.layer4_protocol = AAZStrArg(
            options=["layer4-protocol"],
            help="Layer4 protocol type that needs to be matched. Example: TCP.",
            required=True,
            enum={"TCP": "TCP", "UDP": "UDP"},
            fmt=AAZStrArgFormat(
                min_length=1,
            ),
        )
        port_condition.port_group_names = AAZListArg(
            options=["port-group-names"],
            help="List of the port Group Names that need to be matched.",
        )
        port_condition.port_type = AAZStrArg(
            options=["port-type"],
            help="Port type that needs to be matched. Example: SourcePort.",
            enum={"DestinationPort": "DestinationPort", "SourcePort": "SourcePort"},
            fmt=AAZStrArgFormat(
                min_length=1,
            ),
        )
        port_condition.ports = AAZListArg(
            options=["ports"],
            help="List of the Ports that need to be matched.",
        )

        port_group_names = cls._args_schema.match_configurations.Element.match_conditions.Element.port_condition.port_group_names
        port_group_names.Element = AAZStrArg(
            fmt=AAZStrArgFormat(
                min_length=1,
            ),
        )

        ports = cls._args_schema.match_configurations.Element.match_conditions.Element.port_condition.ports
        ports.Element = AAZStrArg(
            fmt=AAZStrArgFormat(
                min_length=1,
            ),
        )

        protocol_types = cls._args_schema.match_configurations.Element.match_conditions.Element.protocol_types
        protocol_types.Element = AAZStrArg(
            fmt=AAZStrArgFormat(
                min_length=1,
            ),
        )

        vlan_match_condition = cls._args_schema.match_configurations.Element.match_conditions.Element.vlan_match_condition
        vlan_match_condition.inner_vlans = AAZListArg(
            options=["inner-vlans"],
            help="List of inner vlans that need to be matched.",
        )
        vlan_match_condition.vlan_group_names = AAZListArg(
            options=["vlan-group-names"],
            help="List of vlan group names that need to be matched.",
        )
        vlan_match_condition.vlans = AAZListArg(
            options=["vlans"],
            help="List of vlans that need to be matched.",
        )

        inner_vlans = cls._args_schema.match_configurations.Element.match_conditions.Element.vlan_match_condition.inner_vlans
        inner_vlans.Element = AAZStrArg(
            fmt=AAZStrArgFormat(
                min_length=1,
            ),
        )

        vlan_group_names = cls._args_schema.match_configurations.Element.match_conditions.Element.vlan_match_condition.vlan_group_names
        vlan_group_names.Element = AAZStrArg(
            fmt=AAZStrArgFormat(
                min_length=1,
            ),
        )

        vlans = cls._args_schema.match_configurations.Element.match_conditions.Element.vlan_match_condition.vlans
        vlans.Element = AAZStrArg(
            fmt=AAZStrArgFormat(
                min_length=1,
            ),
        )
        return cls._args_schema

    def _execute_operations(self):
        self.pre_operations()
        yield self.NetworkTapRulesCreate(ctx=self.ctx)()
        self.post_operations()

    @register_callback
    def pre_operations(self):
        pass

    @register_callback
    def post_operations(self):
        pass

    def _output(self, *args, **kwargs):
        result = self.deserialize_output(self.ctx.vars.instance, client_flatten=True)
        return result

    class NetworkTapRulesCreate(AAZHttpOperation):
        CLIENT_TYPE = "MgmtClient"

        def __call__(self, *args, **kwargs):
            request = self.make_request()
            session = self.client.send_request(request=request, stream=False, **kwargs)
            if session.http_response.status_code in [202]:
                return self.client.build_lro_polling(
                    self.ctx.args.no_wait,
                    session,
                    self.on_200_201,
                    self.on_error,
                    lro_options={"final-state-via": "azure-async-operation"},
                    path_format_arguments=self.url_parameters,
                )
            if session.http_response.status_code in [200, 201]:
                return self.client.build_lro_polling(
                    self.ctx.args.no_wait,
                    session,
                    self.on_200_201,
                    self.on_error,
                    lro_options={"final-state-via": "azure-async-operation"},
                    path_format_arguments=self.url_parameters,
                )

            return self.on_error(session.http_response)

        @property
        def url(self):
            return self.client.format_url(
                "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}",
                **self.url_parameters
            )

        @property
        def method(self):
            return "PUT"

        @property
        def error_format(self):
            return "MgmtErrorFormat"

        @property
        def url_parameters(self):
            parameters = {
                **self.serialize_url_param(
                    "networkTapRuleName", self.ctx.args.resource_name,
                    required=True,
                ),
                **self.serialize_url_param(
                    "resourceGroupName", self.ctx.args.resource_group,
                    required=True,
                ),
                **self.serialize_url_param(
                    "subscriptionId", self.ctx.subscription_id,
                    required=True,
                ),
            }
            return parameters

        @property
        def query_parameters(self):
            parameters = {
                **self.serialize_query_param(
                    "api-version", "2023-06-15",
                    required=True,
                ),
            }
            return parameters

        @property
        def header_parameters(self):
            parameters = {
                **self.serialize_header_param(
                    "Content-Type", "application/json",
                ),
                **self.serialize_header_param(
                    "Accept", "application/json",
                ),
            }
            return parameters

        @property
        def content(self):
            _content_value, _builder = self.new_content_builder(
                self.ctx.args,
                typ=AAZObjectType,
                typ_kwargs={"flags": {"required": True, "client_flatten": True}}
            )
            _builder.set_prop("location", AAZStrType, ".location", typ_kwargs={"flags": {"required": True}})
            _builder.set_prop("properties", AAZObjectType, ".", typ_kwargs={"flags": {"required": True, "client_flatten": True}})
            _builder.set_prop("tags", AAZDictType, ".tags")

            properties = _builder.get(".properties")
            if properties is not None:
                properties.set_prop("annotation", AAZStrType, ".annotation")
                properties.set_prop("configurationType", AAZStrType, ".configuration_type", typ_kwargs={"flags": {"required": True}})
                properties.set_prop("dynamicMatchConfigurations", AAZListType, ".dynamic_match_configurations")
                properties.set_prop("matchConfigurations", AAZListType, ".match_configurations")
                properties.set_prop("pollingIntervalInSeconds", AAZIntType, ".polling_interval_in_seconds")
                properties.set_prop("tapRulesUrl", AAZStrType, ".tap_rules_url")

            dynamic_match_configurations = _builder.get(".properties.dynamicMatchConfigurations")
            if dynamic_match_configurations is not None:
                dynamic_match_configurations.set_elements(AAZObjectType, ".")

            _elements = _builder.get(".properties.dynamicMatchConfigurations[]")
            if _elements is not None:
                _elements.set_prop("ipGroups", AAZListType, ".ip_groups")
                _elements.set_prop("portGroups", AAZListType, ".port_groups")
                _elements.set_prop("vlanGroups", AAZListType, ".vlan_groups")

            ip_groups = _builder.get(".properties.dynamicMatchConfigurations[].ipGroups")
            if ip_groups is not None:
                ip_groups.set_elements(AAZObjectType, ".")

            _elements = _builder.get(".properties.dynamicMatchConfigurations[].ipGroups[]")
            if _elements is not None:
                _elements.set_prop("ipAddressType", AAZStrType, ".ip_address_type")
                _elements.set_prop("ipPrefixes", AAZListType, ".ip_prefixes")
                _elements.set_prop("name", AAZStrType, ".name")

            ip_prefixes = _builder.get(".properties.dynamicMatchConfigurations[].ipGroups[].ipPrefixes")
            if ip_prefixes is not None:
                ip_prefixes.set_elements(AAZStrType, ".")

            port_groups = _builder.get(".properties.dynamicMatchConfigurations[].portGroups")
            if port_groups is not None:
                port_groups.set_elements(AAZObjectType, ".")

            _elements = _builder.get(".properties.dynamicMatchConfigurations[].portGroups[]")
            if _elements is not None:
                _elements.set_prop("name", AAZStrType, ".name")
                _elements.set_prop("ports", AAZListType, ".ports")

            ports = _builder.get(".properties.dynamicMatchConfigurations[].portGroups[].ports")
            if ports is not None:
                ports.set_elements(AAZStrType, ".")

            vlan_groups = _builder.get(".properties.dynamicMatchConfigurations[].vlanGroups")
            if vlan_groups is not None:
                vlan_groups.set_elements(AAZObjectType, ".")

            _elements = _builder.get(".properties.dynamicMatchConfigurations[].vlanGroups[]")
            if _elements is not None:
                _elements.set_prop("name", AAZStrType, ".name")
                _elements.set_prop("vlans", AAZListType, ".vlans")

            vlans = _builder.get(".properties.dynamicMatchConfigurations[].vlanGroups[].vlans")
            if vlans is not None:
                vlans.set_elements(AAZStrType, ".")

            match_configurations = _builder.get(".properties.matchConfigurations")
            if match_configurations is not None:
                match_configurations.set_elements(AAZObjectType, ".")

            _elements = _builder.get(".properties.matchConfigurations[]")
            if _elements is not None:
                _elements.set_prop("actions", AAZListType, ".actions")
                _elements.set_prop("ipAddressType", AAZStrType, ".ip_address_type")
                _elements.set_prop("matchConditions", AAZListType, ".match_conditions")
                _elements.set_prop("matchConfigurationName", AAZStrType, ".match_configuration_name")
                _elements.set_prop("sequenceNumber", AAZIntType, ".sequence_number")

            actions = _builder.get(".properties.matchConfigurations[].actions")
            if actions is not None:
                actions.set_elements(AAZObjectType, ".")

            _elements = _builder.get(".properties.matchConfigurations[].actions[]")
            if _elements is not None:
                _elements.set_prop("destinationId", AAZStrType, ".destination_id")
                _elements.set_prop("isTimestampEnabled", AAZStrType, ".is_timestamp_enabled")
                _elements.set_prop("matchConfigurationName", AAZStrType, ".match_configuration_name")
                _elements.set_prop("truncate", AAZStrType, ".truncate")
                _elements.set_prop("type", AAZStrType, ".type")

            match_conditions = _builder.get(".properties.matchConfigurations[].matchConditions")
            if match_conditions is not None:
                match_conditions.set_elements(AAZObjectType, ".")

            _elements = _builder.get(".properties.matchConfigurations[].matchConditions[]")
            if _elements is not None:
                _elements.set_prop("encapsulationType", AAZStrType, ".encapsulation_type")
                _elements.set_prop("ipCondition", AAZObjectType, ".ip_condition")
                _elements.set_prop("portCondition", AAZObjectType, ".port_condition")
                _elements.set_prop("protocolTypes", AAZListType, ".protocol_types")
                _elements.set_prop("vlanMatchCondition", AAZObjectType, ".vlan_match_condition")

            ip_condition = _builder.get(".properties.matchConfigurations[].matchConditions[].ipCondition")
            if ip_condition is not None:
                ip_condition.set_prop("ipGroupNames", AAZListType, ".ip_group_names")
                ip_condition.set_prop("ipPrefixValues", AAZListType, ".ip_prefix_values")
                ip_condition.set_prop("prefixType", AAZStrType, ".prefix_type")
                ip_condition.set_prop("type", AAZStrType, ".type")

            ip_group_names = _builder.get(".properties.matchConfigurations[].matchConditions[].ipCondition.ipGroupNames")
            if ip_group_names is not None:
                ip_group_names.set_elements(AAZStrType, ".")

            ip_prefix_values = _builder.get(".properties.matchConfigurations[].matchConditions[].ipCondition.ipPrefixValues")
            if ip_prefix_values is not None:
                ip_prefix_values.set_elements(AAZStrType, ".")

            port_condition = _builder.get(".properties.matchConfigurations[].matchConditions[].portCondition")
            if port_condition is not None:
                port_condition.set_prop("layer4Protocol", AAZStrType, ".layer4_protocol", typ_kwargs={"flags": {"required": True}})
                port_condition.set_prop("portGroupNames", AAZListType, ".port_group_names")
                port_condition.set_prop("portType", AAZStrType, ".port_type")
                port_condition.set_prop("ports", AAZListType, ".ports")

            port_group_names = _builder.get(".properties.matchConfigurations[].matchConditions[].portCondition.portGroupNames")
            if port_group_names is not None:
                port_group_names.set_elements(AAZStrType, ".")

            ports = _builder.get(".properties.matchConfigurations[].matchConditions[].portCondition.ports")
            if ports is not None:
                ports.set_elements(AAZStrType, ".")

            protocol_types = _builder.get(".properties.matchConfigurations[].matchConditions[].protocolTypes")
            if protocol_types is not None:
                protocol_types.set_elements(AAZStrType, ".")

            vlan_match_condition = _builder.get(".properties.matchConfigurations[].matchConditions[].vlanMatchCondition")
            if vlan_match_condition is not None:
                vlan_match_condition.set_prop("innerVlans", AAZListType, ".inner_vlans")
                vlan_match_condition.set_prop("vlanGroupNames", AAZListType, ".vlan_group_names")
                vlan_match_condition.set_prop("vlans", AAZListType, ".vlans")

            inner_vlans = _builder.get(".properties.matchConfigurations[].matchConditions[].vlanMatchCondition.innerVlans")
            if inner_vlans is not None:
                inner_vlans.set_elements(AAZStrType, ".")

            vlan_group_names = _builder.get(".properties.matchConfigurations[].matchConditions[].vlanMatchCondition.vlanGroupNames")
            if vlan_group_names is not None:
                vlan_group_names.set_elements(AAZStrType, ".")

            vlans = _builder.get(".properties.matchConfigurations[].matchConditions[].vlanMatchCondition.vlans")
            if vlans is not None:
                vlans.set_elements(AAZStrType, ".")

            tags = _builder.get(".tags")
            if tags is not None:
                tags.set_elements(AAZStrType, ".")

            return self.serialize_content(_content_value)

        def on_200_201(self, session):
            data = self.deserialize_http_content(session)
            self.ctx.set_var(
                "instance",
                data,
                schema_builder=self._build_schema_on_200_201
            )

        _schema_on_200_201 = None

        @classmethod
        def _build_schema_on_200_201(cls):
            if cls._schema_on_200_201 is not None:
                return cls._schema_on_200_201

            cls._schema_on_200_201 = AAZObjectType()

            _schema_on_200_201 = cls._schema_on_200_201
            _schema_on_200_201.id = AAZStrType(
                flags={"read_only": True},
            )
            _schema_on_200_201.location = AAZStrType(
                flags={"required": True},
            )
            _schema_on_200_201.name = AAZStrType(
                flags={"read_only": True},
            )
            _schema_on_200_201.properties = AAZObjectType(
                flags={"required": True, "client_flatten": True},
            )
            _schema_on_200_201.system_data = AAZObjectType(
                serialized_name="systemData",
                flags={"read_only": True},
            )
            _schema_on_200_201.tags = AAZDictType()
            _schema_on_200_201.type = AAZStrType(
                flags={"read_only": True},
            )

            properties = cls._schema_on_200_201.properties
            properties.administrative_state = AAZStrType(
                serialized_name="administrativeState",
                flags={"read_only": True},
            )
            properties.annotation = AAZStrType()
            properties.configuration_state = AAZStrType(
                serialized_name="configurationState",
                flags={"read_only": True},
            )
            properties.configuration_type = AAZStrType(
                serialized_name="configurationType",
                flags={"required": True},
            )
            properties.dynamic_match_configurations = AAZListType(
                serialized_name="dynamicMatchConfigurations",
            )
            properties.last_synced_time = AAZStrType(
                serialized_name="lastSyncedTime",
                flags={"read_only": True},
            )
            properties.match_configurations = AAZListType(
                serialized_name="matchConfigurations",
            )
            properties.network_tap_id = AAZStrType(
                serialized_name="networkTapId",
                flags={"read_only": True},
            )
            properties.polling_interval_in_seconds = AAZIntType(
                serialized_name="pollingIntervalInSeconds",
            )
            properties.provisioning_state = AAZStrType(
                serialized_name="provisioningState",
                flags={"read_only": True},
            )
            properties.tap_rules_url = AAZStrType(
                serialized_name="tapRulesUrl",
            )

            dynamic_match_configurations = cls._schema_on_200_201.properties.dynamic_match_configurations
            dynamic_match_configurations.Element = AAZObjectType()

            _element = cls._schema_on_200_201.properties.dynamic_match_configurations.Element
            _element.ip_groups = AAZListType(
                serialized_name="ipGroups",
            )
            _element.port_groups = AAZListType(
                serialized_name="portGroups",
            )
            _element.vlan_groups = AAZListType(
                serialized_name="vlanGroups",
            )

            ip_groups = cls._schema_on_200_201.properties.dynamic_match_configurations.Element.ip_groups
            ip_groups.Element = AAZObjectType()

            _element = cls._schema_on_200_201.properties.dynamic_match_configurations.Element.ip_groups.Element
            _element.ip_address_type = AAZStrType(
                serialized_name="ipAddressType",
            )
            _element.ip_prefixes = AAZListType(
                serialized_name="ipPrefixes",
            )
            _element.name = AAZStrType()

            ip_prefixes = cls._schema_on_200_201.properties.dynamic_match_configurations.Element.ip_groups.Element.ip_prefixes
            ip_prefixes.Element = AAZStrType()

            port_groups = cls._schema_on_200_201.properties.dynamic_match_configurations.Element.port_groups
            port_groups.Element = AAZObjectType()

            _element = cls._schema_on_200_201.properties.dynamic_match_configurations.Element.port_groups.Element
            _element.name = AAZStrType()
            _element.ports = AAZListType()

            ports = cls._schema_on_200_201.properties.dynamic_match_configurations.Element.port_groups.Element.ports
            ports.Element = AAZStrType()

            vlan_groups = cls._schema_on_200_201.properties.dynamic_match_configurations.Element.vlan_groups
            vlan_groups.Element = AAZObjectType()

            _element = cls._schema_on_200_201.properties.dynamic_match_configurations.Element.vlan_groups.Element
            _element.name = AAZStrType()
            _element.vlans = AAZListType()

            vlans = cls._schema_on_200_201.properties.dynamic_match_configurations.Element.vlan_groups.Element.vlans
            vlans.Element = AAZStrType()

            match_configurations = cls._schema_on_200_201.properties.match_configurations
            match_configurations.Element = AAZObjectType()

            _element = cls._schema_on_200_201.properties.match_configurations.Element
            _element.actions = AAZListType()
            _element.ip_address_type = AAZStrType(
                serialized_name="ipAddressType",
            )
            _element.match_conditions = AAZListType(
                serialized_name="matchConditions",
            )
            _element.match_configuration_name = AAZStrType(
                serialized_name="matchConfigurationName",
            )
            _element.sequence_number = AAZIntType(
                serialized_name="sequenceNumber",
            )

            actions = cls._schema_on_200_201.properties.match_configurations.Element.actions
            actions.Element = AAZObjectType()

            _element = cls._schema_on_200_201.properties.match_configurations.Element.actions.Element
            _element.destination_id = AAZStrType(
                serialized_name="destinationId",
            )
            _element.is_timestamp_enabled = AAZStrType(
                serialized_name="isTimestampEnabled",
            )
            _element.match_configuration_name = AAZStrType(
                serialized_name="matchConfigurationName",
            )
            _element.truncate = AAZStrType()
            _element.type = AAZStrType()

            match_conditions = cls._schema_on_200_201.properties.match_configurations.Element.match_conditions
            match_conditions.Element = AAZObjectType()

            _element = cls._schema_on_200_201.properties.match_configurations.Element.match_conditions.Element
            _element.encapsulation_type = AAZStrType(
                serialized_name="encapsulationType",
            )
            _element.ip_condition = AAZObjectType(
                serialized_name="ipCondition",
            )
            _element.port_condition = AAZObjectType(
                serialized_name="portCondition",
            )
            _element.protocol_types = AAZListType(
                serialized_name="protocolTypes",
            )
            _element.vlan_match_condition = AAZObjectType(
                serialized_name="vlanMatchCondition",
            )

            ip_condition = cls._schema_on_200_201.properties.match_configurations.Element.match_conditions.Element.ip_condition
            ip_condition.ip_group_names = AAZListType(
                serialized_name="ipGroupNames",
            )
            ip_condition.ip_prefix_values = AAZListType(
                serialized_name="ipPrefixValues",
            )
            ip_condition.prefix_type = AAZStrType(
                serialized_name="prefixType",
            )
            ip_condition.type = AAZStrType()

            ip_group_names = cls._schema_on_200_201.properties.match_configurations.Element.match_conditions.Element.ip_condition.ip_group_names
            ip_group_names.Element = AAZStrType()

            ip_prefix_values = cls._schema_on_200_201.properties.match_configurations.Element.match_conditions.Element.ip_condition.ip_prefix_values
            ip_prefix_values.Element = AAZStrType()

            port_condition = cls._schema_on_200_201.properties.match_configurations.Element.match_conditions.Element.port_condition
            port_condition.layer4_protocol = AAZStrType(
                serialized_name="layer4Protocol",
                flags={"required": True},
            )
            port_condition.port_group_names = AAZListType(
                serialized_name="portGroupNames",
            )
            port_condition.port_type = AAZStrType(
                serialized_name="portType",
            )
            port_condition.ports = AAZListType()

            port_group_names = cls._schema_on_200_201.properties.match_configurations.Element.match_conditions.Element.port_condition.port_group_names
            port_group_names.Element = AAZStrType()

            ports = cls._schema_on_200_201.properties.match_configurations.Element.match_conditions.Element.port_condition.ports
            ports.Element = AAZStrType()

            protocol_types = cls._schema_on_200_201.properties.match_configurations.Element.match_conditions.Element.protocol_types
            protocol_types.Element = AAZStrType()

            vlan_match_condition = cls._schema_on_200_201.properties.match_configurations.Element.match_conditions.Element.vlan_match_condition
            vlan_match_condition.inner_vlans = AAZListType(
                serialized_name="innerVlans",
            )
            vlan_match_condition.vlan_group_names = AAZListType(
                serialized_name="vlanGroupNames",
            )
            vlan_match_condition.vlans = AAZListType()

            inner_vlans = cls._schema_on_200_201.properties.match_configurations.Element.match_conditions.Element.vlan_match_condition.inner_vlans
            inner_vlans.Element = AAZStrType()

            vlan_group_names = cls._schema_on_200_201.properties.match_configurations.Element.match_conditions.Element.vlan_match_condition.vlan_group_names
            vlan_group_names.Element = AAZStrType()

            vlans = cls._schema_on_200_201.properties.match_configurations.Element.match_conditions.Element.vlan_match_condition.vlans
            vlans.Element = AAZStrType()

            system_data = cls._schema_on_200_201.system_data
            system_data.created_at = AAZStrType(
                serialized_name="createdAt",
            )
            system_data.created_by = AAZStrType(
                serialized_name="createdBy",
            )
            system_data.created_by_type = AAZStrType(
                serialized_name="createdByType",
            )
            system_data.last_modified_at = AAZStrType(
                serialized_name="lastModifiedAt",
            )
            system_data.last_modified_by = AAZStrType(
                serialized_name="lastModifiedBy",
            )
            system_data.last_modified_by_type = AAZStrType(
                serialized_name="lastModifiedByType",
            )

            tags = cls._schema_on_200_201.tags
            tags.Element = AAZStrType()

            return cls._schema_on_200_201


class _CreateHelper:
    """Helper class for Create"""


__all__ = ["Create"]
