# --------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
#
# Code generated by aaz-dev-tools
# --------------------------------------------------------------------------------------------

# pylint: disable=too-many-lines, wildcard-import
# pylint: disable=too-many-statements, line-too-long, protected-access

from knack.log import get_logger
from azure.cli.core.aaz import has_value, register_command
from azure.cli.core.azclierror import RequiredArgumentMissingError
from azext_logic.aaz.latest.logic.workflow import Create as _WorkflowCreate
from azext_logic.aaz.latest.logic.workflow import Update as _WorkflowUpdate
from azext_logic.aaz.latest.logic.workflow import List as _WorkflowList
from azext_logic.aaz.latest.logic.workflow.identity import Assign as _IdentityAssign
from azext_logic.aaz.latest.logic.workflow.identity import Remove as _IdentityRemove
from azext_logic.aaz.latest.logic.integration_account import Create as _IntegrationAccountCreate
from azext_logic.aaz.latest.logic.integration_account import Update as _IntegrationAccountUpdate
from azext_logic.aaz.latest.logic.integration_account import List as _IntegrationAccountList
from azext_logic.aaz.latest.logic.integration_account.map import Create as _MapCreate
from azext_logic.aaz.latest.logic.integration_account.map import Update as _MapUpdate

logger = get_logger(__name__)


class MapCreate(_MapCreate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZFileArg
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.map_content = AAZFileArg(
            options=["--map-content"],
            help="The content.",
        )
        args_schema.content._registered = False
        return args_schema

    def pre_operations(self):
        args = self.ctx.args
        if has_value(args.map_content):
            args.content = args.map_content


class MapUpdate(_MapUpdate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZFileArg
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.map_content = AAZFileArg(
            options=["--map-content"],
            help="The content.",
        )
        args_schema.content._registered = False
        return args_schema

    def pre_instance_update(self, instance):
        if has_value(self.ctx.args.content_type):
            return
        if instance.properties.map_type in ['Xslt', 'Xslt20', 'Xslt30']:
            instance.properties.content_type = 'application/xml'
        if instance.properties.map_type == 'Liquid':
            instance.properties.content_type = 'text/plain'


class IntegrationAccountCreate(_IntegrationAccountCreate):
    def pre_operations(self):
        args = self.ctx.args
        if not has_value(args.state):
            args.state = 'Enabled'


class IntegrationAccountUpdate(_IntegrationAccountUpdate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.name._id_part = None
        return args_schema


@register_command(
    "logic integration-account import",
)
class IntegrationAccountImport(_IntegrationAccountCreate):
    """Import an integration account.

    :example: Import integration account
        az logic integration-account import --name integration-account-name --resource-group rg --input-path integration.json
    """
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZFreeFormDictArg, AAZFreeFormDictArgFormat
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.input_path = AAZFreeFormDictArg(
            options=["--input-path"],
            help="Path to a intergration-account file",
            required=True,
            fmt=AAZFreeFormDictArgFormat()
        )
        args_schema.state._registered = False
        args_schema.integration_service_environment._registered = False
        return args_schema

    def pre_operations(self):
        args = self.ctx.args
        if not has_value(args.state):
            args.state = 'Enabled'

        if 'properties' not in args.input_path:
            raise RequiredArgumentMissingError("--input-path does not contain a 'properties' key")
        input_path = args.input_path.to_serialized_data()
        args.tags = input_path.get('tags', args.tags)
        args.sku = input_path.get('sku', {}).get('name', args.sku)
        args.integration_service_environment = input_path['properties'].get('integration_service_environment', None)
        args.state = input_path['properties'].get('state', 'Enabled')


class WorkflowCreate(_WorkflowCreate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZBoolArg, AAZListArg, AAZResourceIdArg, AAZResourceIdArgFormat
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.mi_system_assigned = AAZBoolArg(
            options=["--mi-system-assigned"],
            help="Enable system assigned identity"
        )
        args_schema.mi_user_assigned = AAZListArg(
            options=["--mi-user-assigned"],
            help="Space separated resource IDs to add user-assigned identities.",
        )
        args_schema.mi_user_assigned.Element = AAZResourceIdArg(
            fmt=AAZResourceIdArgFormat(template="/subscriptions/{subscription}/resourceGroups/{resource_group}"
                                                "/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{}")
        )
        args_schema.identity._registered = False
        args_schema.parameters._registered = False
        return args_schema

    def pre_operations(self):
        args = self.ctx.args
        if 'definition' not in args.definition:
            raise RequiredArgumentMissingError("--definition does not contain a 'definition' key")
        definition = args.definition.to_serialized_data()
        args.access_control = definition.get('accessControl', args.access_control)
        args.parameters = definition.get('parameters', None)
        args.definition = definition['definition']
        if args.mi_system_assigned:
            args.identity.type = "SystemAssigned"
        if has_value(args.mi_user_assigned):
            args.identity.type = "UserAssigned" if not args.identity.type else "SystemAssigned,UserAssigned"
            user_assigned_identities = {}
            for identity in args.mi_user_assigned:
                user_assigned_identities.update({
                    identity.to_serialized_data(): {}
                })
            args.identity.user_assigned_identities = user_assigned_identities


class WorkflowUpdate(_WorkflowUpdate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.name._id_part = None
        args_schema.identity._registered = False
        args_schema.endpoints_configuration._registered = False
        args_schema.integration_service_environment._registered = False
        args_schema.integration_account._registered = False
        args_schema.access_control._registered = False
        args_schema.parameters._registered = False
        return args_schema

    def pre_operations(self):
        args = self.ctx.args
        if has_value(args.definition) and 'definition' not in args.definition:
            raise RequiredArgumentMissingError("--definition does not contain a 'definition' key")
        if has_value(args.definition):
            definition = args.definition.to_serialized_data()
            args.definition = definition['definition']
            args.access_control = definition.get('accessControl', args.access_control)
            args.parameters = definition.get('parameters', None)

    def pre_instance_update(self, instance):
        self.ctx.args.location = instance.location


class IdentityAssign(_IdentityAssign):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZBoolArg, AAZListArg, AAZResourceIdArg, AAZResourceIdArgFormat
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.system_assigned = AAZBoolArg(
            options=["--system-assigned"],
            help="Enable system assigned identity"
        )
        args_schema.user_assigned = AAZListArg(
            options=["--user-assigned"],
            help="Space separated resource IDs to add user-assigned identities.",
        )
        args_schema.user_assigned.Element = AAZResourceIdArg(
            fmt=AAZResourceIdArgFormat(template="/subscriptions/{subscription}/resourceGroups/{resource_group}"
                                                "/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{}")
        )
        args_schema.type._registered = False
        args_schema.type._required = False
        args_schema.user_assigned_identities._registered = False
        return args_schema

    def pre_operations(self):
        args = self.ctx.args
        if args.system_assigned:
            args.type = "SystemAssigned"
        if has_value(args.user_assigned):
            args.type = "UserAssigned" if not args.type else "SystemAssigned,UserAssigned"
            user_assigned_identities = {}
            for identity in args.user_assigned:
                user_assigned_identities.update({
                    identity.to_serialized_data(): {}
                })
            args.user_assigned_identities = user_assigned_identities

    def pre_instance_create(self):
        old_identity = self.ctx.vars.instance.identity
        args = self.ctx.args

        if args.system_assigned:
            args.type = "SystemAssigned" if not old_identity.type else "SystemAssigned,UserAssigned"
        if has_value(args.user_assigned):
            args.type = "UserAssigned" if not old_identity.type else "SystemAssigned,UserAssigned"
            if not old_identity.type:
                user_assigned_identities = {}
            else:
                user_assigned_identities = {} if 'UserAssigned' not in old_identity.type.to_serialized_data() else {**old_identity.user_assigned_identities.to_serialized_data()}
            for identity in args.user_assigned:
                user_assigned_identities.update({
                    identity.to_serialized_data(): {}
                })
            args.user_assigned_identities = user_assigned_identities


class IdentityRemove(_IdentityRemove):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZBoolArg, AAZListArg, AAZResourceIdArg, AAZResourceIdArgFormat
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.system_assigned = AAZBoolArg(
            options=["--system-assigned"],
            help="Enable system assigned identity"
        )
        args_schema.user_assigned = AAZListArg(
            options=["--user-assigned"],
            help="Space separated resource IDs to add user-assigned identities.",
        )
        args_schema.user_assigned.Element = AAZResourceIdArg(
            fmt=AAZResourceIdArgFormat(template="/subscriptions/{subscription}/resourceGroups/{resource_group}"
                                                "/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{}")
        )
        args_schema.type._registered = False
        args_schema.user_assigned_identities._registered = False
        return args_schema

    def pre_instance_update(self, instance):
        args = self.ctx.args
        if has_value(args.user_assigned):
            user_assigned_identities = instance.user_assigned_identities
            for identity in args.user_assigned:
                user_assigned_identities._data.pop(identity.to_serialized_data(), None)
            args.user_assigned_identities = user_assigned_identities
        if instance.user_assigned_identities and 'SystemAssigned' in instance.type.to_serialized_data():
            args.type = "SystemAssigned,UserAssigned"
        if not instance.user_assigned_identities and 'SystemAssigned' in instance.type.to_serialized_data():
            args.type = 'SystemAssigned'
        if args.system_assigned and instance.user_assigned_identities:
            args.type = 'UserAssigned'
        if args.system_assigned and instance.type.to_serialized_data() == 'SystemAssigned':
            args.type = 'None'
        if not instance.user_assigned_identities and instance.type.to_serialized_data() == 'UserAssigned':
            args.type = 'None'

    def _output(self, *args, **kwargs):
        if not self.ctx.vars.instance.identity.to_serialized_data():
            return {'type': None}
        return self.deserialize_output(self.ctx.selectors.subresource.required(), client_flatten=True)


class IntegrationAccountList(_IntegrationAccountList):
    def _output(self, *args, **kwargs):
        args = self.ctx.args
        result = self.deserialize_output(self.ctx.vars.instance.value, client_flatten=True)
        next_link = self.deserialize_output(self.ctx.vars.instance.next_link)
        if has_value(args.top):
            next_link = None
            if len(result) > self.ctx.args.top:
                result = result[:args.top.to_serialized_data()]
        return result, next_link


class WorkflowList(_WorkflowList):
    def _output(self, *args, **kwargs):
        args = self.ctx.args
        result = self.deserialize_output(self.ctx.vars.instance.value, client_flatten=True)
        next_link = self.deserialize_output(self.ctx.vars.instance.next_link)
        if has_value(args.top):
            next_link = None
            if len(result) > self.ctx.args.top:
                result = result[:args.top.to_serialized_data()]
        return result, next_link
