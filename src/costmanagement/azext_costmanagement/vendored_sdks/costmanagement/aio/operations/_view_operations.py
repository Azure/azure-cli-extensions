# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from typing import Any, AsyncIterable, Callable, Dict, Generic, List, Optional, TypeVar, Union
import warnings

from azure.core.async_paging import AsyncItemPaged, AsyncList
from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse, HttpRequest
from azure.mgmt.core.exceptions import ARMErrorFormat

from ... import models

T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class ViewOperations:
    """ViewOperations async operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~cost_management_client.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = models

    def __init__(self, client, config, serializer, deserializer) -> None:
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    def list(
        self,
        **kwargs
    ) -> AsyncIterable["models.ViewListResult"]:
        """Lists all views by tenant and object.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either ViewListResult or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~cost_management_client.models.ViewListResult]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.ViewListResult"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-06-01"
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('ViewListResult', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.ErrorResponse, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list.metadata = {'url': '/providers/Microsoft.CostManagement/views'}  # type: ignore

    def list_by_scope(
        self,
        scope: str,
        **kwargs
    ) -> AsyncIterable["models.ViewListResult"]:
        """Lists all views at the given scope.

        :param scope: The scope associated with view operations. This includes
         'subscriptions/{subscriptionId}' for subscription scope,
         'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
         Department scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
         for EnrollmentAccount scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
         for BillingProfile scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}'
         for InvoiceSection scope, 'providers/Microsoft.Management/managementGroups/{managementGroupId}'
         for Management Group scope,
         'providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}' for
         External Billing Account scope and
         'providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}' for
         External Subscription scope.
        :type scope: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either ViewListResult or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~cost_management_client.models.ViewListResult]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.ViewListResult"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-06-01"
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_by_scope.metadata['url']  # type: ignore
                path_format_arguments = {
                    'scope': self._serialize.url("scope", scope, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('ViewListResult', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.ErrorResponse, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_by_scope.metadata = {'url': '/{scope}/providers/Microsoft.CostManagement/views'}  # type: ignore

    async def get(
        self,
        view_name: str,
        **kwargs
    ) -> "models.View":
        """Gets the view by view name.

        :param view_name: View name.
        :type view_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: View, or the result of cls(response)
        :rtype: ~cost_management_client.models.View
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.View"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-06-01"
        accept = "application/json"

        # Construct URL
        url = self.get.metadata['url']  # type: ignore
        path_format_arguments = {
            'viewName': self._serialize.url("view_name", view_name, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('View', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get.metadata = {'url': '/providers/Microsoft.CostManagement/views/{viewName}'}  # type: ignore

    async def create_or_update(
        self,
        view_name: str,
        e_tag: Optional[str] = None,
        display_name: Optional[str] = None,
        scope: Optional[str] = None,
        chart: Optional[Union[str, "models.ChartType"]] = None,
        accumulated: Optional[Union[str, "models.AccumulatedType"]] = None,
        metric: Optional[Union[str, "models.MetricType"]] = None,
        kpis: Optional[List["models.KpiProperties"]] = None,
        pivots: Optional[List["models.PivotProperties"]] = None,
        type_properties_query_type: Optional[Union[str, "models.ReportType"]] = None,
        timeframe: Optional[Union[str, "models.ReportTimeframeType"]] = None,
        time_period: Optional["models.ReportConfigTimePeriod"] = None,
        granularity: Optional[Union[str, "models.ReportGranularityType"]] = None,
        configuration: Optional["models.ReportConfigDatasetConfiguration"] = None,
        aggregation: Optional[Dict[str, "models.ReportConfigAggregation"]] = None,
        grouping: Optional[List["models.ReportConfigGrouping"]] = None,
        sorting: Optional[List["models.ReportConfigSorting"]] = None,
        filter: Optional["models.ReportConfigFilter"] = None,
        **kwargs
    ) -> "models.View":
        """The operation to create or update a view. Update operation requires latest eTag to be set in
        the request. You may obtain the latest eTag by performing a get operation. Create operation
        does not require eTag.

        :param view_name: View name.
        :type view_name: str
        :param e_tag: eTag of the resource. To handle concurrent update scenario, this field will be
         used to determine whether the user is updating the latest version or not.
        :type e_tag: str
        :param display_name: User input name of the view. Required.
        :type display_name: str
        :param scope: Cost Management scope to save the view on. This includes
         'subscriptions/{subscriptionId}' for subscription scope,
         'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
         Department scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
         for EnrollmentAccount scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
         for BillingProfile scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}'
         for InvoiceSection scope, 'providers/Microsoft.Management/managementGroups/{managementGroupId}'
         for Management Group scope,
         '/providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}' for
         ExternalBillingAccount scope, and
         '/providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}' for
         ExternalSubscription scope.
        :type scope: str
        :param chart: Chart type of the main view in Cost Analysis. Required.
        :type chart: str or ~cost_management_client.models.ChartType
        :param accumulated: Show costs accumulated over time.
        :type accumulated: str or ~cost_management_client.models.AccumulatedType
        :param metric: Metric to use when displaying costs.
        :type metric: str or ~cost_management_client.models.MetricType
        :param kpis: List of KPIs to show in Cost Analysis UI.
        :type kpis: list[~cost_management_client.models.KpiProperties]
        :param pivots: Configuration of 3 sub-views in the Cost Analysis UI.
        :type pivots: list[~cost_management_client.models.PivotProperties]
        :param type_properties_query_type: The type of the report. Usage represents actual usage,
         forecast represents forecasted data and UsageAndForecast represents both usage and forecasted
         data. Actual usage and forecasted data can be differentiated based on dates.
        :type type_properties_query_type: str or ~cost_management_client.models.ReportType
        :param timeframe: The time frame for pulling data for the report. If custom, then a specific
         time period must be provided.
        :type timeframe: str or ~cost_management_client.models.ReportTimeframeType
        :param time_period: Has time period for pulling data for the report.
        :type time_period: ~cost_management_client.models.ReportConfigTimePeriod
        :param granularity: The granularity of rows in the report.
        :type granularity: str or ~cost_management_client.models.ReportGranularityType
        :param configuration: Has configuration information for the data in the report. The
         configuration will be ignored if aggregation and grouping are provided.
        :type configuration: ~cost_management_client.models.ReportConfigDatasetConfiguration
        :param aggregation: Dictionary of aggregation expression to use in the report. The key of each
         item in the dictionary is the alias for the aggregated column. Report can have up to 2
         aggregation clauses.
        :type aggregation: dict[str, ~cost_management_client.models.ReportConfigAggregation]
        :param grouping: Array of group by expression to use in the report. Report can have up to 2
         group by clauses.
        :type grouping: list[~cost_management_client.models.ReportConfigGrouping]
        :param sorting: Array of order by expression to use in the report.
        :type sorting: list[~cost_management_client.models.ReportConfigSorting]
        :param filter: Has filter expression to use in the report.
        :type filter: ~cost_management_client.models.ReportConfigFilter
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: View, or the result of cls(response)
        :rtype: ~cost_management_client.models.View
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.View"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        parameters = models.View(e_tag=e_tag, display_name=display_name, scope=scope, chart=chart, accumulated=accumulated, metric=metric, kpis=kpis, pivots=pivots, type_properties_query_type=type_properties_query_type, timeframe=timeframe, time_period=time_period, granularity=granularity, configuration=configuration, aggregation=aggregation, grouping=grouping, sorting=sorting, filter=filter)
        api_version = "2020-06-01"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_or_update.metadata['url']  # type: ignore
        path_format_arguments = {
            'viewName': self._serialize.url("view_name", view_name, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(parameters, 'View')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if response.status_code == 200:
            deserialized = self._deserialize('View', pipeline_response)

        if response.status_code == 201:
            deserialized = self._deserialize('View', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update.metadata = {'url': '/providers/Microsoft.CostManagement/views/{viewName}'}  # type: ignore

    async def delete(
        self,
        view_name: str,
        **kwargs
    ) -> None:
        """The operation to delete a view.

        :param view_name: View name.
        :type view_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-06-01"
        accept = "application/json"

        # Construct URL
        url = self.delete.metadata['url']  # type: ignore
        path_format_arguments = {
            'viewName': self._serialize.url("view_name", view_name, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete.metadata = {'url': '/providers/Microsoft.CostManagement/views/{viewName}'}  # type: ignore

    async def get_by_scope(
        self,
        scope: str,
        view_name: str,
        **kwargs
    ) -> "models.View":
        """Gets the view for the defined scope by view name.

        :param scope: The scope associated with view operations. This includes
         'subscriptions/{subscriptionId}' for subscription scope,
         'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
         Department scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
         for EnrollmentAccount scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
         for BillingProfile scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}'
         for InvoiceSection scope, 'providers/Microsoft.Management/managementGroups/{managementGroupId}'
         for Management Group scope,
         'providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}' for
         External Billing Account scope and
         'providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}' for
         External Subscription scope.
        :type scope: str
        :param view_name: View name.
        :type view_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: View, or the result of cls(response)
        :rtype: ~cost_management_client.models.View
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.View"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-06-01"
        accept = "application/json"

        # Construct URL
        url = self.get_by_scope.metadata['url']  # type: ignore
        path_format_arguments = {
            'scope': self._serialize.url("scope", scope, 'str'),
            'viewName': self._serialize.url("view_name", view_name, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('View', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_by_scope.metadata = {'url': '/{scope}/providers/Microsoft.CostManagement/views/{viewName}'}  # type: ignore

    async def create_or_update_by_scope(
        self,
        scope: str,
        view_name: str,
        e_tag: Optional[str] = None,
        display_name: Optional[str] = None,
        view_properties_scope: Optional[str] = None,
        chart: Optional[Union[str, "models.ChartType"]] = None,
        accumulated: Optional[Union[str, "models.AccumulatedType"]] = None,
        metric: Optional[Union[str, "models.MetricType"]] = None,
        kpis: Optional[List["models.KpiProperties"]] = None,
        pivots: Optional[List["models.PivotProperties"]] = None,
        type_properties_query_type: Optional[Union[str, "models.ReportType"]] = None,
        timeframe: Optional[Union[str, "models.ReportTimeframeType"]] = None,
        time_period: Optional["models.ReportConfigTimePeriod"] = None,
        granularity: Optional[Union[str, "models.ReportGranularityType"]] = None,
        configuration: Optional["models.ReportConfigDatasetConfiguration"] = None,
        aggregation: Optional[Dict[str, "models.ReportConfigAggregation"]] = None,
        grouping: Optional[List["models.ReportConfigGrouping"]] = None,
        sorting: Optional[List["models.ReportConfigSorting"]] = None,
        filter: Optional["models.ReportConfigFilter"] = None,
        **kwargs
    ) -> "models.View":
        """The operation to create or update a view. Update operation requires latest eTag to be set in
        the request. You may obtain the latest eTag by performing a get operation. Create operation
        does not require eTag.

        :param scope: The scope associated with view operations. This includes
         'subscriptions/{subscriptionId}' for subscription scope,
         'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
         Department scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
         for EnrollmentAccount scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
         for BillingProfile scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}'
         for InvoiceSection scope, 'providers/Microsoft.Management/managementGroups/{managementGroupId}'
         for Management Group scope,
         'providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}' for
         External Billing Account scope and
         'providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}' for
         External Subscription scope.
        :type scope: str
        :param view_name: View name.
        :type view_name: str
        :param e_tag: eTag of the resource. To handle concurrent update scenario, this field will be
         used to determine whether the user is updating the latest version or not.
        :type e_tag: str
        :param display_name: User input name of the view. Required.
        :type display_name: str
        :param view_properties_scope: Cost Management scope to save the view on. This includes
         'subscriptions/{subscriptionId}' for subscription scope,
         'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
         Department scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
         for EnrollmentAccount scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
         for BillingProfile scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}'
         for InvoiceSection scope, 'providers/Microsoft.Management/managementGroups/{managementGroupId}'
         for Management Group scope,
         '/providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}' for
         ExternalBillingAccount scope, and
         '/providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}' for
         ExternalSubscription scope.
        :type view_properties_scope: str
        :param chart: Chart type of the main view in Cost Analysis. Required.
        :type chart: str or ~cost_management_client.models.ChartType
        :param accumulated: Show costs accumulated over time.
        :type accumulated: str or ~cost_management_client.models.AccumulatedType
        :param metric: Metric to use when displaying costs.
        :type metric: str or ~cost_management_client.models.MetricType
        :param kpis: List of KPIs to show in Cost Analysis UI.
        :type kpis: list[~cost_management_client.models.KpiProperties]
        :param pivots: Configuration of 3 sub-views in the Cost Analysis UI.
        :type pivots: list[~cost_management_client.models.PivotProperties]
        :param type_properties_query_type: The type of the report. Usage represents actual usage,
         forecast represents forecasted data and UsageAndForecast represents both usage and forecasted
         data. Actual usage and forecasted data can be differentiated based on dates.
        :type type_properties_query_type: str or ~cost_management_client.models.ReportType
        :param timeframe: The time frame for pulling data for the report. If custom, then a specific
         time period must be provided.
        :type timeframe: str or ~cost_management_client.models.ReportTimeframeType
        :param time_period: Has time period for pulling data for the report.
        :type time_period: ~cost_management_client.models.ReportConfigTimePeriod
        :param granularity: The granularity of rows in the report.
        :type granularity: str or ~cost_management_client.models.ReportGranularityType
        :param configuration: Has configuration information for the data in the report. The
         configuration will be ignored if aggregation and grouping are provided.
        :type configuration: ~cost_management_client.models.ReportConfigDatasetConfiguration
        :param aggregation: Dictionary of aggregation expression to use in the report. The key of each
         item in the dictionary is the alias for the aggregated column. Report can have up to 2
         aggregation clauses.
        :type aggregation: dict[str, ~cost_management_client.models.ReportConfigAggregation]
        :param grouping: Array of group by expression to use in the report. Report can have up to 2
         group by clauses.
        :type grouping: list[~cost_management_client.models.ReportConfigGrouping]
        :param sorting: Array of order by expression to use in the report.
        :type sorting: list[~cost_management_client.models.ReportConfigSorting]
        :param filter: Has filter expression to use in the report.
        :type filter: ~cost_management_client.models.ReportConfigFilter
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: View, or the result of cls(response)
        :rtype: ~cost_management_client.models.View
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.View"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        parameters = models.View(e_tag=e_tag, display_name=display_name, scope=view_properties_scope, chart=chart, accumulated=accumulated, metric=metric, kpis=kpis, pivots=pivots, type_properties_query_type=type_properties_query_type, timeframe=timeframe, time_period=time_period, granularity=granularity, configuration=configuration, aggregation=aggregation, grouping=grouping, sorting=sorting, filter=filter)
        api_version = "2020-06-01"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_or_update_by_scope.metadata['url']  # type: ignore
        path_format_arguments = {
            'scope': self._serialize.url("scope", scope, 'str'),
            'viewName': self._serialize.url("view_name", view_name, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(parameters, 'View')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if response.status_code == 200:
            deserialized = self._deserialize('View', pipeline_response)

        if response.status_code == 201:
            deserialized = self._deserialize('View', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_by_scope.metadata = {'url': '/{scope}/providers/Microsoft.CostManagement/views/{viewName}'}  # type: ignore

    async def delete_by_scope(
        self,
        scope: str,
        view_name: str,
        **kwargs
    ) -> None:
        """The operation to delete a view.

        :param scope: The scope associated with view operations. This includes
         'subscriptions/{subscriptionId}' for subscription scope,
         'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
         Department scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
         for EnrollmentAccount scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
         for BillingProfile scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}'
         for InvoiceSection scope, 'providers/Microsoft.Management/managementGroups/{managementGroupId}'
         for Management Group scope,
         'providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}' for
         External Billing Account scope and
         'providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}' for
         External Subscription scope.
        :type scope: str
        :param view_name: View name.
        :type view_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-06-01"
        accept = "application/json"

        # Construct URL
        url = self.delete_by_scope.metadata['url']  # type: ignore
        path_format_arguments = {
            'scope': self._serialize.url("scope", scope, 'str'),
            'viewName': self._serialize.url("view_name", view_name, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_by_scope.metadata = {'url': '/{scope}/providers/Microsoft.CostManagement/views/{viewName}'}  # type: ignore
