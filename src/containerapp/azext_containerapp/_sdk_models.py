# --------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# --------------------------------------------------------------------------------------------

# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------
# pylint: disable=line-too-long, super-with-arguments, too-many-instance-attributes

from msrest.serialization import Model
from msrest.exceptions import HttpOperationError


class AllowedAudiencesValidation(Model):
    """The configuration settings of the Allowed Audiences validation flow.

    :param allowed_audiences: The configuration settings of the allowed list
     of audiences from which to validate the JWT token.
    :type allowed_audiences: list[str]
    """

    _attribute_map = {
        'allowed_audiences': {'key': 'allowedAudiences', 'type': '[str]'},
    }

    def __init__(self, **kwargs):
        super(AllowedAudiencesValidation, self).__init__(**kwargs)
        self.allowed_audiences = kwargs.get('allowed_audiences', None)


class Apple(Model):
    """The configuration settings of the Apple provider.

    :param state: <code>Disabled</code> if the Apple provider should not be
     enabled despite the set registration; otherwise, <code>Enabled</code>.
     Possible values include: 'Enabled', 'Disabled'
    :type state: str or ~commondefinitions.models.IdentityProviderState
    :param registration: The configuration settings of the Apple registration.
    :type registration: ~commondefinitions.models.AppleRegistration
    :param login: The configuration settings of the login flow.
    :type login: ~commondefinitions.models.LoginScopes
    """

    _attribute_map = {
        'state': {'key': 'state', 'type': 'str'},
        'registration': {'key': 'registration', 'type': 'AppleRegistration'},
        'login': {'key': 'login', 'type': 'LoginScopes'},
    }

    def __init__(self, **kwargs):
        super(Apple, self).__init__(**kwargs)
        self.state = kwargs.get('state', None)
        self.registration = kwargs.get('registration', None)
        self.login = kwargs.get('login', None)


class AppleRegistration(Model):
    """The configuration settings of the registration for the Apple provider.

    :param client_id: The Client ID of the app used for login.
    :type client_id: str
    :param client_secret_ref_name: The app secret ref name that contains the
     client secret.
    :type client_secret_ref_name: str
    """

    _attribute_map = {
        'client_id': {'key': 'clientId', 'type': 'str'},
        'client_secret_ref_name': {'key': 'clientSecretRefName', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(AppleRegistration, self).__init__(**kwargs)
        self.client_id = kwargs.get('client_id', None)
        self.client_secret_ref_name = kwargs.get('client_secret_ref_name', None)


class AppLogsConfiguration(Model):
    """Configuration of application logs.

    :param destination: Logs destination
    :type destination: str
    :param log_analytics_configuration: Log Analytics configuration
    :type log_analytics_configuration:
     ~commondefinitions.models.LogAnalyticsConfiguration
    """

    _attribute_map = {
        'destination': {'key': 'destination', 'type': 'str'},
        'log_analytics_configuration': {'key': 'logAnalyticsConfiguration', 'type': 'LogAnalyticsConfiguration'},
    }

    def __init__(self, **kwargs):
        super(AppLogsConfiguration, self).__init__(**kwargs)
        self.destination = kwargs.get('destination', None)
        self.log_analytics_configuration = kwargs.get('log_analytics_configuration', None)


class AppRegistration(Model):
    """The configuration settings of the app registration for providers that have
    app ids and app secrets.

    :param app_id: The App ID of the app used for login.
    :type app_id: str
    :param app_secret_ref_name: The app secret ref name that contains the app
     secret.
    :type app_secret_ref_name: str
    """

    _attribute_map = {
        'app_id': {'key': 'appId', 'type': 'str'},
        'app_secret_ref_name': {'key': 'appSecretRefName', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(AppRegistration, self).__init__(**kwargs)
        self.app_id = kwargs.get('app_id', None)
        self.app_secret_ref_name = kwargs.get('app_secret_ref_name', None)


class Resource(Model):
    """Resource.

    Common fields that are returned in the response for all Azure Resource
    Manager resources.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
    :vartype id: str
    :ivar name: The name of the resource
    :vartype name: str
    :ivar type: The type of the resource. E.g.
     "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy
     and modifiedBy information.
    :vartype system_data: ~commondefinitions.models.SystemData
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'system_data': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
    }

    def __init__(self, **kwargs):
        super(Resource, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None
        self.system_data = None


class ProxyResource(Resource):
    """Proxy Resource.

    The resource model definition for a Azure Resource Manager proxy resource.
    It will not have tags and a location.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
    :vartype id: str
    :ivar name: The name of the resource
    :vartype name: str
    :ivar type: The type of the resource. E.g.
     "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy
     and modifiedBy information.
    :vartype system_data: ~commondefinitions.models.SystemData
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'system_data': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
    }

    # def __init__(self, **kwargs):
    #     super(ProxyResource, self).__init__(**kwargs)


class AuthConfig(ProxyResource):
    """Configuration settings for the Azure ContainerApp Authentication /
    Authorization feature.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
    :vartype id: str
    :ivar name: The name of the resource
    :vartype name: str
    :ivar type: The type of the resource. E.g.
     "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy
     and modifiedBy information.
    :vartype system_data: ~commondefinitions.models.SystemData
    :param state: <code>Enabled</code> if the Authentication / Authorization
     feature is enabled for the current app; otherwise, <code>Disabled</code>.
     Possible values include: 'Enabled', 'Disabled'
    :type state: str or ~commondefinitions.models.EasyAuthState
    :param global_validation: The configuration settings that determines the
     validation flow of users using ContainerApp Authentication/Authorization.
    :type global_validation: ~commondefinitions.models.GlobalValidation
    :param identity_providers: The configuration settings of each of the
     identity providers used to configure ContainerApp
     Authentication/Authorization.
    :type identity_providers: ~commondefinitions.models.IdentityProviders
    :param login: The configuration settings of the login flow of users using
     ContainerApp Authentication/Authorization.
    :type login: ~commondefinitions.models.Login
    :param http_settings: The configuration settings of the HTTP requests for
     authentication and authorization requests made against ContainerApp
     Authentication/Authorization.
    :type http_settings: ~commondefinitions.models.HttpSettings
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'system_data': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
        'state': {'key': 'properties.state', 'type': 'str'},
        'global_validation': {'key': 'properties.globalValidation', 'type': 'GlobalValidation'},
        'identity_providers': {'key': 'properties.identityProviders', 'type': 'IdentityProviders'},
        'login': {'key': 'properties.login', 'type': 'Login'},
        'http_settings': {'key': 'properties.httpSettings', 'type': 'HttpSettings'},
    }

    def __init__(self, **kwargs):
        super(AuthConfig, self).__init__(**kwargs)
        self.state = kwargs.get('state', None)
        self.global_validation = kwargs.get('global_validation', None)
        self.identity_providers = kwargs.get('identity_providers', None)
        self.login = kwargs.get('login', None)
        self.http_settings = kwargs.get('http_settings', None)


class AuthConfigCollection(Model):
    """AuthConfig collection ARM resource.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :param value: Required. Collection of resources.
    :type value: list[~commondefinitions.models.AuthConfig]
    :ivar next_link: Link to next page of resources.
    :vartype next_link: str
    """

    _validation = {
        'value': {'required': True},
        'next_link': {'readonly': True},
    }

    _attribute_map = {
        'value': {'key': 'value', 'type': '[AuthConfig]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(AuthConfigCollection, self).__init__(**kwargs)
        self.value = kwargs.get('value', None)
        self.next_link = None


class AvailableOperations(Model):
    """Available operations of the service.

    :param value: Collection of available operation details
    :type value: list[~commondefinitions.models.OperationDetail]
    :param next_link: URL client should use to fetch the next page (per server
     side paging).
     It's null for now, added for future use.
    :type next_link: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[OperationDetail]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(AvailableOperations, self).__init__(**kwargs)
        self.value = kwargs.get('value', None)
        self.next_link = kwargs.get('next_link', None)


class AzureActiveDirectory(Model):
    """The configuration settings of the Azure Active directory provider.

    :param state: <code>Disabled</code> if the Azure Active Directory provider
     should not be enabled despite the set registration; otherwise,
     <code>Enabled</code>. Possible values include: 'Enabled', 'Disabled'
    :type state: str or ~commondefinitions.models.IdentityProviderState
    :param registration: The configuration settings of the Azure Active
     Directory app registration.
    :type registration:
     ~commondefinitions.models.AzureActiveDirectoryRegistration
    :param login: The configuration settings of the Azure Active Directory
     login flow.
    :type login: ~commondefinitions.models.AzureActiveDirectoryLogin
    :param validation: The configuration settings of the Azure Active
     Directory token validation flow.
    :type validation: ~commondefinitions.models.AzureActiveDirectoryValidation
    """

    _attribute_map = {
        'state': {'key': 'state', 'type': 'str'},
        'registration': {'key': 'registration', 'type': 'AzureActiveDirectoryRegistration'},
        'login': {'key': 'login', 'type': 'AzureActiveDirectoryLogin'},
        'validation': {'key': 'validation', 'type': 'AzureActiveDirectoryValidation'},
    }

    def __init__(self, **kwargs):
        super(AzureActiveDirectory, self).__init__(**kwargs)
        self.state = kwargs.get('state', None)
        self.registration = kwargs.get('registration', None)
        self.login = kwargs.get('login', None)
        self.validation = kwargs.get('validation', None)


class AzureActiveDirectoryLogin(Model):
    """The configuration settings of the Azure Active Directory login flow.

    :param login_parameters: Login parameters to send to the OpenID Connect
     authorization endpoint when
     a user logs in. Each parameter must be in the form "key=value".
    :type login_parameters: list[str]
    :param disable_www_authenticate: <code>true</code> if the www-authenticate
     provider should be omitted from the request; otherwise,
     <code>false</code>. Possible values include: 'True', 'False'
    :type disable_www_authenticate: str or
     ~commondefinitions.models.DisableWwwAuthenticateMode
    """

    _attribute_map = {
        'login_parameters': {'key': 'loginParameters', 'type': '[str]'},
        'disable_www_authenticate': {'key': 'disableWwwAuthenticate', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(AzureActiveDirectoryLogin, self).__init__(**kwargs)
        self.login_parameters = kwargs.get('login_parameters', None)
        self.disable_www_authenticate = kwargs.get('disable_www_authenticate', None)


class AzureActiveDirectoryRegistration(Model):
    """The configuration settings of the Azure Active Directory app registration.

    :param open_id_issuer: The OpenID Connect Issuer URI that represents the
     entity which issues access tokens for this application.
     When using Azure Active Directory, this value is the URI of the directory
     tenant, e.g. https://login.microsoftonline.com/v2.0/{tenant-guid}/.
     This URI is a case-sensitive identifier for the token issuer.
     More information on OpenID Connect Discovery:
     http://openid.net/specs/openid-connect-discovery-1_0.html
    :type open_id_issuer: str
    :param client_id: The Client ID of this relying party application, known
     as the client_id.
     This setting is required for enabling OpenID Connection authentication
     with Azure Active Directory or
     other 3rd party OpenID Connect providers.
     More information on OpenID Connect:
     http://openid.net/specs/openid-connect-core-1_0.html
    :type client_id: str
    :param client_secret_ref_name: The app secret ref name that contains the
     client secret of the relying party application.
    :type client_secret_ref_name: str
    :param client_secret_certificate_thumbprint: An alternative to the client
     secret, that is the thumbprint of a certificate used for signing purposes.
     This property acts as
     a replacement for the Client Secret. It is also optional.
    :type client_secret_certificate_thumbprint: str
    :param client_secret_certificate_subject_alternative_name: An alternative
     to the client secret thumbprint, that is the subject alternative name of a
     certificate used for signing purposes. This property acts as
     a replacement for the Client Secret Certificate Thumbprint. It is also
     optional.
    :type client_secret_certificate_subject_alternative_name: str
    :param client_secret_certificate_issuer: An alternative to the client
     secret thumbprint, that is the issuer of a certificate used for signing
     purposes. This property acts as
     a replacement for the Client Secret Certificate Thumbprint. It is also
     optional.
    :type client_secret_certificate_issuer: str
    """

    _attribute_map = {
        'open_id_issuer': {'key': 'openIdIssuer', 'type': 'str'},
        'client_id': {'key': 'clientId', 'type': 'str'},
        'client_secret_ref_name': {'key': 'clientSecretRefName', 'type': 'str'},
        'client_secret_certificate_thumbprint': {'key': 'clientSecretCertificateThumbprint', 'type': 'str'},
        'client_secret_certificate_subject_alternative_name': {'key': 'clientSecretCertificateSubjectAlternativeName', 'type': 'str'},
        'client_secret_certificate_issuer': {'key': 'clientSecretCertificateIssuer', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(AzureActiveDirectoryRegistration, self).__init__(**kwargs)
        self.open_id_issuer = kwargs.get('open_id_issuer', None)
        self.client_id = kwargs.get('client_id', None)
        self.client_secret_ref_name = kwargs.get('client_secret_ref_name', None)
        self.client_secret_certificate_thumbprint = kwargs.get('client_secret_certificate_thumbprint', None)
        self.client_secret_certificate_subject_alternative_name = kwargs.get('client_secret_certificate_subject_alternative_name', None)
        self.client_secret_certificate_issuer = kwargs.get('client_secret_certificate_issuer', None)


class AzureActiveDirectoryValidation(Model):
    """The configuration settings of the Azure Active Directory token validation
    flow.

    :param allowed_audiences: The list of audiences that can make successful
     authentication/authorization requests.
    :type allowed_audiences: list[str]
    """

    _attribute_map = {
        'allowed_audiences': {'key': 'allowedAudiences', 'type': '[str]'},
    }

    def __init__(self, **kwargs):
        super(AzureActiveDirectoryValidation, self).__init__(**kwargs)
        self.allowed_audiences = kwargs.get('allowed_audiences', None)


class AzureCredentials(Model):
    """Container App credentials.

    :param client_id: Client Id.
    :type client_id: str
    :param client_secret: Client Secret.
    :type client_secret: str
    :param tenant_id: Tenant Id.
    :type tenant_id: str
    :param subscription_id: Subscription Id.
    :type subscription_id: str
    """

    _attribute_map = {
        'client_id': {'key': 'clientId', 'type': 'str'},
        'client_secret': {'key': 'clientSecret', 'type': 'str'},
        'tenant_id': {'key': 'tenantId', 'type': 'str'},
        'subscription_id': {'key': 'subscriptionId', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(AzureCredentials, self).__init__(**kwargs)
        self.client_id = kwargs.get('client_id', None)
        self.client_secret = kwargs.get('client_secret', None)
        self.tenant_id = kwargs.get('tenant_id', None)
        self.subscription_id = kwargs.get('subscription_id', None)


class AzureEntityResource(Resource):
    """Entity Resource.

    The resource model definition for an Azure Resource Manager resource with
    an etag.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
    :vartype id: str
    :ivar name: The name of the resource
    :vartype name: str
    :ivar type: The type of the resource. E.g.
     "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy
     and modifiedBy information.
    :vartype system_data: ~commondefinitions.models.SystemData
    :ivar etag: Resource Etag.
    :vartype etag: str
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'system_data': {'readonly': True},
        'etag': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
        'etag': {'key': 'etag', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(AzureEntityResource, self).__init__(**kwargs)
        self.etag = None


class AzureFileProperties(Model):
    """Azure File Properties.

    :param account_name: Storage account name for azure file.
    :type account_name: str
    :param account_key: Storage account key for azure file.
    :type account_key: str
    :param access_mode: Access mode for storage. Possible values include:
     'ReadOnly', 'ReadWrite'
    :type access_mode: str or ~commondefinitions.models.AccessMode
    :param share_name: Azure file share name.
    :type share_name: str
    """

    _attribute_map = {
        'account_name': {'key': 'accountName', 'type': 'str'},
        'account_key': {'key': 'accountKey', 'type': 'str'},
        'access_mode': {'key': 'accessMode', 'type': 'str'},
        'share_name': {'key': 'shareName', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(AzureFileProperties, self).__init__(**kwargs)
        self.account_name = kwargs.get('account_name', None)
        self.account_key = kwargs.get('account_key', None)
        self.access_mode = kwargs.get('access_mode', None)
        self.share_name = kwargs.get('share_name', None)


class AzureStaticWebApp(Model):
    """The configuration settings of the Azure Static Web Apps provider.

    :param state: <code>Disabled</code> if the Azure Static Web Apps provider
     should not be enabled despite the set registration; otherwise,
     <code>Enabled</code>. Possible values include: 'Enabled', 'Disabled'
    :type state: str or ~commondefinitions.models.IdentityProviderState
    :param registration: The configuration settings of the Azure Static Web
     Apps registration.
    :type registration:
     ~commondefinitions.models.AzureStaticWebAppRegistration
    """

    _attribute_map = {
        'state': {'key': 'state', 'type': 'str'},
        'registration': {'key': 'registration', 'type': 'AzureStaticWebAppRegistration'},
    }

    def __init__(self, **kwargs):
        super(AzureStaticWebApp, self).__init__(**kwargs)
        self.state = kwargs.get('state', None)
        self.registration = kwargs.get('registration', None)


class AzureStaticWebAppRegistration(Model):
    """The configuration settings of the registration for the Azure Static Web
    Apps provider.

    :param client_id: The Client ID of the app used for login.
    :type client_id: str
    """

    _attribute_map = {
        'client_id': {'key': 'clientId', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(AzureStaticWebAppRegistration, self).__init__(**kwargs)
        self.client_id = kwargs.get('client_id', None)


class TrackedResource(Resource):
    """Tracked Resource.

    The resource model definition for an Azure Resource Manager tracked top
    level resource which has 'tags' and a 'location'.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
    :vartype id: str
    :ivar name: The name of the resource
    :vartype name: str
    :ivar type: The type of the resource. E.g.
     "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy
     and modifiedBy information.
    :vartype system_data: ~commondefinitions.models.SystemData
    :param tags: Resource tags.
    :type tags: dict[str, str]
    :param location: Required. The geo-location where the resource lives
    :type location: str
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'system_data': {'readonly': True},
        'location': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'location': {'key': 'location', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(TrackedResource, self).__init__(**kwargs)
        self.tags = kwargs.get('tags', None)
        self.location = kwargs.get('location', None)


class Certificate(TrackedResource):
    """Certificate used for Custom Domain bindings of Container Apps in a Managed
    Environment.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
    :vartype id: str
    :ivar name: The name of the resource
    :vartype name: str
    :ivar type: The type of the resource. E.g.
     "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy
     and modifiedBy information.
    :vartype system_data: ~commondefinitions.models.SystemData
    :param tags: Resource tags.
    :type tags: dict[str, str]
    :param location: Required. The geo-location where the resource lives
    :type location: str
    :param properties: Certificate resource specific properties
    :type properties: ~commondefinitions.models.CertificateProperties
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'system_data': {'readonly': True},
        'location': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'location': {'key': 'location', 'type': 'str'},
        'properties': {'key': 'properties', 'type': 'CertificateProperties'},
    }

    def __init__(self, **kwargs):
        super(Certificate, self).__init__(**kwargs)
        self.properties = kwargs.get('properties', None)


class CertificateCollection(Model):
    """Collection of Certificates.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :param value: Required. Collection of resources.
    :type value: list[~commondefinitions.models.Certificate]
    :ivar next_link: Link to next page of resources.
    :vartype next_link: str
    """

    _validation = {
        'value': {'required': True},
        'next_link': {'readonly': True},
    }

    _attribute_map = {
        'value': {'key': 'value', 'type': '[Certificate]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(CertificateCollection, self).__init__(**kwargs)
        self.value = kwargs.get('value', None)
        self.next_link = None


class CertificatePatch(Model):
    """A certificate to update.

    :param tags: Application-specific metadata in the form of key-value pairs.
    :type tags: dict[str, str]
    """

    _attribute_map = {
        'tags': {'key': 'tags', 'type': '{str}'},
    }

    def __init__(self, **kwargs):
        super(CertificatePatch, self).__init__(**kwargs)
        self.tags = kwargs.get('tags', None)


class CertificateProperties(Model):
    """Certificate resource specific properties.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :param password: Certificate password.
    :type password: str
    :ivar subject_name: Subject name of the certificate.
    :vartype subject_name: str
    :param value: PFX or PEM blob
    :type value: bytearray
    :ivar issuer: Certificate issuer.
    :vartype issuer: str
    :ivar issue_date: Certificate issue Date.
    :vartype issue_date: datetime
    :ivar expiration_date: Certificate expiration date.
    :vartype expiration_date: datetime
    :ivar thumbprint: Certificate thumbprint.
    :vartype thumbprint: str
    :ivar valid: Is the certificate valid?.
    :vartype valid: bool
    :ivar public_key_hash: Public key hash.
    :vartype public_key_hash: str
    """

    _validation = {
        'subject_name': {'readonly': True},
        'issuer': {'readonly': True},
        'issue_date': {'readonly': True},
        'expiration_date': {'readonly': True},
        'thumbprint': {'readonly': True},
        'valid': {'readonly': True},
        'public_key_hash': {'readonly': True},
    }

    _attribute_map = {
        'password': {'key': 'password', 'type': 'str'},
        'subject_name': {'key': 'subjectName', 'type': 'str'},
        'value': {'key': 'value', 'type': 'bytearray'},
        'issuer': {'key': 'issuer', 'type': 'str'},
        'issue_date': {'key': 'issueDate', 'type': 'iso-8601'},
        'expiration_date': {'key': 'expirationDate', 'type': 'iso-8601'},
        'thumbprint': {'key': 'thumbprint', 'type': 'str'},
        'valid': {'key': 'valid', 'type': 'bool'},
        'public_key_hash': {'key': 'publicKeyHash', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(CertificateProperties, self).__init__(**kwargs)
        self.password = kwargs.get('password', None)
        self.subject_name = None
        self.value = kwargs.get('value', None)
        self.issuer = None
        self.issue_date = None
        self.expiration_date = None
        self.thumbprint = None
        self.valid = None
        self.public_key_hash = None


class ClientRegistration(Model):
    """The configuration settings of the app registration for providers that have
    client ids and client secrets.

    :param client_id: The Client ID of the app used for login.
    :type client_id: str
    :param client_secret_ref_name: The app secret ref name that contains the
     client secret.
    :type client_secret_ref_name: str
    """

    _attribute_map = {
        'client_id': {'key': 'clientId', 'type': 'str'},
        'client_secret_ref_name': {'key': 'clientSecretRefName', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(ClientRegistration, self).__init__(**kwargs)
        self.client_id = kwargs.get('client_id', None)
        self.client_secret_ref_name = kwargs.get('client_secret_ref_name', None)


class Configuration(Model):
    """Non versioned Container App configuration properties that define the
    mutable settings of a Container app.

    :param secrets: Collection of secrets used by a Container app
    :type secrets: list[~commondefinitions.models.Secret]
    :param active_revisions_mode: ActiveRevisionsMode controls how active
     revisions are handled for the Container app:
     <list><item>Multiple: multiple revisions can be active. If no value if
     provided, this is the default</item><item>Single: Only one revision can be
     active at a time. Revision weights can not be used in this
     mode</item></list>. Possible values include: 'multiple', 'single'
    :type active_revisions_mode: str or
     ~commondefinitions.models.ActiveRevisionsMode
    :param ingress: Ingress configurations.
    :type ingress: ~commondefinitions.models.Ingress
    :param dapr: Dapr configuration for the Container App.
    :type dapr: ~commondefinitions.models.Dapr
    :param registries: Collection of private container registry credentials
     for containers used by the Container app
    :type registries: list[~commondefinitions.models.RegistryCredentials]
    """

    _attribute_map = {
        'secrets': {'key': 'secrets', 'type': '[Secret]'},
        'active_revisions_mode': {'key': 'activeRevisionsMode', 'type': 'str'},
        'ingress': {'key': 'ingress', 'type': 'Ingress'},
        'dapr': {'key': 'dapr', 'type': 'Dapr'},
        'registries': {'key': 'registries', 'type': '[RegistryCredentials]'},
    }

    def __init__(self, **kwargs):
        super(Configuration, self).__init__(**kwargs)
        self.secrets = kwargs.get('secrets', None)
        self.active_revisions_mode = kwargs.get('active_revisions_mode', None)
        self.ingress = kwargs.get('ingress', None)
        self.dapr = kwargs.get('dapr', None)
        self.registries = kwargs.get('registries', None)


class Container(Model):
    """Container App container definition.

    :param image: Container image tag.
    :type image: str
    :param name: Custom container name.
    :type name: str
    :param command: Container start command.
    :type command: list[str]
    :param args: Container start command arguments.
    :type args: list[str]
    :param env: Container environment variables.
    :type env: list[~commondefinitions.models.EnvironmentVar]
    :param resources: Container resource requirements.
    :type resources: ~commondefinitions.models.ContainerResources
    :param probes: List of probes for the container.
    :type probes: list[~commondefinitions.models.ContainerAppProbe]
    :param volume_mounts: Container volume mounts.
    :type volume_mounts: list[~commondefinitions.models.VolumeMount]
    """

    _attribute_map = {
        'image': {'key': 'image', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'command': {'key': 'command', 'type': '[str]'},
        'args': {'key': 'args', 'type': '[str]'},
        'env': {'key': 'env', 'type': '[EnvironmentVar]'},
        'resources': {'key': 'resources', 'type': 'ContainerResources'},
        'probes': {'key': 'probes', 'type': '[ContainerAppProbe]'},
        'volume_mounts': {'key': 'volumeMounts', 'type': '[VolumeMount]'},
    }

    def __init__(self, **kwargs):
        super(Container, self).__init__(**kwargs)
        self.image = kwargs.get('image', None)
        self.name = kwargs.get('name', None)
        self.command = kwargs.get('command', None)
        self.args = kwargs.get('args', None)
        self.env = kwargs.get('env', None)
        self.resources = kwargs.get('resources', None)
        self.probes = kwargs.get('probes', None)
        self.volume_mounts = kwargs.get('volume_mounts', None)


class ContainerApp(TrackedResource):
    """Container App.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
    :vartype id: str
    :ivar name: The name of the resource
    :vartype name: str
    :ivar type: The type of the resource. E.g.
     "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy
     and modifiedBy information.
    :vartype system_data: ~commondefinitions.models.SystemData
    :param tags: Resource tags.
    :type tags: dict[str, str]
    :param location: Required. The geo-location where the resource lives
    :type location: str
    :param identity: managed identities for the Container App to interact with
     other Azure services without maintaining any secrets or credentials in
     code.
    :type identity: ~commondefinitions.models.ManagedServiceIdentity
    :ivar provisioning_state: Provisioning state of the Container App.
     Possible values include: 'InProgress', 'Succeeded', 'Failed', 'Canceled'
    :vartype provisioning_state: str or
     ~commondefinitions.models.ContainerAppProvisioningState
    :param managed_environment_id: Resource ID of the Container App's
     environment.
    :type managed_environment_id: str
    :ivar latest_revision_name: Name of the latest revision of the Container
     App.
    :vartype latest_revision_name: str
    :ivar latest_revision_fqdn: Fully Qualified Domain Name of the latest
     revision of the Container App.
    :vartype latest_revision_fqdn: str
    :ivar custom_domain_verification_id: Id used to verify domain name
     ownership
    :vartype custom_domain_verification_id: str
    :param configuration: Non versioned Container App configuration
     properties.
    :type configuration: ~commondefinitions.models.Configuration
    :param template: Container App versioned application definition.
    :type template: ~commondefinitions.models.Template
    :ivar outbound_ip_addresses: Outbound IP Addresses for container app.
    :vartype outbound_ip_addresses: list[str]
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'system_data': {'readonly': True},
        'location': {'required': True},
        'provisioning_state': {'readonly': True},
        'latest_revision_name': {'readonly': True},
        'latest_revision_fqdn': {'readonly': True},
        'custom_domain_verification_id': {'readonly': True},
        'outbound_ip_addresses': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'location': {'key': 'location', 'type': 'str'},
        'identity': {'key': 'identity', 'type': 'ManagedServiceIdentity'},
        'provisioning_state': {'key': 'properties.provisioningState', 'type': 'str'},
        'environment_id': {'key': 'properties.environmentId', 'type': 'str'},
        'latest_revision_name': {'key': 'properties.latestRevisionName', 'type': 'str'},
        'latest_revision_fqdn': {'key': 'properties.latestRevisionFqdn', 'type': 'str'},
        'custom_domain_verification_id': {'key': 'properties.customDomainVerificationId', 'type': 'str'},
        'configuration': {'key': 'properties.configuration', 'type': 'Configuration'},
        'template': {'key': 'properties.template', 'type': 'Template'},
        'outbound_ip_addresses': {'key': 'properties.outboundIPAddresses', 'type': '[str]'},
    }

    def __init__(self, **kwargs):
        super(ContainerApp, self).__init__(**kwargs)
        self.identity = kwargs.get('identity', None)
        self.provisioning_state = None
        self.environment_id = kwargs.get('environment_id', None)
        self.latest_revision_name = None
        self.latest_revision_fqdn = None
        self.custom_domain_verification_id = None
        self.configuration = kwargs.get('configuration', None)
        self.template = kwargs.get('template', None)
        self.outbound_ip_addresses = None


class ContainerAppCollection(Model):
    """Container App collection ARM resource.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :param value: Required. Collection of resources.
    :type value: list[~commondefinitions.models.ContainerApp]
    :ivar next_link: Link to next page of resources.
    :vartype next_link: str
    """

    _validation = {
        'value': {'required': True},
        'next_link': {'readonly': True},
    }

    _attribute_map = {
        'value': {'key': 'value', 'type': '[ContainerApp]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(ContainerAppCollection, self).__init__(**kwargs)
        self.value = kwargs.get('value', None)
        self.next_link = None


class ContainerAppPatch(Model):
    """Container App Patch.

    :param tags: Application-specific metadata in the form of key-value pairs.
    :type tags: dict[str, str]
    """

    _attribute_map = {
        'tags': {'key': 'tags', 'type': '{str}'},
    }

    def __init__(self, **kwargs):
        super(ContainerAppPatch, self).__init__(**kwargs)
        self.tags = kwargs.get('tags', None)


class ContainerAppProbe(Model):
    """Probe describes a health check to be performed against a container to
    determine whether it is alive or ready to receive traffic.

    :param failure_threshold: Minimum consecutive failures for the probe to be
     considered failed after having succeeded. Defaults to 3. Minimum value is
     1. Maximum value is 10.
    :type failure_threshold: int
    :param http_get: HTTPGet specifies the http request to perform.
    :type http_get: ~commondefinitions.models.ContainerAppProbeHttpGet
    :param initial_delay_seconds: Number of seconds after the container has
     started before liveness probes are initiated. Minimum value is 1. Maximum
     value is 60.
    :type initial_delay_seconds: int
    :param period_seconds: How often (in seconds) to perform the probe.
     Default to 10 seconds. Minimum value is 1. Maximum value is 240.
    :type period_seconds: int
    :param success_threshold: Minimum consecutive successes for the probe to
     be considered successful after having failed. Defaults to 1. Must be 1 for
     liveness and startup. Minimum value is 1. Maximum value is 10.
    :type success_threshold: int
    :param tcp_socket: TCPSocket specifies an action involving a TCP port. TCP
     hooks not yet supported.
    :type tcp_socket: ~commondefinitions.models.ContainerAppProbeTcpSocket
    :param termination_grace_period_seconds: Optional duration in seconds the
     pod needs to terminate gracefully upon probe failure. The grace period is
     the duration in seconds after the processes running in the pod are sent a
     termination signal and the time when the processes are forcibly halted
     with a kill signal. Set this value longer than the expected cleanup time
     for your process. If this value is nil, the pod's
     terminationGracePeriodSeconds will be used. Otherwise, this value
     overrides the value provided by the pod spec. Value must be non-negative
     integer. The value zero indicates stop immediately via the kill signal (no
     opportunity to shut down). This is an alpha field and requires enabling
     ProbeTerminationGracePeriod feature gate. Maximum value is 3600 seconds (1
     hour)
    :type termination_grace_period_seconds: long
    :param timeout_seconds: Number of seconds after which the probe times out.
     Defaults to 1 second. Minimum value is 1. Maximum value is 240.
    :type timeout_seconds: int
    :param type: The type of probe. Possible values include: 'liveness',
     'readiness', 'startup'
    :type type: str or ~commondefinitions.models.Type
    """

    _attribute_map = {
        'failure_threshold': {'key': 'failureThreshold', 'type': 'int'},
        'http_get': {'key': 'httpGet', 'type': 'ContainerAppProbeHttpGet'},
        'initial_delay_seconds': {'key': 'initialDelaySeconds', 'type': 'int'},
        'period_seconds': {'key': 'periodSeconds', 'type': 'int'},
        'success_threshold': {'key': 'successThreshold', 'type': 'int'},
        'tcp_socket': {'key': 'tcpSocket', 'type': 'ContainerAppProbeTcpSocket'},
        'termination_grace_period_seconds': {'key': 'terminationGracePeriodSeconds', 'type': 'long'},
        'timeout_seconds': {'key': 'timeoutSeconds', 'type': 'int'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(ContainerAppProbe, self).__init__(**kwargs)
        self.failure_threshold = kwargs.get('failure_threshold', None)
        self.http_get = kwargs.get('http_get', None)
        self.initial_delay_seconds = kwargs.get('initial_delay_seconds', None)
        self.period_seconds = kwargs.get('period_seconds', None)
        self.success_threshold = kwargs.get('success_threshold', None)
        self.tcp_socket = kwargs.get('tcp_socket', None)
        self.termination_grace_period_seconds = kwargs.get('termination_grace_period_seconds', None)
        self.timeout_seconds = kwargs.get('timeout_seconds', None)
        self.type = kwargs.get('type', None)


class ContainerAppProbeHttpGet(Model):
    """HTTPGet specifies the http request to perform.

    All required parameters must be populated in order to send to Azure.

    :param host: Host name to connect to, defaults to the pod IP. You probably
     want to set "Host" in httpHeaders instead.
    :type host: str
    :param http_headers: Custom headers to set in the request. HTTP allows
     repeated headers.
    :type http_headers:
     list[~commondefinitions.models.ContainerAppProbeHttpGetHttpHeadersItem]
    :param path: Path to access on the HTTP server.
    :type path: str
    :param port: Required. Name or number of the port to access on the
     container. Number must be in the range 1 to 65535. Name must be an
     IANA_SVC_NAME.
    :type port: int
    :param scheme: Scheme to use for connecting to the host. Defaults to HTTP.
    :type scheme: str
    """

    _validation = {
        'port': {'required': True},
    }

    _attribute_map = {
        'host': {'key': 'host', 'type': 'str'},
        'http_headers': {'key': 'httpHeaders', 'type': '[ContainerAppProbeHttpGetHttpHeadersItem]'},
        'path': {'key': 'path', 'type': 'str'},
        'port': {'key': 'port', 'type': 'int'},
        'scheme': {'key': 'scheme', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(ContainerAppProbeHttpGet, self).__init__(**kwargs)
        self.host = kwargs.get('host', None)
        self.http_headers = kwargs.get('http_headers', None)
        self.path = kwargs.get('path', None)
        self.port = kwargs.get('port', None)
        self.scheme = kwargs.get('scheme', None)


class ContainerAppProbeHttpGetHttpHeadersItem(Model):
    """HTTPHeader describes a custom header to be used in HTTP probes.

    All required parameters must be populated in order to send to Azure.

    :param name: Required. The header field name
    :type name: str
    :param value: Required. The header field value
    :type value: str
    """

    _validation = {
        'name': {'required': True},
        'value': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'value': {'key': 'value', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(ContainerAppProbeHttpGetHttpHeadersItem, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.value = kwargs.get('value', None)


class ContainerAppProbeTcpSocket(Model):
    """TCPSocket specifies an action involving a TCP port. TCP hooks not yet
    supported.

    All required parameters must be populated in order to send to Azure.

    :param host: Optional: Host name to connect to, defaults to the pod IP.
    :type host: str
    :param port: Required. Number or name of the port to access on the
     container. Number must be in the range 1 to 65535. Name must be an
     IANA_SVC_NAME.
    :type port: int
    """

    _validation = {
        'port': {'required': True},
    }

    _attribute_map = {
        'host': {'key': 'host', 'type': 'str'},
        'port': {'key': 'port', 'type': 'int'},
    }

    def __init__(self, **kwargs):
        super(ContainerAppProbeTcpSocket, self).__init__(**kwargs)
        self.host = kwargs.get('host', None)
        self.port = kwargs.get('port', None)


class ContainerAppSecret(Model):
    """Container App Secret.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar name: Secret Name.
    :vartype name: str
    :ivar value: Secret Value.
    :vartype value: str
    """

    _validation = {
        'name': {'readonly': True},
        'value': {'readonly': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'value': {'key': 'value', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(ContainerAppSecret, self).__init__(**kwargs)
        self.name = None
        self.value = None


class ContainerResources(Model):
    """Container App container resource requirements.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :param cpu: Required CPU in cores, e.g. 0.5
    :type cpu: float
    :param memory: Required memory, e.g. "250Mb"
    :type memory: str
    :ivar ephemeral_storage: Ephemeral Storage, e.g. "1Gi"
    :vartype ephemeral_storage: str
    """

    _validation = {
        'ephemeral_storage': {'readonly': True},
    }

    _attribute_map = {
        'cpu': {'key': 'cpu', 'type': 'float'},
        'memory': {'key': 'memory', 'type': 'str'},
        'ephemeral_storage': {'key': 'ephemeralStorage', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(ContainerResources, self).__init__(**kwargs)
        self.cpu = kwargs.get('cpu', None)
        self.memory = kwargs.get('memory', None)
        self.ephemeral_storage = None


class CustomDomain(Model):
    """Custom Domain of a Container App.

    :param name: Hostname.
    :type name: str
    :param binding_type: Custom Domain binding type. Possible values include:
     'Disabled', 'SniEnabled'
    :type binding_type: str or ~commondefinitions.models.BindingType
    :param certificate_id: Resource Id of the Certificate to be bound to this
     hostname. Must exist in the Managed Environment.
    :type certificate_id: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'binding_type': {'key': 'bindingType', 'type': 'str'},
        'certificate_id': {'key': 'certificateId', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(CustomDomain, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.binding_type = kwargs.get('binding_type', None)
        self.certificate_id = kwargs.get('certificate_id', None)


class IPSecurityRestrictions(Model):
    """IP Restrictions of a Container App.

    :param name: ipAddressRange
    :type name: str
    :param name: action
    :type name: str
    :param name: name
    :type name: str
    :param name: description
    :type name: str

    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'ipAddressRange': {'key': 'ipAddressRange', 'type': 'str'},
        'action': {'key': 'action', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(IPSecurityRestrictions, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.ipAddressRange = kwargs.get('ipAddressRange', None)
        self.action = kwargs.get('action', None)
        self.description = kwargs.get('description', None)


class CustomHostnameAnalysisResult(ProxyResource):
    """Custom domain analysis.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
    :vartype id: str
    :ivar name: The name of the resource
    :vartype name: str
    :ivar type: The type of the resource. E.g.
     "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy
     and modifiedBy information.
    :vartype system_data: ~commondefinitions.models.SystemData
    :ivar host_name: Host name that was analyzed
    :vartype host_name: str
    :ivar is_hostname_already_verified: <code>true</code> if hostname is
     already verified; otherwise, <code>false</code>.
    :vartype is_hostname_already_verified: bool
    :ivar custom_domain_verification_test: DNS verification test result.
     Possible values include: 'Passed', 'Failed', 'Skipped'
    :vartype custom_domain_verification_test: str or
     ~commondefinitions.models.DnsVerificationTestResult
    :ivar custom_domain_verification_failure_info: Raw failure information if
     DNS verification fails.
    :vartype custom_domain_verification_failure_info:
     ~commondefinitions.models.DefaultErrorResponse
    :ivar has_conflict_on_managed_environment: <code>true</code> if there is a
     conflict on the Container App's managed environment; otherwise,
     <code>false</code>.
    :vartype has_conflict_on_managed_environment: bool
    :ivar conflicting_container_app_resource_id: Name of the conflicting
     Container App on the Managed Environment if it's within the same
     subscription.
    :vartype conflicting_container_app_resource_id: str
    :param c_name_records: CName records visible for this hostname.
    :type c_name_records: list[str]
    :param txt_records: TXT records visible for this hostname.
    :type txt_records: list[str]
    :param a_records: A records visible for this hostname.
    :type a_records: list[str]
    :param alternate_cname_records: Alternate CName records visible for this
     hostname.
    :type alternate_cname_records: list[str]
    :param alternate_txt_records: Alternate TXT records visible for this
     hostname.
    :type alternate_txt_records: list[str]
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'system_data': {'readonly': True},
        'host_name': {'readonly': True},
        'is_hostname_already_verified': {'readonly': True},
        'custom_domain_verification_test': {'readonly': True},
        'custom_domain_verification_failure_info': {'readonly': True},
        'has_conflict_on_managed_environment': {'readonly': True},
        'conflicting_container_app_resource_id': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
        'host_name': {'key': 'properties.hostName', 'type': 'str'},
        'is_hostname_already_verified': {'key': 'properties.isHostnameAlreadyVerified', 'type': 'bool'},
        'custom_domain_verification_test': {'key': 'properties.customDomainVerificationTest', 'type': 'DnsVerificationTestResult'},
        'custom_domain_verification_failure_info': {'key': 'properties.customDomainVerificationFailureInfo', 'type': 'DefaultErrorResponse'},
        'has_conflict_on_managed_environment': {'key': 'properties.hasConflictOnManagedEnvironment', 'type': 'bool'},
        'conflicting_container_app_resource_id': {'key': 'properties.conflictingContainerAppResourceId', 'type': 'str'},
        'c_name_records': {'key': 'properties.cNameRecords', 'type': '[str]'},
        'txt_records': {'key': 'properties.txtRecords', 'type': '[str]'},
        'a_records': {'key': 'properties.aRecords', 'type': '[str]'},
        'alternate_cname_records': {'key': 'properties.alternateCNameRecords', 'type': '[str]'},
        'alternate_txt_records': {'key': 'properties.alternateTxtRecords', 'type': '[str]'},
    }

    def __init__(self, **kwargs):
        super(CustomHostnameAnalysisResult, self).__init__(**kwargs)
        self.host_name = None
        self.is_hostname_already_verified = None
        self.custom_domain_verification_test = None
        self.custom_domain_verification_failure_info = None
        self.has_conflict_on_managed_environment = None
        self.conflicting_container_app_resource_id = None
        self.c_name_records = kwargs.get('c_name_records', None)
        self.txt_records = kwargs.get('txt_records', None)
        self.a_records = kwargs.get('a_records', None)
        self.alternate_cname_records = kwargs.get('alternate_cname_records', None)
        self.alternate_txt_records = kwargs.get('alternate_txt_records', None)


class CustomOpenIdConnectProvider(Model):
    """The configuration settings of the custom Open ID Connect provider.

    :param state: <code>Disabled</code> if the custom Open ID Connect provider
     should not be enabled despite the set registration; otherwise,
     <code>Enabled</code>. Possible values include: 'Enabled', 'Disabled'
    :type state: str or ~commondefinitions.models.IdentityProviderState
    :param registration: The configuration settings of the app registration
     for the custom Open ID Connect provider.
    :type registration: ~commondefinitions.models.OpenIdConnectRegistration
    :param login: The configuration settings of the login flow of the custom
     Open ID Connect provider.
    :type login: ~commondefinitions.models.OpenIdConnectLogin
    """

    _attribute_map = {
        'state': {'key': 'state', 'type': 'str'},
        'registration': {'key': 'registration', 'type': 'OpenIdConnectRegistration'},
        'login': {'key': 'login', 'type': 'OpenIdConnectLogin'},
    }

    def __init__(self, **kwargs):
        super(CustomOpenIdConnectProvider, self).__init__(**kwargs)
        self.state = kwargs.get('state', None)
        self.registration = kwargs.get('registration', None)
        self.login = kwargs.get('login', None)


class CustomScaleRule(Model):
    """Container App container Custom scaling rule.

    :param type: Type of the custom scale rule
     eg: azure-servicebus, redis etc.
    :type type: str
    :param metadata: Metadata properties to describe custom scale rule.
    :type metadata: dict[str, str]
    :param auth: Authentication secrets for the custom scale rule.
    :type auth: list[~commondefinitions.models.ScaleRuleAuth]
    """

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'metadata': {'key': 'metadata', 'type': '{str}'},
        'auth': {'key': 'auth', 'type': '[ScaleRuleAuth]'},
    }

    def __init__(self, **kwargs):
        super(CustomScaleRule, self).__init__(**kwargs)
        self.type = kwargs.get('type', None)
        self.metadata = kwargs.get('metadata', None)
        self.auth = kwargs.get('auth', None)


class Dapr(Model):
    """Container App Dapr configuration.

    :param enabled: Boolean indicating if the Dapr side car is enabled
    :type enabled: bool
    :param app_id: Dapr application identifier
    :type app_id: str
    :param app_protocol: Tells Dapr which protocol your application is using.
     Valid options are http and grpc. Default is http. Possible values include:
     'http', 'grpc'
    :type app_protocol: str or ~commondefinitions.models.AppProtocol
    :param app_port: Tells Dapr which port your application is listening on
    :type app_port: int
    """

    _attribute_map = {
        'enabled': {'key': 'enabled', 'type': 'bool'},
        'app_id': {'key': 'appId', 'type': 'str'},
        'app_protocol': {'key': 'appProtocol', 'type': 'str'},
        'app_port': {'key': 'appPort', 'type': 'int'},
    }

    def __init__(self, **kwargs):
        super(Dapr, self).__init__(**kwargs)
        self.enabled = kwargs.get('enabled', None)
        self.app_id = kwargs.get('app_id', None)
        self.app_protocol = kwargs.get('app_protocol', None)
        self.app_port = kwargs.get('app_port', None)


class DaprComponent(ProxyResource):
    """Dapr Component.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
    :vartype id: str
    :ivar name: The name of the resource
    :vartype name: str
    :ivar type: The type of the resource. E.g.
     "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy
     and modifiedBy information.
    :vartype system_data: ~commondefinitions.models.SystemData
    :param component_type: Component type
    :type component_type: str
    :param version: Component version
    :type version: str
    :param ignore_errors: Boolean describing if the component errors are
     ignores
    :type ignore_errors: bool
    :param init_timeout: Initialization timeout
    :type init_timeout: str
    :param secrets: Collection of secrets used by a Dapr component
    :type secrets: list[~commondefinitions.models.Secret]
    :param metadata: Component metadata
    :type metadata: list[~commondefinitions.models.DaprMetadata]
    :param scopes: Names of container apps that can use this Dapr component
    :type scopes: list[str]
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'system_data': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
        'component_type': {'key': 'properties.componentType', 'type': 'str'},
        'version': {'key': 'properties.version', 'type': 'str'},
        'ignore_errors': {'key': 'properties.ignoreErrors', 'type': 'bool'},
        'init_timeout': {'key': 'properties.initTimeout', 'type': 'str'},
        'secrets': {'key': 'properties.secrets', 'type': '[Secret]'},
        'metadata': {'key': 'properties.metadata', 'type': '[DaprMetadata]'},
        'scopes': {'key': 'properties.scopes', 'type': '[str]'},
    }

    def __init__(self, **kwargs):
        super(DaprComponent, self).__init__(**kwargs)
        self.component_type = kwargs.get('component_type', None)
        self.version = kwargs.get('version', None)
        self.ignore_errors = kwargs.get('ignore_errors', None)
        self.init_timeout = kwargs.get('init_timeout', None)
        self.secrets = kwargs.get('secrets', None)
        self.metadata = kwargs.get('metadata', None)
        self.scopes = kwargs.get('scopes', None)


class DaprComponentsCollection(Model):
    """Dapr Components ARM resource.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :param value: Required. Collection of resources.
    :type value: list[~commondefinitions.models.DaprComponent]
    :ivar next_link: Link to next page of resources.
    :vartype next_link: str
    """

    _validation = {
        'value': {'required': True},
        'next_link': {'readonly': True},
    }

    _attribute_map = {
        'value': {'key': 'value', 'type': '[DaprComponent]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(DaprComponentsCollection, self).__init__(**kwargs)
        self.value = kwargs.get('value', None)
        self.next_link = None


class DaprMetadata(Model):
    """Dapr component metadata.

    :param name: Metadata property name.
    :type name: str
    :param value: Metadata property value.
    :type value: str
    :param secret_ref: Name of the Dapr Component secret from which to pull
     the metadata property value.
    :type secret_ref: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'value': {'key': 'value', 'type': 'str'},
        'secret_ref': {'key': 'secretRef', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(DaprMetadata, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.value = kwargs.get('value', None)
        self.secret_ref = kwargs.get('secret_ref', None)


class DefaultErrorResponse(Model):
    """App Service error response.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar error: Error model.
    :vartype error: ~commondefinitions.models.DefaultErrorResponseError
    """

    _validation = {
        'error': {'readonly': True},
    }

    _attribute_map = {
        'error': {'key': 'error', 'type': 'DefaultErrorResponseError'},
    }

    def __init__(self, **kwargs):
        super(DefaultErrorResponse, self).__init__(**kwargs)
        self.error = None


class DefaultErrorResponseException(HttpOperationError):
    """Server responsed with exception of type: 'DefaultErrorResponse'.

    :param deserialize: A deserializer
    :param response: Server response to be deserialized.
    """

    def __init__(self, deserialize, response, *args):

        super(DefaultErrorResponseException, self).__init__(deserialize, response, 'DefaultErrorResponse', *args)


class DefaultErrorResponseError(Model):
    """Error model.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar code: Standardized string to programmatically identify the error.
    :vartype code: str
    :ivar message: Detailed error description and debugging information.
    :vartype message: str
    :ivar target: Detailed error description and debugging information.
    :vartype target: str
    :param details: Details or the error
    :type details:
     list[~commondefinitions.models.DefaultErrorResponseErrorDetailsItem]
    :ivar innererror: More information to debug error.
    :vartype innererror: str
    """

    _validation = {
        'code': {'readonly': True},
        'message': {'readonly': True},
        'target': {'readonly': True},
        'innererror': {'readonly': True},
    }

    _attribute_map = {
        'code': {'key': 'code', 'type': 'str'},
        'message': {'key': 'message', 'type': 'str'},
        'target': {'key': 'target', 'type': 'str'},
        'details': {'key': 'details', 'type': '[DefaultErrorResponseErrorDetailsItem]'},
        'innererror': {'key': 'innererror', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(DefaultErrorResponseError, self).__init__(**kwargs)
        self.code = None
        self.message = None
        self.target = None
        self.details = kwargs.get('details', None)
        self.innererror = None


class DefaultErrorResponseErrorDetailsItem(Model):
    """Detailed errors.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar code: Standardized string to programmatically identify the error.
    :vartype code: str
    :ivar message: Detailed error description and debugging information.
    :vartype message: str
    :ivar target: Detailed error description and debugging information.
    :vartype target: str
    """

    _validation = {
        'code': {'readonly': True},
        'message': {'readonly': True},
        'target': {'readonly': True},
    }

    _attribute_map = {
        'code': {'key': 'code', 'type': 'str'},
        'message': {'key': 'message', 'type': 'str'},
        'target': {'key': 'target', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(DefaultErrorResponseErrorDetailsItem, self).__init__(**kwargs)
        self.code = None
        self.message = None
        self.target = None


class EnvironmentVar(Model):
    """Container App container environment variable.

    :param name: Environment variable name.
    :type name: str
    :param value: Non-secret environment variable value.
    :type value: str
    :param secret_ref: Name of the Container App secret from which to pull the
     environment variable value.
    :type secret_ref: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'value': {'key': 'value', 'type': 'str'},
        'secret_ref': {'key': 'secretRef', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(EnvironmentVar, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.value = kwargs.get('value', None)
        self.secret_ref = kwargs.get('secret_ref', None)


class Facebook(Model):
    """The configuration settings of the Facebook provider.

    :param state: <code>Disabled</code> if the Facebook provider should not be
     enabled despite the set registration; otherwise, <code>Enabled</code>.
     Possible values include: 'Enabled', 'Disabled'
    :type state: str or ~commondefinitions.models.IdentityProviderState
    :param registration: The configuration settings of the app registration
     for the Facebook provider.
    :type registration: ~commondefinitions.models.AppRegistration
    :param graph_api_version: The version of the Facebook api to be used while
     logging in.
    :type graph_api_version: str
    :param login: The configuration settings of the login flow.
    :type login: ~commondefinitions.models.LoginScopes
    """

    _attribute_map = {
        'state': {'key': 'state', 'type': 'str'},
        'registration': {'key': 'registration', 'type': 'AppRegistration'},
        'graph_api_version': {'key': 'graphApiVersion', 'type': 'str'},
        'login': {'key': 'login', 'type': 'LoginScopes'},
    }

    def __init__(self, **kwargs):
        super(Facebook, self).__init__(**kwargs)
        self.state = kwargs.get('state', None)
        self.registration = kwargs.get('registration', None)
        self.graph_api_version = kwargs.get('graph_api_version', None)
        self.login = kwargs.get('login', None)


class GitHub(Model):
    """The configuration settings of the GitHub provider.

    :param state: <code>Disabled</code> if the GitHub provider should not be
     enabled despite the set registration; otherwise, <code>Enabled</code>.
     Possible values include: 'Enabled', 'Disabled'
    :type state: str or ~commondefinitions.models.IdentityProviderState
    :param registration: The configuration settings of the app registration
     for the GitHub provider.
    :type registration: ~commondefinitions.models.ClientRegistration
    :param login: The configuration settings of the login flow.
    :type login: ~commondefinitions.models.LoginScopes
    """

    _attribute_map = {
        'state': {'key': 'state', 'type': 'str'},
        'registration': {'key': 'registration', 'type': 'ClientRegistration'},
        'login': {'key': 'login', 'type': 'LoginScopes'},
    }

    def __init__(self, **kwargs):
        super(GitHub, self).__init__(**kwargs)
        self.state = kwargs.get('state', None)
        self.registration = kwargs.get('registration', None)
        self.login = kwargs.get('login', None)


class GithubActionConfiguration(Model):
    """Configuration properties that define the mutable settings of a Container
    App SourceControl.

    :param registry_info: Registry configurations.
    :type registry_info: ~commondefinitions.models.RegistryInfo
    :param azure_credentials: AzureCredentials configurations.
    :type azure_credentials: ~commondefinitions.models.AzureCredentials
    :param dockerfile_path: Docker file path
    :type dockerfile_path: str
    :param publish_type: Code or Image
    :type publish_type: str
    :param os: Operation system
    :type os: str
    :param runtime_stack: Runtime stack
    :type runtime_stack: str
    :param runtime_version: Runtime Version
    :type runtime_version: str
    """

    _attribute_map = {
        'registry_info': {'key': 'registryInfo', 'type': 'RegistryInfo'},
        'azure_credentials': {'key': 'azureCredentials', 'type': 'AzureCredentials'},
        'dockerfile_path': {'key': 'dockerfilePath', 'type': 'str'},
        'publish_type': {'key': 'publishType', 'type': 'str'},
        'os': {'key': 'os', 'type': 'str'},
        'runtime_stack': {'key': 'runtimeStack', 'type': 'str'},
        'runtime_version': {'key': 'runtimeVersion', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(GithubActionConfiguration, self).__init__(**kwargs)
        self.registry_info = kwargs.get('registry_info', None)
        self.azure_credentials = kwargs.get('azure_credentials', None)
        self.dockerfile_path = kwargs.get('dockerfile_path', None)
        self.publish_type = kwargs.get('publish_type', None)
        self.os = kwargs.get('os', None)
        self.runtime_stack = kwargs.get('runtime_stack', None)
        self.runtime_version = kwargs.get('runtime_version', None)


class GlobalValidation(Model):
    """The configuration settings that determines the validation flow of users
    using ContainerApp Authentication/Authorization.

    :param unauthenticated_client_action: The action to take when an
     unauthenticated client attempts to access the app. Possible values
     include: 'RedirectToLoginPage', 'AllowAnonymous', 'Return401', 'Return403'
    :type unauthenticated_client_action: str or
     ~commondefinitions.models.UnauthenticatedClientAction
    :param redirect_to_provider: The default authentication provider to use
     when multiple providers are configured.
     This setting is only needed if multiple providers are configured and the
     unauthenticated client
     action is set to "RedirectToLoginPage".
    :type redirect_to_provider: str
    """

    _attribute_map = {
        'unauthenticated_client_action': {'key': 'unauthenticatedClientAction', 'type': 'str'},
        'redirect_to_provider': {'key': 'redirectToProvider', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(GlobalValidation, self).__init__(**kwargs)
        self.unauthenticated_client_action = kwargs.get('unauthenticated_client_action', None)
        self.redirect_to_provider = kwargs.get('redirect_to_provider', None)


class Google(Model):
    """The configuration settings of the Google provider.

    :param state: <code>Disabled</code> if the Google provider should not be
     enabled despite the set registration; otherwise, <code>Enabled</code>.
     Possible values include: 'Enabled', 'Disabled'
    :type state: str or ~commondefinitions.models.IdentityProviderState
    :param registration: The configuration settings of the app registration
     for the Google provider.
    :type registration: ~commondefinitions.models.ClientRegistration
    :param login: The configuration settings of the login flow.
    :type login: ~commondefinitions.models.LoginScopes
    :param validation: The configuration settings of the Azure Active
     Directory token validation flow.
    :type validation: ~commondefinitions.models.AllowedAudiencesValidation
    """

    _attribute_map = {
        'state': {'key': 'state', 'type': 'str'},
        'registration': {'key': 'registration', 'type': 'ClientRegistration'},
        'login': {'key': 'login', 'type': 'LoginScopes'},
        'validation': {'key': 'validation', 'type': 'AllowedAudiencesValidation'},
    }

    def __init__(self, **kwargs):
        super(Google, self).__init__(**kwargs)
        self.state = kwargs.get('state', None)
        self.registration = kwargs.get('registration', None)
        self.login = kwargs.get('login', None)
        self.validation = kwargs.get('validation', None)


class HttpScaleRule(Model):
    """Container App container Custom scaling rule.

    :param metadata: Metadata properties to describe http scale rule.
    :type metadata: dict[str, str]
    :param auth: Authentication secrets for the custom scale rule.
    :type auth: list[~commondefinitions.models.ScaleRuleAuth]
    """

    _attribute_map = {
        'metadata': {'key': 'metadata', 'type': '{str}'},
        'auth': {'key': 'auth', 'type': '[ScaleRuleAuth]'},
    }

    def __init__(self, **kwargs):
        super(HttpScaleRule, self).__init__(**kwargs)
        self.metadata = kwargs.get('metadata', None)
        self.auth = kwargs.get('auth', None)


class HttpSettings(Model):
    """The configuration settings of the HTTP requests for authentication and
    authorization requests made against ContainerApp
    Authentication/Authorization.

    :param require_https: <code>false</code> if the
     authentication/authorization responses not having the HTTPS scheme are
     permissible; otherwise, <code>true</code>. Possible values include:
     'True', 'False'
    :type require_https: str or ~commondefinitions.models.RequireHttpsMode
    :param route: The configuration settings of the paths HTTP requests.
    :type route: ~commondefinitions.models.HttpSettingsRoute
    """

    _attribute_map = {
        'require_https': {'key': 'requireHttps', 'type': 'str'},
        'route': {'key': 'route', 'type': 'HttpSettingsRoute'},
    }

    def __init__(self, **kwargs):
        super(HttpSettings, self).__init__(**kwargs)
        self.require_https = kwargs.get('require_https', None)
        self.route = kwargs.get('route', None)


class HttpSettingsRoute(Model):
    """The configuration settings of the paths HTTP requests.

    :param api_prefix: The prefix that should precede all the
     authentication/authorization paths.
    :type api_prefix: str
    """

    _attribute_map = {
        'api_prefix': {'key': 'apiPrefix', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(HttpSettingsRoute, self).__init__(**kwargs)
        self.api_prefix = kwargs.get('api_prefix', None)


class IdentityProviders(Model):
    """The configuration settings of each of the identity providers used to
    configure ContainerApp Authentication/Authorization.

    :param azure_active_directory: The configuration settings of the Azure
     Active directory provider.
    :type azure_active_directory:
     ~commondefinitions.models.AzureActiveDirectory
    :param facebook: The configuration settings of the Facebook provider.
    :type facebook: ~commondefinitions.models.Facebook
    :param git_hub: The configuration settings of the GitHub provider.
    :type git_hub: ~commondefinitions.models.GitHub
    :param google: The configuration settings of the Google provider.
    :type google: ~commondefinitions.models.Google
    :param legacy_microsoft_account: The configuration settings of the legacy
     Microsoft Account provider.
    :type legacy_microsoft_account:
     ~commondefinitions.models.LegacyMicrosoftAccount
    :param twitter: The configuration settings of the Twitter provider.
    :type twitter: ~commondefinitions.models.Twitter
    :param apple: The configuration settings of the Apple provider.
    :type apple: ~commondefinitions.models.Apple
    :param azure_static_web_app: The configuration settings of the Azure
     Static Web Apps provider.
    :type azure_static_web_app: ~commondefinitions.models.AzureStaticWebApp
    :param custom_open_id_connect_providers: The map of the name of the alias
     of each custom Open ID Connect provider to the
     configuration settings of the custom Open ID Connect provider.
    :type custom_open_id_connect_providers: dict[str,
     ~commondefinitions.models.CustomOpenIdConnectProvider]
    """

    _attribute_map = {
        'azure_active_directory': {'key': 'azureActiveDirectory', 'type': 'AzureActiveDirectory'},
        'facebook': {'key': 'facebook', 'type': 'Facebook'},
        'git_hub': {'key': 'gitHub', 'type': 'GitHub'},
        'google': {'key': 'google', 'type': 'Google'},
        'legacy_microsoft_account': {'key': 'legacyMicrosoftAccount', 'type': 'LegacyMicrosoftAccount'},
        'twitter': {'key': 'twitter', 'type': 'Twitter'},
        'apple': {'key': 'apple', 'type': 'Apple'},
        'azure_static_web_app': {'key': 'azureStaticWebApp', 'type': 'AzureStaticWebApp'},
        'custom_open_id_connect_providers': {'key': 'customOpenIdConnectProviders', 'type': '{CustomOpenIdConnectProvider}'},
    }

    def __init__(self, **kwargs):
        super(IdentityProviders, self).__init__(**kwargs)
        self.azure_active_directory = kwargs.get('azure_active_directory', None)
        self.facebook = kwargs.get('facebook', None)
        self.git_hub = kwargs.get('git_hub', None)
        self.google = kwargs.get('google', None)
        self.legacy_microsoft_account = kwargs.get('legacy_microsoft_account', None)
        self.twitter = kwargs.get('twitter', None)
        self.apple = kwargs.get('apple', None)
        self.azure_static_web_app = kwargs.get('azure_static_web_app', None)
        self.custom_open_id_connect_providers = kwargs.get('custom_open_id_connect_providers', None)


class Ingress(Model):
    """Container App Ingress configuration.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar fqdn: Hostname.
    :vartype fqdn: str
    :param external: Bool indicating if app exposes an external http endpoint.
     Default value: False .
    :type external: bool
    :param target_port: Target Port in containers for traffic from ingress
    :type target_port: int
    :param transport: Ingress transport protocol. Possible values include:
     'auto', 'http', 'http2'
    :type transport: str or ~commondefinitions.models.IngressTransportMethod
    :param traffic: Traffic weights for app's revisions
    :type traffic: list[~commondefinitions.models.TrafficWeight]
    :param custom_domains: custom domain bindings for Container Apps'
     hostnames.
    :type custom_domains: list[~commondefinitions.models.CustomDomain]
    :param allow_insecure: Bool indicating if HTTP connections to is allowed.
     If set to false HTTP connections are automatically redirected to HTTPS
     connections
    :type allow_insecure: bool
    """

    _validation = {
        'fqdn': {'readonly': True},
    }

    _attribute_map = {
        'fqdn': {'key': 'fqdn', 'type': 'str'},
        'external': {'key': 'external', 'type': 'bool'},
        'target_port': {'key': 'targetPort', 'type': 'int'},
        'transport': {'key': 'transport', 'type': 'str'},
        'traffic': {'key': 'traffic', 'type': '[TrafficWeight]'},
        'custom_domains': {'key': 'customDomains', 'type': '[CustomDomain]'},
        'allow_insecure': {'key': 'allowInsecure', 'type': 'bool'},
        'ipSecurityRestrictions': {'key': 'ipSecurityRestrictions', 'type': '[IPSecurityRestrictions]'},
    }

    def __init__(self, **kwargs):
        super(Ingress, self).__init__(**kwargs)
        self.fqdn = None
        self.external = kwargs.get('external', False)
        self.target_port = kwargs.get('target_port', None)
        self.transport = kwargs.get('transport', None)
        self.traffic = kwargs.get('traffic', None)
        self.custom_domains = kwargs.get('custom_domains', None)
        self.allow_insecure = kwargs.get('allow_insecure', None)
        self.ipSecurityRestrictions = kwargs.get('ipSecurityRestrictions', None)


class LegacyMicrosoftAccount(Model):
    """The configuration settings of the legacy Microsoft Account provider.

    :param state: <code>Disabled</code> if the legacy Microsoft Account
     provider should not be enabled despite the set registration; otherwise,
     <code>Enabled</code>. Possible values include: 'Enabled', 'Disabled'
    :type state: str or ~commondefinitions.models.IdentityProviderState
    :param registration: The configuration settings of the app registration
     for the legacy Microsoft Account provider.
    :type registration: ~commondefinitions.models.ClientRegistration
    :param login: The configuration settings of the login flow.
    :type login: ~commondefinitions.models.LoginScopes
    :param validation: The configuration settings of the legacy Microsoft
     Account provider token validation flow.
    :type validation: ~commondefinitions.models.AllowedAudiencesValidation
    """

    _attribute_map = {
        'state': {'key': 'state', 'type': 'str'},
        'registration': {'key': 'registration', 'type': 'ClientRegistration'},
        'login': {'key': 'login', 'type': 'LoginScopes'},
        'validation': {'key': 'validation', 'type': 'AllowedAudiencesValidation'},
    }

    def __init__(self, **kwargs):
        super(LegacyMicrosoftAccount, self).__init__(**kwargs)
        self.state = kwargs.get('state', None)
        self.registration = kwargs.get('registration', None)
        self.login = kwargs.get('login', None)
        self.validation = kwargs.get('validation', None)


class LogAnalyticsConfiguration(Model):
    """Log analytics configuration.

    :param customer_id: Log analytics customer id
    :type customer_id: str
    :param shared_key: Log analytics customer key
    :type shared_key: str
    """

    _attribute_map = {
        'customer_id': {'key': 'customerId', 'type': 'str'},
        'shared_key': {'key': 'sharedKey', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(LogAnalyticsConfiguration, self).__init__(**kwargs)
        self.customer_id = kwargs.get('customer_id', None)
        self.shared_key = kwargs.get('shared_key', None)


class Login(Model):
    """The configuration settings of the login flow of users using ContainerApp
    Authentication/Authorization.

    :param route: The route that specify the endpoint used for login and
     logout requests.
    :type route: ~commondefinitions.models.LoginRoute
    :param preserve_url_fragments_for_logins: <code>True</code> if the
     fragments from the request are preserved after the login request is made;
     otherwise, <code>False</code>. Possible values include: 'True', 'False'
    :type preserve_url_fragments_for_logins: str or
     ~commondefinitions.models.PreserveUrlFragmentsForLoginsMode
    :param allowed_external_redirect_urls: External URLs that can be
     redirected to as part of logging in or logging out of the app. Note that
     the query string part of the URL is ignored.
     This is an advanced setting typically only needed by Windows Store
     application backends.
     Note that URLs within the current domain are always implicitly allowed.
    :type allowed_external_redirect_urls: list[str]
    """

    _attribute_map = {
        'route': {'key': 'route', 'type': 'LoginRoute'},
        'preserve_url_fragments_for_logins': {'key': 'preserveUrlFragmentsForLogins', 'type': 'str'},
        'allowed_external_redirect_urls': {'key': 'allowedExternalRedirectUrls', 'type': '[str]'},
    }

    def __init__(self, **kwargs):
        super(Login, self).__init__(**kwargs)
        self.route = kwargs.get('route', None)
        self.preserve_url_fragments_for_logins = kwargs.get('preserve_url_fragments_for_logins', None)
        self.allowed_external_redirect_urls = kwargs.get('allowed_external_redirect_urls', None)


class LoginRoute(Model):
    """The route that specify the endpoint used for login and logout requests.

    :param logout_endpoint: The endpoint at which a logout request should be
     made.
    :type logout_endpoint: str
    """

    _attribute_map = {
        'logout_endpoint': {'key': 'logoutEndpoint', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(LoginRoute, self).__init__(**kwargs)
        self.logout_endpoint = kwargs.get('logout_endpoint', None)


class LoginScopes(Model):
    """The configuration settings of the login flow, including the scopes that
    should be requested.

    :param scopes: A list of the scopes that should be requested while
     authenticating.
    :type scopes: list[str]
    """

    _attribute_map = {
        'scopes': {'key': 'scopes', 'type': '[str]'},
    }

    def __init__(self, **kwargs):
        super(LoginScopes, self).__init__(**kwargs)
        self.scopes = kwargs.get('scopes', None)


class ManagedEnvironment(TrackedResource):
    """An environment for hosting container apps.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
    :vartype id: str
    :ivar name: The name of the resource
    :vartype name: str
    :ivar type: The type of the resource. E.g.
     "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy
     and modifiedBy information.
    :vartype system_data: ~commondefinitions.models.SystemData
    :param tags: Resource tags.
    :type tags: dict[str, str]
    :param location: Required. The geo-location where the resource lives
    :type location: str
    :ivar provisioning_state: Provisioning state of the Environment. Possible
     values include: 'Succeeded', 'Failed', 'Canceled', 'Waiting',
     'InitializationInProgress', 'InfrastructureSetupInProgress',
     'InfrastructureSetupComplete', 'ScheduledForDelete', 'UpgradeRequested',
     'UpgradeFailed'
    :vartype provisioning_state: str or
     ~commondefinitions.models.EnvironmentProvisioningState
    :param dapr_ai_instrumentation_key: Azure Monitor instrumentation key used
     by Dapr to export Service to Service communication telemetry
    :type dapr_ai_instrumentation_key: str
    :param vnet_configuration: Vnet configuration for the environment
    :type vnet_configuration: ~commondefinitions.models.VnetConfiguration
    :ivar deployment_errors: Any errors that occurred during deployment or
     deployment validation
    :vartype deployment_errors: str
    :ivar default_domain: Default Domain Name for the cluster
    :vartype default_domain: str
    :ivar static_ip: Static IP of the Environment
    :vartype static_ip: str
    :param app_logs_configuration: Cluster configuration which enables the log
     daemon to export
     app logs to a destination. Currently only "log-analytics" is
     supported
    :type app_logs_configuration:
     ~commondefinitions.models.AppLogsConfiguration
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'system_data': {'readonly': True},
        'location': {'required': True},
        'provisioning_state': {'readonly': True},
        'deployment_errors': {'readonly': True},
        'default_domain': {'readonly': True},
        'static_ip': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'location': {'key': 'location', 'type': 'str'},
        'provisioning_state': {'key': 'properties.provisioningState', 'type': 'str'},
        'dapr_ai_instrumentation_key': {'key': 'properties.daprAIInstrumentationKey', 'type': 'str'},
        'vnet_configuration': {'key': 'properties.vnetConfiguration', 'type': 'VnetConfiguration'},
        'deployment_errors': {'key': 'properties.deploymentErrors', 'type': 'str'},
        'default_domain': {'key': 'properties.defaultDomain', 'type': 'str'},
        'static_ip': {'key': 'properties.staticIp', 'type': 'str'},
        'app_logs_configuration': {'key': 'properties.appLogsConfiguration', 'type': 'AppLogsConfiguration'},
    }

    def __init__(self, **kwargs):
        super(ManagedEnvironment, self).__init__(**kwargs)
        self.provisioning_state = None
        self.dapr_ai_instrumentation_key = kwargs.get('dapr_ai_instrumentation_key', None)
        self.vnet_configuration = kwargs.get('vnet_configuration', None)
        self.deployment_errors = None
        self.default_domain = None
        self.static_ip = None
        self.app_logs_configuration = kwargs.get('app_logs_configuration', None)


class ManagedEnvironmentPatch(Model):
    """An environment for hosting container apps.

    :param tags: Application-specific metadata in the form of key-value pairs.
    :type tags: dict[str, str]
    """

    _attribute_map = {
        'tags': {'key': 'tags', 'type': '{str}'},
    }

    def __init__(self, **kwargs):
        super(ManagedEnvironmentPatch, self).__init__(**kwargs)
        self.tags = kwargs.get('tags', None)


class ManagedEnvironmentsCollection(Model):
    """Collection of Environments.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :param value: Required. Collection of resources.
    :type value: list[~commondefinitions.models.ManagedEnvironment]
    :ivar next_link: Link to next page of resources.
    :vartype next_link: str
    """

    _validation = {
        'value': {'required': True},
        'next_link': {'readonly': True},
    }

    _attribute_map = {
        'value': {'key': 'value', 'type': '[ManagedEnvironment]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(ManagedEnvironmentsCollection, self).__init__(**kwargs)
        self.value = kwargs.get('value', None)
        self.next_link = None


class ManagedEnvironmentStorage(ProxyResource):
    """Storage resource for managedEnvironment.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
    :vartype id: str
    :ivar name: The name of the resource
    :vartype name: str
    :ivar type: The type of the resource. E.g.
     "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy
     and modifiedBy information.
    :vartype system_data: ~commondefinitions.models.SystemData
    :param properties: Storage properties
    :type properties:
     ~commondefinitions.models.ManagedEnvironmentStorageProperties
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'system_data': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
        'properties': {'key': 'properties', 'type': 'ManagedEnvironmentStorageProperties'},
    }

    def __init__(self, **kwargs):
        super(ManagedEnvironmentStorage, self).__init__(**kwargs)
        self.properties = kwargs.get('properties', None)


class ManagedEnvironmentStorageProperties(Model):
    """Storage properties.

    :param azure_file: Azure file properties
    :type azure_file: ~commondefinitions.models.AzureFileProperties
    """

    _attribute_map = {
        'azure_file': {'key': 'azureFile', 'type': 'AzureFileProperties'},
    }

    def __init__(self, **kwargs):
        super(ManagedEnvironmentStorageProperties, self).__init__(**kwargs)
        self.azure_file = kwargs.get('azure_file', None)


class ManagedEnvironmentStoragesCollection(Model):
    """Collection of Storage for Environments.

    All required parameters must be populated in order to send to Azure.

    :param value: Required. Collection of storage resources.
    :type value: list[~commondefinitions.models.ManagedEnvironmentStorage]
    """

    _validation = {
        'value': {'required': True},
    }

    _attribute_map = {
        'value': {'key': 'value', 'type': '[ManagedEnvironmentStorage]'},
    }

    def __init__(self, **kwargs):
        super(ManagedEnvironmentStoragesCollection, self).__init__(**kwargs)
        self.value = kwargs.get('value', None)


class ManagedServiceIdentity(Model):
    """Managed service identity (system assigned and/or user assigned identities).

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar principal_id: The service principal ID of the system assigned
     identity. This property will only be provided for a system assigned
     identity.
    :vartype principal_id: str
    :ivar tenant_id: The tenant ID of the system assigned identity. This
     property will only be provided for a system assigned identity.
    :vartype tenant_id: str
    :param type: Required. Possible values include: 'None', 'SystemAssigned',
     'UserAssigned', 'SystemAssigned,UserAssigned'
    :type type: str or ~commondefinitions.models.ManagedServiceIdentityType
    :param user_assigned_identities:
    :type user_assigned_identities: dict[str,
     ~commondefinitions.models.UserAssignedIdentity]
    """

    _validation = {
        'principal_id': {'readonly': True},
        'tenant_id': {'readonly': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'principal_id': {'key': 'principalId', 'type': 'str'},
        'tenant_id': {'key': 'tenantId', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'user_assigned_identities': {'key': 'userAssignedIdentities', 'type': '{UserAssignedIdentity}'},
    }

    def __init__(self, **kwargs):
        super(ManagedServiceIdentity, self).__init__(**kwargs)
        self.principal_id = None
        self.tenant_id = None
        self.type = kwargs.get('type', None)
        self.user_assigned_identities = kwargs.get('user_assigned_identities', None)


class OpenIdConnectClientCredential(Model):
    """The authentication client credentials of the custom Open ID Connect
    provider.

    :param client_secret_ref_name: The app setting that contains the client
     secret for the custom Open ID Connect provider.
    :type client_secret_ref_name: str
    """

    _attribute_map = {
        'client_secret_ref_name': {'key': 'clientSecretRefName', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(OpenIdConnectClientCredential, self).__init__(**kwargs)
        self.client_secret_ref_name = kwargs.get('client_secret_ref_name', None)


class OpenIdConnectConfig(Model):
    """The configuration settings of the endpoints used for the custom Open ID
    Connect provider.

    :param authorization_endpoint: The endpoint to be used to make an
     authorization request.
    :type authorization_endpoint: str
    :param token_endpoint: The endpoint to be used to request a token.
    :type token_endpoint: str
    :param issuer: The endpoint that issues the token.
    :type issuer: str
    :param certification_uri: The endpoint that provides the keys necessary to
     validate the token.
    :type certification_uri: str
    :param well_known_open_id_configuration: The endpoint that contains all
     the configuration endpoints for the provider.
    :type well_known_open_id_configuration: str
    """

    _attribute_map = {
        'authorization_endpoint': {'key': 'authorizationEndpoint', 'type': 'str'},
        'token_endpoint': {'key': 'tokenEndpoint', 'type': 'str'},
        'issuer': {'key': 'issuer', 'type': 'str'},
        'certification_uri': {'key': 'certificationUri', 'type': 'str'},
        'well_known_open_id_configuration': {'key': 'wellKnownOpenIdConfiguration', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(OpenIdConnectConfig, self).__init__(**kwargs)
        self.authorization_endpoint = kwargs.get('authorization_endpoint', None)
        self.token_endpoint = kwargs.get('token_endpoint', None)
        self.issuer = kwargs.get('issuer', None)
        self.certification_uri = kwargs.get('certification_uri', None)
        self.well_known_open_id_configuration = kwargs.get('well_known_open_id_configuration', None)


class OpenIdConnectLogin(Model):
    """The configuration settings of the login flow of the custom Open ID Connect
    provider.

    :param name_claim_type: The name of the claim that contains the users
     name.
    :type name_claim_type: str
    :param scopes: A list of the scopes that should be requested while
     authenticating.
    :type scopes: list[str]
    """

    _attribute_map = {
        'name_claim_type': {'key': 'nameClaimType', 'type': 'str'},
        'scopes': {'key': 'scopes', 'type': '[str]'},
    }

    def __init__(self, **kwargs):
        super(OpenIdConnectLogin, self).__init__(**kwargs)
        self.name_claim_type = kwargs.get('name_claim_type', None)
        self.scopes = kwargs.get('scopes', None)


class OpenIdConnectRegistration(Model):
    """The configuration settings of the app registration for the custom Open ID
    Connect provider.

    :param client_id: The client id of the custom Open ID Connect provider.
    :type client_id: str
    :param client_credential: The authentication credentials of the custom
     Open ID Connect provider.
    :type client_credential:
     ~commondefinitions.models.OpenIdConnectClientCredential
    :param open_id_connect_configuration: The configuration settings of the
     endpoints used for the custom Open ID Connect provider.
    :type open_id_connect_configuration:
     ~commondefinitions.models.OpenIdConnectConfig
    """

    _attribute_map = {
        'client_id': {'key': 'clientId', 'type': 'str'},
        'client_credential': {'key': 'clientCredential', 'type': 'OpenIdConnectClientCredential'},
        'open_id_connect_configuration': {'key': 'openIdConnectConfiguration', 'type': 'OpenIdConnectConfig'},
    }

    def __init__(self, **kwargs):
        super(OpenIdConnectRegistration, self).__init__(**kwargs)
        self.client_id = kwargs.get('client_id', None)
        self.client_credential = kwargs.get('client_credential', None)
        self.open_id_connect_configuration = kwargs.get('open_id_connect_configuration', None)


class OperationDetail(Model):
    """Operation detail payload.

    :param name: Name of the operation
    :type name: str
    :param is_data_action: Indicates whether the operation is a data action
    :type is_data_action: bool
    :param display: Display of the operation
    :type display: ~commondefinitions.models.OperationDisplay
    :param origin: Origin of the operation
    :type origin: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'is_data_action': {'key': 'isDataAction', 'type': 'bool'},
        'display': {'key': 'display', 'type': 'OperationDisplay'},
        'origin': {'key': 'origin', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(OperationDetail, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.is_data_action = kwargs.get('is_data_action', None)
        self.display = kwargs.get('display', None)
        self.origin = kwargs.get('origin', None)


class OperationDisplay(Model):
    """Operation display payload.

    :param provider: Resource provider of the operation
    :type provider: str
    :param resource: Resource of the operation
    :type resource: str
    :param operation: Localized friendly name for the operation
    :type operation: str
    :param description: Localized friendly description for the operation
    :type description: str
    """

    _attribute_map = {
        'provider': {'key': 'provider', 'type': 'str'},
        'resource': {'key': 'resource', 'type': 'str'},
        'operation': {'key': 'operation', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(OperationDisplay, self).__init__(**kwargs)
        self.provider = kwargs.get('provider', None)
        self.resource = kwargs.get('resource', None)
        self.operation = kwargs.get('operation', None)
        self.description = kwargs.get('description', None)


class QueueScaleRule(Model):
    """Container App container Azure Queue based scaling rule.

    :param queue_name: Queue name.
    :type queue_name: str
    :param queue_length: Queue length.
    :type queue_length: int
    :param auth: Authentication secrets for the queue scale rule.
    :type auth: list[~commondefinitions.models.ScaleRuleAuth]
    """

    _attribute_map = {
        'queue_name': {'key': 'queueName', 'type': 'str'},
        'queue_length': {'key': 'queueLength', 'type': 'int'},
        'auth': {'key': 'auth', 'type': '[ScaleRuleAuth]'},
    }

    def __init__(self, **kwargs):
        super(QueueScaleRule, self).__init__(**kwargs)
        self.queue_name = kwargs.get('queue_name', None)
        self.queue_length = kwargs.get('queue_length', None)
        self.auth = kwargs.get('auth', None)


class RegistryCredentials(Model):
    """Container App Private Registry.

    :param server: Container Registry Server
    :type server: str
    :param username: Container Registry Username
    :type username: str
    :param password_secret_ref: The name of the Secret that contains the
     registry login password
    :type password_secret_ref: str
    """

    _attribute_map = {
        'server': {'key': 'server', 'type': 'str'},
        'username': {'key': 'username', 'type': 'str'},
        'password_secret_ref': {'key': 'passwordSecretRef', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(RegistryCredentials, self).__init__(**kwargs)
        self.server = kwargs.get('server', None)
        self.username = kwargs.get('username', None)
        self.password_secret_ref = kwargs.get('password_secret_ref', None)


class RegistryInfo(Model):
    """Container App registry information.

    :param registry_url: registry server Url.
    :type registry_url: str
    :param registry_user_name: registry username.
    :type registry_user_name: str
    :param registry_password: registry secret.
    :type registry_password: str
    """

    _attribute_map = {
        'registry_url': {'key': 'registryUrl', 'type': 'str'},
        'registry_user_name': {'key': 'registryUserName', 'type': 'str'},
        'registry_password': {'key': 'registryPassword', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(RegistryInfo, self).__init__(**kwargs)
        self.registry_url = kwargs.get('registry_url', None)
        self.registry_user_name = kwargs.get('registry_user_name', None)
        self.registry_password = kwargs.get('registry_password', None)


class Replica(ProxyResource):
    """Container App Revision Replica.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
    :vartype id: str
    :ivar name: The name of the resource
    :vartype name: str
    :ivar type: The type of the resource. E.g.
     "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy
     and modifiedBy information.
    :vartype system_data: ~commondefinitions.models.SystemData
    :ivar created_time: Timestamp describing when the pod was created by
     controller
    :vartype created_time: datetime
    :param containers: The containers collection under a replica.
    :type containers: list[~commondefinitions.models.ReplicaContainer]
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'system_data': {'readonly': True},
        'created_time': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
        'created_time': {'key': 'properties.createdTime', 'type': 'iso-8601'},
        'containers': {'key': 'properties.containers', 'type': '[ReplicaContainer]'},
    }

    def __init__(self, **kwargs):
        super(Replica, self).__init__(**kwargs)
        self.created_time = None
        self.containers = kwargs.get('containers', None)


class ReplicaCollection(Model):
    """Container App Revision Replicas collection ARM resource.

    All required parameters must be populated in order to send to Azure.

    :param value: Required. Collection of resources.
    :type value: list[~commondefinitions.models.Replica]
    """

    _validation = {
        'value': {'required': True},
    }

    _attribute_map = {
        'value': {'key': 'value', 'type': '[Replica]'},
    }

    def __init__(self, **kwargs):
        super(ReplicaCollection, self).__init__(**kwargs)
        self.value = kwargs.get('value', None)


class ReplicaContainer(Model):
    """Container object under Container App Revision Replica.

    :param name: The Name of the Container
    :type name: str
    :param container_id: The Id of the Container
    :type container_id: str
    :param ready: The container ready status
    :type ready: bool
    :param started: The container start status
    :type started: bool
    :param restart_count: The container restart count
    :type restart_count: int
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'container_id': {'key': 'containerId', 'type': 'str'},
        'ready': {'key': 'ready', 'type': 'bool'},
        'started': {'key': 'started', 'type': 'bool'},
        'restart_count': {'key': 'restartCount', 'type': 'int'},
    }

    def __init__(self, **kwargs):
        super(ReplicaContainer, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.container_id = kwargs.get('container_id', None)
        self.ready = kwargs.get('ready', None)
        self.started = kwargs.get('started', None)
        self.restart_count = kwargs.get('restart_count', None)


class Revision(ProxyResource):
    """Container App Revision.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
    :vartype id: str
    :ivar name: The name of the resource
    :vartype name: str
    :ivar type: The type of the resource. E.g.
     "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy
     and modifiedBy information.
    :vartype system_data: ~commondefinitions.models.SystemData
    :ivar created_time: Timestamp describing when the revision was created
     by controller
    :vartype created_time: datetime
    :ivar fqdn: Fully qualified domain name of the revision
    :vartype fqdn: str
    :ivar template: Container App Revision Template with all possible settings
     and the
     defaults if user did not provide them. The defaults are populated
     as they were at the creation time
    :vartype template: ~commondefinitions.models.Template
    :ivar active: Boolean describing if the Revision is Active
    :vartype active: bool
    :ivar replicas: Number of pods currently running for this revision
    :vartype replicas: int
    :ivar traffic_weight: Traffic weight assigned to this revision
    :vartype traffic_weight: int
    :ivar provisioning_error: Optional Field - Platform Error Message
    :vartype provisioning_error: str
    :ivar health_state: Current health State of the revision. Possible values
     include: 'Healthy', 'Unhealthy', 'None'
    :vartype health_state: str or
     ~commondefinitions.models.RevisionHealthState
    :ivar provisioning_state: Current provisioning State of the revision.
     Possible values include: 'Provisioning', 'Provisioned', 'Failed',
     'Deprovisioning', 'Deprovisioned'
    :vartype provisioning_state: str or
     ~commondefinitions.models.RevisionProvisioningState
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'system_data': {'readonly': True},
        'created_time': {'readonly': True},
        'fqdn': {'readonly': True},
        'template': {'readonly': True},
        'active': {'readonly': True},
        'replicas': {'readonly': True},
        'traffic_weight': {'readonly': True},
        'provisioning_error': {'readonly': True},
        'health_state': {'readonly': True},
        'provisioning_state': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
        'created_time': {'key': 'properties.createdTime', 'type': 'iso-8601'},
        'fqdn': {'key': 'properties.fqdn', 'type': 'str'},
        'template': {'key': 'properties.template', 'type': 'Template'},
        'active': {'key': 'properties.active', 'type': 'bool'},
        'replicas': {'key': 'properties.replicas', 'type': 'int'},
        'traffic_weight': {'key': 'properties.trafficWeight', 'type': 'int'},
        'provisioning_error': {'key': 'properties.provisioningError', 'type': 'str'},
        'health_state': {'key': 'properties.healthState', 'type': 'str'},
        'provisioning_state': {'key': 'properties.provisioningState', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(Revision, self).__init__(**kwargs)
        self.created_time = None
        self.fqdn = None
        self.template = None
        self.active = None
        self.replicas = None
        self.traffic_weight = None
        self.provisioning_error = None
        self.health_state = None
        self.provisioning_state = None


class RevisionCollection(Model):
    """Container App Revisions collection ARM resource.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :param value: Required. Collection of resources.
    :type value: list[~commondefinitions.models.Revision]
    :ivar next_link: Link to next page of resources.
    :vartype next_link: str
    """

    _validation = {
        'value': {'required': True},
        'next_link': {'readonly': True},
    }

    _attribute_map = {
        'value': {'key': 'value', 'type': '[Revision]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(RevisionCollection, self).__init__(**kwargs)
        self.value = kwargs.get('value', None)
        self.next_link = None


class Scale(Model):
    """Container App scaling configurations.

    :param min_replicas: Optional. Minimum number of container replicas.
    :type min_replicas: int
    :param max_replicas: Optional. Maximum number of container replicas.
     Defaults to 10 if not set.
    :type max_replicas: int
    :param rules: Scaling rules.
    :type rules: list[~commondefinitions.models.ScaleRule]
    """

    _attribute_map = {
        'min_replicas': {'key': 'minReplicas', 'type': 'int'},
        'max_replicas': {'key': 'maxReplicas', 'type': 'int'},
        'rules': {'key': 'rules', 'type': '[ScaleRule]'},
    }

    def __init__(self, **kwargs):
        super(Scale, self).__init__(**kwargs)
        self.min_replicas = kwargs.get('min_replicas', None)
        self.max_replicas = kwargs.get('max_replicas', None)
        self.rules = kwargs.get('rules', None)


class ScaleRule(Model):
    """Container App container scaling rule.

    :param name: Scale Rule Name
    :type name: str
    :param azure_queue: Azure Queue based scaling.
    :type azure_queue: ~commondefinitions.models.QueueScaleRule
    :param custom: Custom scale rule.
    :type custom: ~commondefinitions.models.CustomScaleRule
    :param http: HTTP requests based scaling.
    :type http: ~commondefinitions.models.HttpScaleRule
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'azure_queue': {'key': 'azureQueue', 'type': 'QueueScaleRule'},
        'custom': {'key': 'custom', 'type': 'CustomScaleRule'},
        'http': {'key': 'http', 'type': 'HttpScaleRule'},
    }

    def __init__(self, **kwargs):
        super(ScaleRule, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.azure_queue = kwargs.get('azure_queue', None)
        self.custom = kwargs.get('custom', None)
        self.http = kwargs.get('http', None)


class ScaleRuleAuth(Model):
    """Auth Secrets for Container App Scale Rule.

    :param secret_ref: Name of the Container App secret from which to pull the
     auth params.
    :type secret_ref: str
    :param trigger_parameter: Trigger Parameter that uses the secret
    :type trigger_parameter: str
    """

    _attribute_map = {
        'secret_ref': {'key': 'secretRef', 'type': 'str'},
        'trigger_parameter': {'key': 'triggerParameter', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(ScaleRuleAuth, self).__init__(**kwargs)
        self.secret_ref = kwargs.get('secret_ref', None)
        self.trigger_parameter = kwargs.get('trigger_parameter', None)


class Secret(Model):
    """Secret definition.

    :param name: Secret Name.
    :type name: str
    :param value: Secret Value.
    :type value: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'value': {'key': 'value', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(Secret, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.value = kwargs.get('value', None)


class SecretsCollection(Model):
    """Container App Secrets Collection ARM resource.

    All required parameters must be populated in order to send to Azure.

    :param value: Required. Collection of resources.
    :type value: list[~commondefinitions.models.ContainerAppSecret]
    """

    _validation = {
        'value': {'required': True},
    }

    _attribute_map = {
        'value': {'key': 'value', 'type': '[ContainerAppSecret]'},
    }

    def __init__(self, **kwargs):
        super(SecretsCollection, self).__init__(**kwargs)
        self.value = kwargs.get('value', None)


class SourceControl(ProxyResource):
    """Container App SourceControl.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
    :vartype id: str
    :ivar name: The name of the resource
    :vartype name: str
    :ivar type: The type of the resource. E.g.
     "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy
     and modifiedBy information.
    :vartype system_data: ~commondefinitions.models.SystemData
    :ivar operation_state: Current provisioning State of the operation.
     Possible values include: 'InProgress', 'Succeeded', 'Failed', 'Canceled'
    :vartype operation_state: str or
     ~commondefinitions.models.SourceControlOperationState
    :param repo_url: The repo url which will be integrated to ContainerApp.
    :type repo_url: str
    :param branch: The branch which will trigger the auto deployment
    :type branch: str
    :param github_action_configuration: Container App Revision Template with
     all possible settings and the
     defaults if user did not provide them. The defaults are populated
     as they were at the creation time
    :type github_action_configuration:
     ~commondefinitions.models.GithubActionConfiguration
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'system_data': {'readonly': True},
        'operation_state': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
        'operation_state': {'key': 'properties.operationState', 'type': 'str'},
        'repo_url': {'key': 'properties.repoUrl', 'type': 'str'},
        'branch': {'key': 'properties.branch', 'type': 'str'},
        'github_action_configuration': {'key': 'properties.githubActionConfiguration', 'type': 'GithubActionConfiguration'},
    }

    def __init__(self, **kwargs):
        super(SourceControl, self).__init__(**kwargs)
        self.operation_state = None
        self.repo_url = kwargs.get('repo_url', None)
        self.branch = kwargs.get('branch', None)
        self.github_action_configuration = kwargs.get('github_action_configuration', None)


class SourceControlCollection(Model):
    """SourceControl collection ARM resource.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :param value: Required. Collection of resources.
    :type value: list[~commondefinitions.models.SourceControl]
    :ivar next_link: Link to next page of resources.
    :vartype next_link: str
    """

    _validation = {
        'value': {'required': True},
        'next_link': {'readonly': True},
    }

    _attribute_map = {
        'value': {'key': 'value', 'type': '[SourceControl]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(SourceControlCollection, self).__init__(**kwargs)
        self.value = kwargs.get('value', None)
        self.next_link = None


class SystemData(Model):
    """Metadata pertaining to creation and last modification of the resource.

    :param created_by: The identity that created the resource.
    :type created_by: str
    :param created_by_type: The type of identity that created the resource.
     Possible values include: 'User', 'Application', 'ManagedIdentity', 'Key'
    :type created_by_type: str or ~commondefinitions.models.CreatedByType
    :param created_at: The timestamp of resource creation (UTC).
    :type created_at: datetime
    :param last_modified_by: The identity that last modified the resource.
    :type last_modified_by: str
    :param last_modified_by_type: The type of identity that last modified the
     resource. Possible values include: 'User', 'Application',
     'ManagedIdentity', 'Key'
    :type last_modified_by_type: str or
     ~commondefinitions.models.CreatedByType
    :param last_modified_at: The timestamp of resource last modification (UTC)
    :type last_modified_at: datetime
    """

    _attribute_map = {
        'created_by': {'key': 'createdBy', 'type': 'str'},
        'created_by_type': {'key': 'createdByType', 'type': 'str'},
        'created_at': {'key': 'createdAt', 'type': 'iso-8601'},
        'last_modified_by': {'key': 'lastModifiedBy', 'type': 'str'},
        'last_modified_by_type': {'key': 'lastModifiedByType', 'type': 'str'},
        'last_modified_at': {'key': 'lastModifiedAt', 'type': 'iso-8601'},
    }

    def __init__(self, **kwargs):
        super(SystemData, self).__init__(**kwargs)
        self.created_by = kwargs.get('created_by', None)
        self.created_by_type = kwargs.get('created_by_type', None)
        self.created_at = kwargs.get('created_at', None)
        self.last_modified_by = kwargs.get('last_modified_by', None)
        self.last_modified_by_type = kwargs.get('last_modified_by_type', None)
        self.last_modified_at = kwargs.get('last_modified_at', None)


class Template(Model):
    """Container App versioned application definition.
    Defines the desired state of an immutable revision.
    Any changes to this section Will result in a new revision being created.

    :param revision_suffix: User friendly suffix that is appended to the
     revision name
    :type revision_suffix: str
    :param containers: List of container definitions for the Container App.
    :type containers: list[~commondefinitions.models.Container]
    :param scale: Scaling properties for the Container App.
    :type scale: ~commondefinitions.models.Scale
    :param volumes: List of volume definitions for the Container App.
    :type volumes: list[~commondefinitions.models.Volume]
    """

    _attribute_map = {
        'revision_suffix': {'key': 'revisionSuffix', 'type': 'str'},
        'containers': {'key': 'containers', 'type': '[Container]'},
        'initContainers': {'key': 'initContainers', 'type': '[Container]'},
        'scale': {'key': 'scale', 'type': 'Scale'},
        'volumes': {'key': 'volumes', 'type': '[Volume]'},
    }

    def __init__(self, **kwargs):
        super(Template, self).__init__(**kwargs)
        self.revision_suffix = kwargs.get('revision_suffix', None)
        self.containers = kwargs.get('containers', None)
        self.scale = kwargs.get('scale', None)
        self.volumes = kwargs.get('volumes', None)


class TrafficWeight(Model):
    """Traffic weight assigned to a revision.

    :param revision_name: Name of a revision
    :type revision_name: str
    :param weight: Traffic weight assigned to a revision
    :type weight: int
    :param latest_revision: Indicates that the traffic weight belongs to a
     latest stable revision. Default value: False .
    :type latest_revision: bool
    """

    _attribute_map = {
        'revision_name': {'key': 'revisionName', 'type': 'str'},
        'weight': {'key': 'weight', 'type': 'int'},
        'latest_revision': {'key': 'latestRevision', 'type': 'bool'},
    }

    def __init__(self, **kwargs):
        super(TrafficWeight, self).__init__(**kwargs)
        self.revision_name = kwargs.get('revision_name', None)
        self.weight = kwargs.get('weight', None)
        self.latest_revision = kwargs.get('latest_revision', False)


class Twitter(Model):
    """The configuration settings of the Twitter provider.

    :param state: <code>Disabled</code> if the Twitter provider should not be
     enabled despite the set registration; otherwise, <code>Enabled</code>.
     Possible values include: 'Enabled', 'Disabled'
    :type state: str or ~commondefinitions.models.IdentityProviderState
    :param registration: The configuration settings of the app registration
     for the Twitter provider.
    :type registration: ~commondefinitions.models.TwitterRegistration
    """

    _attribute_map = {
        'state': {'key': 'state', 'type': 'str'},
        'registration': {'key': 'registration', 'type': 'TwitterRegistration'},
    }

    def __init__(self, **kwargs):
        super(Twitter, self).__init__(**kwargs)
        self.state = kwargs.get('state', None)
        self.registration = kwargs.get('registration', None)


class TwitterRegistration(Model):
    """The configuration settings of the app registration for the Twitter
    provider.

    :param consumer_key: The OAuth 1.0a consumer key of the Twitter
     application used for sign-in.
     This setting is required for enabling Twitter Sign-In.
     Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
    :type consumer_key: str
    :param consumer_secret_ref_name: The app secret ref name that contains the
     OAuth 1.0a consumer secret of the Twitter
     application used for sign-in.
    :type consumer_secret_ref_name: str
    """

    _attribute_map = {
        'consumer_key': {'key': 'consumerKey', 'type': 'str'},
        'consumer_secret_ref_name': {'key': 'consumerSecretRefName', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(TwitterRegistration, self).__init__(**kwargs)
        self.consumer_key = kwargs.get('consumer_key', None)
        self.consumer_secret_ref_name = kwargs.get('consumer_secret_ref_name', None)


class UserAssignedIdentity(Model):
    """User assigned identity properties.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar principal_id: The principal ID of the assigned identity.
    :vartype principal_id: str
    :ivar client_id: The client ID of the assigned identity.
    :vartype client_id: str
    """

    _validation = {
        'principal_id': {'readonly': True},
        'client_id': {'readonly': True},
    }

    _attribute_map = {
        'principal_id': {'key': 'principalId', 'type': 'str'},
        'client_id': {'key': 'clientId', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(UserAssignedIdentity, self).__init__(**kwargs)
        self.principal_id = None
        self.client_id = None


class VnetConfiguration(Model):
    """Configuration properties for apps environment to join a Virtual Network.

    :param internal: Boolean indicating the environment only has an internal
     load balancer. These environments do not have a public static IP resource,
     must provide ControlPlaneSubnetResourceId and AppSubnetResourceId if
     enabling this property
    :type internal: bool
    :param infrastructure_subnet_id: Resource ID of a subnet for
     infrastructure components. This subnet must be in the same VNET as the
     subnet defined in runtimeSubnetId. Must not overlap with any other
     provided IP ranges.
    :type infrastructure_subnet_id: str
    :param runtime_subnet_id: Resource ID of a subnet that Container App
     containers are injected into. This subnet must be in the same VNET as the
     subnet defined in infrastructureSubnetId. Must not overlap with any other
     provided IP ranges.
    :type runtime_subnet_id: str
    :param docker_bridge_cidr: CIDR notation IP range assigned to the Docker
     bridge, network. Must not overlap with any other provided IP ranges.
    :type docker_bridge_cidr: str
    :param platform_reserved_cidr: IP range in CIDR notation that can be
     reserved for environment infrastructure IP addresses. Must not overlap
     with any other provided IP ranges.
    :type platform_reserved_cidr: str
    :param platform_reserved_dns_ip:  An IP address from the IP range defined
     by platformReservedCidr that will be reserved for the internal DNS server.
    :type platform_reserved_dns_ip: str
    """

    _attribute_map = {
        'internal': {'key': 'internal', 'type': 'bool'},
        'infrastructure_subnet_id': {'key': 'infrastructureSubnetId', 'type': 'str'},
        'runtime_subnet_id': {'key': 'runtimeSubnetId', 'type': 'str'},
        'docker_bridge_cidr': {'key': 'dockerBridgeCidr', 'type': 'str'},
        'platform_reserved_cidr': {'key': 'platformReservedCidr', 'type': 'str'},
        'platform_reserved_dns_ip': {'key': 'platformReservedDnsIP', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(VnetConfiguration, self).__init__(**kwargs)
        self.internal = kwargs.get('internal', None)
        self.infrastructure_subnet_id = kwargs.get('infrastructure_subnet_id', None)
        self.runtime_subnet_id = kwargs.get('runtime_subnet_id', None)
        self.docker_bridge_cidr = kwargs.get('docker_bridge_cidr', None)
        self.platform_reserved_cidr = kwargs.get('platform_reserved_cidr', None)
        self.platform_reserved_dns_ip = kwargs.get('platform_reserved_dns_ip', None)


class Volume(Model):
    """Volume definitions for the Container App.

    :param name: Volume name.
    :type name: str
    :param storage_type: Storage type for the volume. If not provided, use
     EmptyDir. Possible values include: 'AzureFile', 'EmptyDir'
    :type storage_type: str or ~commondefinitions.models.StorageType
    :param storage_name: Name of storage resource. No need to provide for
     EmptyDir.
    :type storage_name: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'storage_type': {'key': 'storageType', 'type': 'str'},
        'storage_name': {'key': 'storageName', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(Volume, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.storage_type = kwargs.get('storage_type', None)
        self.storage_name = kwargs.get('storage_name', None)


class VolumeMount(Model):
    """Volume mount for the Container App.

    :param volume_name: This must match the Name of a Volume.
    :type volume_name: str
    :param mount_path: Path within the container at which the volume should be
     mounted.Must not contain ':'.
    :type mount_path: str
    """

    _attribute_map = {
        'volume_name': {'key': 'volumeName', 'type': 'str'},
        'mount_path': {'key': 'mountPath', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(VolumeMount, self).__init__(**kwargs)
        self.volume_name = kwargs.get('volume_name', None)
        self.mount_path = kwargs.get('mount_path', None)
