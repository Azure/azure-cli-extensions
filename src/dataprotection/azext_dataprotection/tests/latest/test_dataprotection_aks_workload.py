# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------
# pylint: disable=line-too-long
# pylint: disable=unused-import

import time
from datetime import datetime
from azure.cli.testsdk import ScenarioTest
from azure.cli.testsdk.scenario_tests import AllowLargeResponse

def setup_vault_and_policy(test):
    test.cmd('az dataprotection backup-vault create '
             '--resource-group "{rgname}" '
             '--location eastus2euap '
             '--vault-name "{vaultname}" '
             '--soft-delete-state Off '
             '--immutability-state Disabled '
             '--storage-settings type=LocallyRedundant datastore-type=VaultStore '
             '--type SystemAssigned '
             '--tags Owner=zubairabid Purpose=Testing MABUsed=Yes',
             checks=[
                #  test.check("id", "{vault_id}")
             ])

    aks_poIicy_json = test.cmd('az dataprotection backup-policy get-default-policy-template --datasource-type AzureKubernetesService', checks=[
        test.check("name", "AKSPolicy1")
    ]).get_output_in_json()
    aks_poIicy_json["name"] = test.kwargs["policyname"]
    test.kwargs.update({
        "policyjson": aks_poIicy_json,
    })

    test.cmd('az dataprotection backup-policy create '
             '-g "{rgname}" '
             '--vault-name "{vaultname}" '
             '-n "{policyname}" '
             '--policy "{policyjson}"',
             checks=[
                #  test.check("id", "{policy_id}")
             ])
    
def configure_backup(test):
    backup_instance_guid = "faec6818-0720-11ec-bd1b-c8f750f92764"

    backup_config_json = test.cmd('az dataprotection backup-instance initialize-backupconfig --datasource-type AzureKubernetesService', checks=[
        test.check('include_cluster_scope_resources', True),
        test.check('snapshot_volumes', True)
    ]).get_output_in_json()
    test.kwargs.update({
        "backup_config_json": backup_config_json
    })

    backup_instance_json = test.cmd('az dataprotection backup-instance initialize '
                                    '--datasource-id "{akscluster1_id}" '
                                    '--datasource-location eastus2euap '
                                    '--datasource-type AzureKubernetesService '
                                    '--policy-id "{policy_id}" '
                                    '--backup-configuration "{backup_config_json}" '
                                    '--friendly-name "{friendlyname1}" '
                                    '--snapshot-resource-group-name "{rgname}"', checks=[]).get_output_in_json()
    backup_instance_json["backup_instance_name"] = test.kwargs['akscluster1'] + "-" + test.kwargs['akscluster1'] + "-" + backup_instance_guid
    test.kwargs.update({
        "backup_instance_json": backup_instance_json,
        "backup_instance_name": backup_instance_json["backup_instance_name"]
    })

    # TODO add failing validation check some time. Not required at the moment.

    # The backup vault creation appeared to be flaky, and the test ran after adding this line. Might need to investigate.
    bvout = test.cmd('az dataprotection backup-vault show -g "{rgname}" --vault-name {vaultname}').get_output_in_json()
    print(bvout)

    # uncomment when running live, run only in record mode - grant permission
    # test.cmd('az dataprotection backup-instance update-msi-permissions '
    #         '--datasource-type AzureKubernetesService '
    #         '--operation Backup '
    #         '--permissions-scope ResourceGroup '
    #         '--vault-name "{vaultname}" '
    #         '--resource-group "{rgname}" '
    #         '--backup-instance "{backup_instance_json}" -y')
    # time.sleep(120)

    # Also uncomment when running live, only run in record mode - provide trusted access
    # helper_trusted_access(test)

    test.cmd('az dataprotection backup-instance create -g "{rgname}" --vault-name "{vaultname}" --backup-instance "{backup_instance_json}"')

    backup_instance_res = test.cmd('az dataprotection backup-instance list -g "{rgname}" --vault-name "{vaultname}" --query "[0].properties.protectionStatus"').get_output_in_json()
    protection_status = backup_instance_res["status"]
    while protection_status != "ProtectionConfigured":
        time.sleep(10)
        backup_instance_res = test.cmd('az dataprotection backup-instance list -g "{rgname}" --vault-name "{vaultname}" --query "[0].properties.protectionStatus"').get_output_in_json()
        protection_status = backup_instance_res["status"]

    time.sleep(30)

def helper_trusted_access(test):
    try:
        test.cmd('az aks trustedaccess rolebinding create '
                '--resource-group {rgname} '
                '--cluster-name {akscluster1} '
                '-n aksRoleBindingName '
                '-s {vault_id} '
                '--roles Microsoft.DataProtection/backupVaults/backup-operator') 
        time.sleep(10)
    except:
        # This is usually failing in the event of the trusted access already existing, so we can skip it unless a new error shows.
        pass

def trigger_backup(test):
    response_json = test.cmd('az dataprotection backup-instance adhoc-backup '
                             '-n {backup_instance_name} -g {rgname} --vault-name {vaultname} --rule-name "{policyrulename}"').get_output_in_json()
    job_status = None
    test.kwargs.update({"backup_job_id": response_json["jobId"]})
    while job_status != "Completed":
        time.sleep(10)
        job_response = test.cmd('az dataprotection job show --ids "{backup_job_id}"').get_output_in_json()
        job_status = job_response["properties"]["status"]
        if job_status not in ["Completed", "InProgress"]:
            raise Exception("Undefined job status received")

def trigger_restore_original_location(test):
    rp_json = test.cmd('az dataprotection recovery-point list '
                       '--backup-instance-name "{backup_instance_name}" -g "{rgname}" --vault-name "{vaultname}"').get_output_in_json()
    test.kwargs.update({"rp_id": rp_json[0]["name"]})

    restore_config_json = test.cmd('az dataprotection backup-instance initialize-restoreconfig --datasource-type AzureKubernetesService', checks=[
        test.check("persistent_volume_restore_mode", "RestoreWithVolumeData"),
        test.check("conflict_policy", "Skip"),
        test.check("include_cluster_scope_resources", True)
    ]).get_output_in_json()
    test.kwargs.update({"restore_config_json": restore_config_json})

    restore_json = test.cmd('az dataprotection backup-instance restore initialize-for-item-recovery'
                            ' --datasource-type AzureKubernetesService '
                            '--restore-location eastus2euap '
                            '--source-datastore OperationalStore '
                            '--recovery-point-id "{rp_id}" '
                            '--backup-instance-id "{backup_instance_id}" '
                            '--restore-configuration "{restore_config_json}"').get_output_in_json()
    test.kwargs.update({"restore_request": restore_json})

    # uncomment when running live, run only in record mode - grant permission
    # test.cmd('az dataprotection backup-instance update-msi-permissions '
    #         '--datasource-type AzureKubernetesService '
    #         '--operation Restore '
    #         '--permissions-scope Resource '
    #         '--vault-name "{vaultname}" '
    #         '--resource-group "{rgname}" '
    #         '--restore-request-object "{restore_request}" '
    #         '--snapshot-resource-group-id "{rg_id}" -y')
    # time.sleep(120)

    # Also uncomment when running live, only run in record mode - provide trusted access
    # helper_trusted_access(test)

    test.cmd('az dataprotection backup-instance validate-for-restore -g "{rgname}" --vault-name "{vaultname}" -n "{backup_instance_name}" --restore-request-object "{restore_request}"')

    response_json = test.cmd('az dataprotection backup-instance restore trigger '
                             '-g "{rgname}" '
                             '--vault-name "{vaultname}" '
                             ' -n "{backup_instance_name}" '
                             '--restore-request-object "{restore_request}"').get_output_in_json()
    job_status = None
    test.kwargs.update({"backup_job_id": response_json["jobId"]})
    while job_status != "Completed":
        time.sleep(10)
        job_response = test.cmd('az dataprotection job show --ids "{backup_job_id}"').get_output_in_json()
        job_status = job_response["properties"]["status"]
        if job_status not in ["Completed", "InProgress"]:
            raise Exception("Undefined job status received")

def delete_backup(test):
    test.cmd('az dataprotection backup-instance delete -g "{rgname}" --vault-name "{vaultname}" -n "{backup_instance_name}" --yes')

def cleanup(test):
    delete_backup(test)
    test.cmd('az dataprotection backup-vault delete -g "{rgname}" --vault-name "{vaultname}" --yes')

    try:
        test.cmd('az aks trustedaccess rolebinding delete -g "{rgname}" --cluster-name "{akscluster1}" -n aksRoleBindingName --yes')    
    except:
        # This is usually failing in the event of the trusted access already not existing, so we can skip it unless a new error shows.
        pass

# Test class for Scenario
class DataprotectionScenarioTest(ScenarioTest):
    def __init__(self, *args, **kwargs):
        super(DataprotectionScenarioTest, self).__init__(*args, **kwargs)

    @AllowLargeResponse()
    def test_dataprotection_aks(self):
        self.kwargs.update({
            "akscluster1": "clitest-cluster1-donotdelete",
            "akscluster2": "clitest-cluster2-donotdelete",
            "policyname": "AKSPolicyCLI1",
            "vaultname": "clitest-aks-bv",
            "rgname": "oss-clitest-rg",
            "friendlyname1": "friendly-cliclust1",
            "friendlyname2": "friendly-cliclust2",
            "policyrulename":  "BackupHourly",
            "backup_instance_name": "clitest-cluster1-donotdelete-clitest-cluster1-donotdelete-faec6818-0720-11ec-bd1b-c8f750f92764",
            "akscluster1_id": "/subscriptions/38304e13-357e-405e-9e9a-220351dcce8c/resourceGroups/oss-clitest-rg/providers/Microsoft.ContainerService/managedClusters/clitest-cluster1-donotdelete",
            "akscluster2_id": "/subscriptions/38304e13-357e-405e-9e9a-220351dcce8c/resourceGroups/oss-clitest-rg/providers/Microsoft.ContainerService/managedClusters/clitest-cluster2-donotdelete",
            "policy_id": "/subscriptions/38304e13-357e-405e-9e9a-220351dcce8c/resourceGroups/oss-clitest-rg/providers/Microsoft.DataProtection/backupVaults/clitest-aks-bv/backupPolicies/AKSPolicyCLI1",
            "vault_id": "/subscriptions/38304e13-357e-405e-9e9a-220351dcce8c/resourceGroups/oss-clitest-rg/providers/Microsoft.DataProtection/backupVaults/clitest-aks-bv",
            "rg_id": "/subscriptions/38304e13-357e-405e-9e9a-220351dcce8c/resourceGroups/oss-clitest-rg",
            "backup_instance_id": "/subscriptions/38304e13-357e-405e-9e9a-220351dcce8c/resourceGroups/oss-clitest-rg/providers/Microsoft.DataProtection/backupVaults/clitest-aks-bv/backupInstances/clitest-cluster1-donotdelete-clitest-cluster1-donotdelete-faec6818-0720-11ec-bd1b-c8f750f92764",
        })
        try:
            setup_vault_and_policy(self)
            configure_backup(self)
            trigger_backup(self)
            trigger_restore_original_location(self)
        except Exception as e:
            raise e
        finally:
            cleanup(self)
