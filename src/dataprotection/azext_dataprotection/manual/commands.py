# --------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# --------------------------------------------------------------------------------------------

# pylint: disable=too-many-statements
# pylint: disable=too-many-locals
# pylint: disable=line-too-long

from azext_dataprotection.manual._client_factory import cf_resource_graph_client
from ._exception_handler import exception_handler


def load_command_table(self, _):

    # =======================================================================
    # =                           MANUAL COMMANDS                           =
    # =======================================================================
    # Commands in this section with the format "self.command_group..." are not autogenerated/overridden.
    # They are entirely defined within the custom.py file, and also need manual management of _params.py
    # and _help.py
    with self.command_group('dataprotection backup-vault', exception_handler=exception_handler) as g:
        g.custom_command('list-from-resourcegraph', 'dataprotection_backup_vault_list_from_resourcegraph', client_factory=cf_resource_graph_client)

    with self.command_group('dataprotection backup-instance', exception_handler=exception_handler) as g:
        g.custom_command('initialize-backupconfig', "dataprotection_backup_instance_initialize_backupconfig")
        g.custom_command('initialize-restoreconfig', "dataprotection_backup_instance_initialize_restoreconfig")
        g.custom_command('initialize', "dataprotection_backup_instance_initialize")
        g.custom_command('list-from-resourcegraph', 'dataprotection_backup_instance_list_from_resourcegraph', client_factory=cf_resource_graph_client)
        g.custom_command('update-msi-permissions', 'dataprotection_backup_instance_update_msi_permissions')
        g.custom_command('update-policy', "dataprotection_backup_instance_update_policy", supports_no_wait=True)
        g.custom_command('validate-for-restore', 'dataprotection_backup_instance_validate_for_restore', supports_no_wait=True)

    with self.command_group('dataprotection backup-instance restore', exception_handler=exception_handler) as g:
        g.custom_command('initialize-for-data-recovery', 'restore_initialize_for_data_recovery')
        g.custom_command('initialize-for-data-recovery-as-files', 'restore_initialize_for_data_recovery_as_files')
        g.custom_command('initialize-for-item-recovery', 'restore_initialize_for_item_recovery')
        g.custom_command('trigger', 'dataprotection_backup_instance_restore_trigger')

    with self.command_group('dataprotection backup-policy', exception_handler=exception_handler) as g:
        g.custom_command('get-default-policy-template', "dataprotection_backup_policy_get_default_policy_template")

    with self.command_group('dataprotection backup-policy trigger') as g:
        g.custom_command('create-schedule', "dataprotection_backup_policy_trigger_create_schedule")
        g.custom_command('set', "dataprotection_backup_policy_trigger_set_in_policy")

    with self.command_group('dataprotection backup-policy retention-rule') as g:
        g.custom_command('create-lifecycle', "dataprotection_backup_policy_create_lifecycle")
        g.custom_command('set', "dataprotection_backup_policy_retention_set_in_policy")
        g.custom_command('remove', "dataprotection_backup_policy_retention_remove_in_policy")

    with self.command_group('dataprotection backup-policy tag') as g:
        g.custom_command('create-absolute-criteria', "dataprotection_backup_policy_create_absolute_criteria")
        g.custom_command('create-generic-criteria', "dataprotection_backup_policy_create_generic_criteria")
        g.custom_command('set', "dataprotection_backup_policy_tag_set_in_policy")
        g.custom_command('remove', "dataprotection_backup_policy_tag_remove_in_policy")

    with self.command_group('dataprotection job') as g:
        g.custom_command('list-from-resourcegraph', "dataprotection_job_list_from_resourcegraph", client_factory=cf_resource_graph_client)
        g.custom_command('list', "dataprotection_job_list", exception_handler=exception_handler)
        g.custom_show_command('show', 'dataprotection_job_show', exception_handler=exception_handler)

    with self.command_group('dataprotection resource-guard', exception_handler=exception_handler) as g:
        g.custom_command('list-protected-operations', 'dataprotection_resource_guard_list_protected_operations')

    # =======================================================================
    # =                 CLASS-BASED OVERRIDE OF AAZ COMMANDS                =
    # =======================================================================
    # Commands in this section with the format "self.command_table..." were autogenerated but had to be overwritten.
    # This class-based approach is the preferred style, as it extends from the existing command and does not require
    # additional code in _help.py and _params.py

    from .aaz_operations.backup_instance import (
        ValidateAndCreate as BackupInstanceCreate,
    )
    self.command_table['dataprotection backup-instance create'] = BackupInstanceCreate(loader=self)

    from .aaz_operations.backup_policy import Create as BackupPolicyCreate
    self.command_table['dataprotection backup-policy create'] = BackupPolicyCreate(loader=self)

    from .aaz_operations.resource_guard import Update as ResourceGuardUpdate
    self.command_table['dataprotection resource-guard update'] = ResourceGuardUpdate(loader=self)

    from .aaz_operations.resource_guard import Unlock as ResouceGuardMappingUnlock
    self.command_table['dataprotection resource-guard unlock'] = ResouceGuardMappingUnlock(loader=self)

    # =======================================================================
    # =               FUNCTION-BASED OVERRIDE OF AAZ COMMANDS               =
    # =======================================================================
    # Commands in this section with the format "self.command_group..." were overwritten with a function-based approach.
    # Function-based override uses AAZ arg schema to validate input but is less manageable. Needs manual management
    # of _params.py and _help.py. We ideally find a way to use class-based override without compromising AAZ Validation.

    with self.command_group('dataprotection backup-instance', exception_handler=exception_handler) as g:
        g.custom_command('validate-for-backup', 'dataprotection_backup_instance_validate_for_backup', supports_no_wait=True)

    # =======================================================================
    # =                HYBRID-BASED OVERRIDE OF AAZ COMMANDS                =
    # =======================================================================
    # Commands in this section with the format "self.command_group..." were overwritten with a class-based approach,
    # but we also use the function-style in order to provide user-friendliness. Prominently in Cross-region restore,
    # where we provide --use-secondary-region as a parameter, but behind the scenes we call an entirely different
    # API-based command when it is provided. Needs manual management of _params.py and _help.py, so we need to be
    # careful not to override defaults.

    with self.command_group('dataprotection backup-instance', exception_handler=exception_handler) as g:
        g.custom_command('validate-for-restore', 'dataprotection_backup_instance_validate_for_restore', supports_no_wait=True)

    with self.command_group('dataprotection backup-instance restore', exception_handler=exception_handler) as g:
        g.custom_command('trigger', 'dataprotection_backup_instance_restore_trigger', supports_no_wait=True)

    with self.command_group('dataprotection job') as g:
        g.custom_command('list', "dataprotection_job_list", exception_handler=exception_handler)
        g.custom_show_command('show', 'dataprotection_job_show', exception_handler=exception_handler)

    with self.command_group('dataprotection recovery-point', exception_handler=exception_handler) as g:
        g.custom_command('list', 'dataprotection_recovery_point_list')
