# --------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
#
# Code generated by aaz-dev-tools
# --------------------------------------------------------------------------------------------

# pylint: disable=too-many-lines, duplicate-key, redefined-outer-name
# pylint: disable=too-many-statements, protected-access, too-many-locals, duplicate-key,

from knack.log import get_logger
from .aaz.latest.redisenterprise.database import Flush as _DatabaseFlush
from .aaz.latest.redisenterprise.database import ForceUnlink as _DatabaseForceUnlink
from .aaz.latest.redisenterprise.database import Create as _DatabaseCreate
from .aaz.latest.redisenterprise.database import Delete as _DatabaseDelete
from .aaz.latest.redisenterprise.database import Export as _DatabaseExport
from .aaz.latest.redisenterprise.database import Import as _DatabaseImport
from .aaz.latest.redisenterprise.database import List as _DatabaseList
from .aaz.latest.redisenterprise.database import RegenerateKey as _DatabaseRegenerateKey
from .aaz.latest.redisenterprise.database import ListKeys as _DatabaseListKey
from .aaz.latest.redisenterprise.database import Show as _DatabaseShow
from .aaz.latest.redisenterprise.database import Update as _DatabaseUpdate
from .aaz.latest.redisenterprise.database import Wait as _DatabaseWait
from .aaz.latest.redisenterprise import List as _ClusterList
from .aaz.latest.redisenterprise import Show as _ClusterShow
from .aaz.latest.redisenterprise import Wait as _DatabaseWait
from .aaz.latest.redisenterprise import Update as _Update
from azure.cli.core.azclierror import (
    MutuallyExclusiveArgumentError,
)
from azure.cli.core.azclierror import ValidationError

logger = get_logger(__name__)


class RedisEnterpriseUpdate(_Update):

    def pre_instance_update(self, instance):
        """Called before the instance is updated"""
        try:
            current_sku = str(instance.sku.name) if hasattr(instance, 'sku') and instance.sku else None
        except (AttributeError, TypeError):
            current_sku = None

        new_sku = str(self.ctx.args.sku) if self.ctx.args.sku is not None else None

        if new_sku and current_sku and new_sku != current_sku:
            self._handle_sku_change(current_sku, new_sku, instance)

    def _handle_sku_change(self, current_sku, new_sku, instance):
        """Handle SKU change logic for capacity and zones"""
        # Check if changing from Azure Cache for Redis Enterprise to Azure Managed Redis SKU types
        # that don't support capacity/zones
        if (current_sku.startswith('Enterprise') and
            (new_sku.startswith('Balanced_') or
             new_sku.startswith('ComputeOptimized_') or
             new_sku.startswith('MemoryOptimized_') or
             new_sku.startswith('FlashOptimized_'))):
            # Unset capacity and zones in the instance
            try:
                if hasattr(instance, 'sku') and instance.sku and hasattr(instance.sku, 'capacity'):
                    instance.sku.capacity = None
            except (AttributeError, TypeError):
                pass

            try:
                if hasattr(instance, 'zones'):
                    instance.zones = None
            except (AttributeError, TypeError):
                pass


def _get_redis_connection(host_name, port, password, ssl=True, username=None):
    """
    Create a Redis connection using the provided credentials.

    :param host_name: The Redis host name.
    :param port: The Redis port.
    :param password: The password or token for authentication.
    :param ssl: Whether to use SSL connection.
    :param username: The username for authentication (required for Entra ID auth).
    :return: Redis client instance.
    """
    import redis
    return redis.Redis(
        host=host_name,
        port=port,
        username=username,
        password=password,
        ssl=ssl,
        ssl_cert_reqs=None,
        decode_responses=True
    )


def _test_redis_connection_with_ping(redis_client):
    """
    Test Redis connection by sending a PING command.

    :param redis_client: The Redis client instance.
    :return: Tuple of (success: bool, message: str).
    """
    test_logger = get_logger(__name__)

    try:
        test_logger.warning("Sending PING command to Redis server...")
        response = redis_client.ping()

        if response:
            test_logger.warning("PING successful, received PONG response.")
            return True, "Successfully connected and verified with PING command."

        test_logger.warning("PING command did not receive expected response.")
        return False, "PING command did not receive expected response."

    except Exception as e:  # pylint: disable=broad-except
        error_msg = f"Failed during PING operation: {str(e)}"
        test_logger.warning("Error: %s", error_msg)
        return False, error_msg


def redisenterprise_test_connection(cmd,
                                    resource_group_name=None,
                                    cluster_name=None,
                                    auth=None,
                                    host_name=None,
                                    access_key=None):
    # pylint: disable=too-many-branches, line-too-long
    """
    Test connection to a Redis Enterprise cluster using the specified authentication method.

    :param cmd: The command instance.
    :param resource_group_name: The name of the resource group (optional if host is provided).
    :param cluster_name: The name of the Redis Enterprise cluster (optional if host is provided).
    :param auth: The authentication method to use ('entra' or 'access-key').
    :param host_name: The Redis host name (optional, will be retrieved from cluster if not provided).
    :param access_key: The access key for authentication (optional, only used with access-key auth).
    :return: Connection test result.
    """
    # Default port for Redis Enterprise
    port = 10000
    database_name = 'default'

    # Parse port from hostname if provided (e.g., "myhost.redis.cache.windows.net:10000")
    if host_name and ':' in host_name:
        host_parts = host_name.rsplit(':', 1)
        host_name = host_parts[0]
        try:
            port = int(host_parts[1])
        except ValueError:
            raise ValidationError(f"Invalid port number in hostname: {host_parts[1]}")

    # Infer auth method from provided parameters
    if access_key and not auth:
        auth = 'access-key'

    # Validate parameters - host and cluster-name are mutually exclusive
    if host_name and cluster_name:
        raise MutuallyExclusiveArgumentError(
            "--host and --cluster-name cannot be used together.",
            "Use either --host (with --access-key or --auth entra) or --resource-group and --cluster-name.")

    # Validate parameters
    if host_name:
        # Direct connection mode - host is provided
        # Default to Entra auth if neither access_key nor auth is provided
        if not access_key and not auth:
            auth = 'entra'
    else:
        # Azure resource mode - need resource group and cluster name
        if not resource_group_name or not cluster_name:
            raise ValidationError("Either --host or both --resource-group and --cluster-name must be provided.")

        # Default to Entra auth if auth is not specified
        if not auth:
            auth = 'entra'

        # Get cluster information
        cluster = _ClusterShow(cli_ctx=cmd.cli_ctx)(command_args={
            "cluster_name": cluster_name,
            "resource_group": resource_group_name})

        if not cluster:
            raise ValidationError(f"Cluster '{cluster_name}' not found in resource group '{resource_group_name}'.")

        # Get the hostname from the cluster
        host_name = cluster.get('hostName')
        if not host_name:
            raise ValidationError(f"Unable to retrieve hostname for cluster '{cluster_name}'.")

    result = {
        'clusterName': cluster_name,
        'resourceGroup': resource_group_name,
        'hostName': host_name,
        'port': port,
        'databaseName': database_name,
        'authMethod': auth,
        'connectionStatus': 'NotTested',
        'message': ''
    }

    if auth == 'entra':
        # Get token from current Azure CLI credentials for Redis
        try:
            from azure.cli.core._profile import Profile

            profile = Profile(cli_ctx=cmd.cli_ctx)
            # Use get_raw_token with the Redis resource
            creds, _, _ = profile.get_raw_token(resource="https://redis.azure.com")
            access_token = creds[1]

            logger.debug("Successfully obtained Entra ID token for Redis.")

            # Create Redis connection with the token
            # For Entra auth, username is the object ID (oid) from the token
            # The password is the access token itself
            import jwt
            decoded_token = jwt.decode(access_token, options={"verify_signature": False})
            entra_object_id = decoded_token.get('oid', decoded_token.get('sub', 'default'))

            logger.warning("Connecting with Entra ID user (oid): %s", entra_object_id)

            redis_client = _get_redis_connection(
                host_name=host_name,
                port=port,
                password=access_token,
                ssl=True,
                username=entra_object_id
            )

            logger.warning("Successfully connected to Redis at %s:%s", host_name, port)

            # Test the connection with a PING command
            success, message = _test_redis_connection_with_ping(redis_client)

            if success:
                result['connectionStatus'] = 'Success'
                result['message'] = message
            else:
                result['connectionStatus'] = 'Failed'
                result['message'] = message

        except ImportError as ie:
            result['connectionStatus'] = 'Failed'
            result['message'] = (f"Required package not installed: {str(ie)}. "
                                 "Please install 'redis' and 'PyJWT' packages.")
        except Exception as e:  # pylint: disable=broad-except
            result['connectionStatus'] = 'Failed'
            result['message'] = f'Entra authentication failed: {str(e)}'

    elif auth == 'access-key':
        # Get access keys for the database
        try:
            # Use provided access key or retrieve from Azure
            if not access_key:
                if not resource_group_name or not cluster_name:
                    raise ValidationError("--access-key is required when using --host without --resource-group and --cluster-name.")

                keys = _DatabaseListKey(cli_ctx=cmd.cli_ctx)(command_args={
                    "cluster_name": cluster_name,
                    "resource_group": resource_group_name,
                    "database_name": database_name})

                if keys:
                    access_key = keys.get('primaryKey') or keys.get('secondaryKey')

            if not access_key:
                result['connectionStatus'] = 'Failed'
                result['message'] = ('Access keys authentication may be disabled. '
                                     'Enable access keys authentication or use Entra authentication.')
                return result

            # Create Redis connection with the access key
            redis_client = _get_redis_connection(
                host_name=host_name,
                port=port,
                password=access_key,
                ssl=True
            )

            logger.warning("Successfully connected to Redis at %s:%s", host_name, port)

            # Test the connection with a PING command
            success, message = _test_redis_connection_with_ping(redis_client)

            if success:
                result['connectionStatus'] = 'Success'
                result['message'] = message
            else:
                result['connectionStatus'] = 'Failed'
                result['message'] = message

        except ImportError as ie:
            result['connectionStatus'] = 'Failed'
            result['message'] = f"Required package not installed: {str(ie)}. Please install 'redis' package."
        except Exception as e:  # pylint: disable=broad-except
            result['connectionStatus'] = 'Failed'
            result['message'] = f'Failed to connect with access key: {str(e)}'

    # Raise error on connection failure to return non-zero exit code
    if result['connectionStatus'] == 'Failed':
        from azure.cli.core.azclierror import CLIError
        raise CLIError(result['message'])

    return result


class DatabaseFlush(_DatabaseFlush):

    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.database_name._registered = False
        args_schema.database_name._required = False
        return args_schema

    def pre_operations(self):
        self.ctx.args.database_name = "default"


class DatabaseForceUnlink(_DatabaseForceUnlink):

    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.database_name._registered = False
        args_schema.database_name._required = False
        return args_schema

    def pre_operations(self):
        self.ctx.args.database_name = "default"


class DatabaseCreate(_DatabaseCreate):

    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.database_name._registered = False
        args_schema.database_name._required = False
        return args_schema

    def pre_operations(self):
        self.ctx.args.database_name = "default"


class DatabaseDelete(_DatabaseDelete):

    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.database_name._registered = False
        args_schema.database_name._required = False
        return args_schema

    def pre_operations(self):
        self.ctx.args.database_name = "default"


class DatabaseExport(_DatabaseExport):

    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.database_name._registered = False
        args_schema.database_name._required = False
        return args_schema

    def pre_operations(self):
        self.ctx.args.database_name = "default"


class DatabaseImport(_DatabaseImport):

    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.database_name._registered = False
        args_schema.database_name._required = False
        return args_schema

    def pre_operations(self):
        self.ctx.args.database_name = "default"


class DatabaseRegenerateKey(_DatabaseRegenerateKey):

    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.database_name._registered = False
        args_schema.database_name._required = False
        return args_schema

    def pre_operations(self):
        self.ctx.args.database_name = "default"


class DatabaseListKey(_DatabaseListKey):

    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.database_name._registered = False
        args_schema.database_name._required = False
        return args_schema

    def pre_operations(self):
        self.ctx.args.database_name = "default"


class DatabaseShow(_DatabaseShow):

    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.database_name._registered = False
        args_schema.database_name._required = False
        return args_schema

    def pre_operations(self):
        self.ctx.args.database_name = "default"


class DatabaseUpdate(_DatabaseUpdate):

    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.database_name._registered = False
        args_schema.database_name._required = False
        return args_schema

    def pre_operations(self):
        self.ctx.args.database_name = "default"


class DatabaseWait(_DatabaseWait):

    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.database_name._registered = False
        args_schema.database_name._required = False
        return args_schema

    def pre_operations(self):
        self.ctx.args.database_name = "default"


class DatabaseList(_DatabaseList):

    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.database_name._registered = False
        args_schema.database_name._required = False
        return args_schema

    def pre_operations(self):
        self.ctx.args.database_name = "default"


def _get_cluster_with_databases(cluster,
                                databases):
    result = dict(cluster)
    # Restore select null cluster attributes that were removed by cluster.as_dict()
    if 'zones' not in cluster.keys() or cluster['zones'] is None:
        result['zones'] = None

    result['databases'] = []
    for database in databases:
        result['databases'].append(database)
    return result


def redisenterprise_list(cmd,
                         resource_group_name=None):
    if resource_group_name:
        clusters = _ClusterList(cli_ctx=cmd.cli_ctx)(command_args={"resource_group": resource_group_name})
    else:
        clusters = _ClusterList(cli_ctx=cmd.cli_ctx)(command_args={})

    result = []
    for cluster in clusters:
        cluster_resource_group = cluster['id'].split('/')[4]
        databases = _DatabaseList(cli_ctx=cmd.cli_ctx)(command_args={
            "cluster_name": cluster['name'],
            "resource_group": cluster_resource_group})
        result.append(_get_cluster_with_databases(cluster, databases))
    return result


def redisenterprise_show(cmd,
                         resource_group_name,
                         cluster_name):
    cluster = _ClusterShow(cli_ctx=cmd.cli_ctx)(command_args={
        "cluster_name": cluster_name,
        "resource_group": resource_group_name})

    databases = _DatabaseList(cli_ctx=cmd.cli_ctx)(command_args={
        "cluster_name": cluster_name,
        "resource_group": resource_group_name})

    return _get_cluster_with_databases(cluster, databases)


def redisenterprise_create(cmd,
                           resource_group_name,
                           cluster_name,
                           location,
                           sku,
                           tags=None,
                           capacity=None,
                           zones=None,
                           high_availability=None,
                           public_network_access=None,
                           key_encryption_key_url=None,
                           identity_type=None,
                           user_assigned_identities=None,
                           key_encryption_identity_type=None,
                           user_assigned_identity_resource_id=None,
                           minimum_tls_version=None,
                           client_protocol=None,
                           port=None,
                           clustering_policy=None,
                           eviction_policy=None,
                           persistence=None,
                           modules=None,
                           no_database=False,
                           no_wait=False,
                           group_nickname=None,
                           access_keys_authentication=None,
                           linked_databases=None):
    if (no_database and any(x is not None for x in [client_protocol,
                                                    port,
                                                    clustering_policy,
                                                    eviction_policy,
                                                    persistence,
                                                    modules,
                                                    group_nickname,
                                                    access_keys_authentication,
                                                    linked_databases])):
        database_param_list_str = []
        if client_protocol is not None:
            database_param_list_str.append('--client-protocol')
        if port is not None:
            database_param_list_str.append('--port')
        if clustering_policy is not None:
            database_param_list_str.append('--clustering-policy')
        if eviction_policy is not None:
            database_param_list_str.append('--eviction-policy')
        if persistence is not None:
            database_param_list_str.append('--persistence')
        if modules is not None:
            database_param_list_str.append('--modules')
        if group_nickname is not None:
            database_param_list_str.append('--group-nickname')
        if linked_databases is not None:
            database_param_list_str.append('--linked-databases')
        if access_keys_authentication is not None:
            database_param_list_str.append('--access-keys-auth')
        error_msg = ('--no-database conflicts with the specified database parameter(s): '
                     '{}'.format(', '.join(database_param_list_str)))
        recommendation = ('Try to use --no-database without specifying database parameters, '
                          'or else try removing --no-database')
        raise MutuallyExclusiveArgumentError(error_msg, recommendation)

    from .aaz.latest.redisenterprise import Create as CacheCreate
    from azure.cli.core.commands import LongRunningOperation
    if (no_database and all(x is None for x in [client_protocol,
                                                port,
                                                clustering_policy,
                                                eviction_policy,
                                                persistence,
                                                modules,
                                                group_nickname,
                                                access_keys_authentication,
                                                linked_databases])):
        return CacheCreate(cli_ctx=cmd.cli_ctx)(command_args={
            "cluster_name": cluster_name,
            "resource_group": resource_group_name,
            "location": location,
            "tags": tags,
            "location": location,
            "sku": sku,
            "capacity": capacity,
            "zones": zones,
            "high_availability": high_availability,
            "public_network_access": public_network_access,
            "minimum_tls_version": minimum_tls_version,
            "key_encryption_key_url": key_encryption_key_url,
            "identity_type": identity_type,
            "user_assigned_identities": user_assigned_identities,
            "key_encryption_identity_type": key_encryption_identity_type,
            "user_assigned_identity_resource_id": user_assigned_identity_resource_id,
            "no_wait": no_wait
        })

    poller = CacheCreate(cli_ctx=cmd.cli_ctx)(command_args={
        "cluster_name": cluster_name,
        "resource_group": resource_group_name,
        "location": location,
        "tags": tags,
        "location": location,
        "sku": sku,
        "capacity": capacity,
        "zones": zones,
        "high_availability": high_availability,
        "public_network_access": public_network_access,
        "minimum_tls_version": minimum_tls_version,
        "key_encryption_key_url": key_encryption_key_url,
        "identity_type": identity_type,
        "user_assigned_identities": user_assigned_identities,
        "key_encryption_identity_type": key_encryption_identity_type,
        "user_assigned_identity_resource_id": user_assigned_identity_resource_id,
        "no_wait": no_wait
    })
    if poller:
        LongRunningOperation(cmd.cli_ctx)(poller)
    from .aaz.latest.redisenterprise.database import Create as DatabaseCreate
    return DatabaseCreate(cli_ctx=cmd.cli_ctx)(command_args={
        "cluster_name": cluster_name,
        "resource_group": resource_group_name,
        "client_protocol": client_protocol,
        "port": port,
        "clustering_policy": clustering_policy,
        "eviction_policy": eviction_policy,
        "persistence": persistence,
        "group_nickname": group_nickname,
        "linkeddatabase": linked_databases,
        "access_keys_authentication": access_keys_authentication,
        "mods": modules,
        "database_name": 'default',
        "no_wait": no_wait
    })
