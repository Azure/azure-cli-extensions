# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from typing import TYPE_CHECKING
import warnings

from azure.core.exceptions import HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.paging import ItemPaged
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpRequest, HttpResponse
from azure.mgmt.core.exceptions import ARMErrorFormat

from .. import models

if TYPE_CHECKING:
    # pylint: disable=unused-import,ungrouped-imports
    from typing import Any, Callable, Dict, Generic, Iterable, List, Optional, TypeVar, Union

    T = TypeVar('T')
    ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

class JobOperations(object):
    """JobOperations operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~storage_import_export.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = models

    def __init__(self, client, config, serializer, deserializer):
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    def list_by_subscription(
        self,
        top=None,  # type: Optional[int]
        filter=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.ListJobsResponse"]
        """Returns all active and completed jobs in a subscription.

        :param top: An integer value that specifies how many jobs at most should be returned. The value
         cannot exceed 100.
        :type top: int
        :param filter: Can be used to restrict the results to certain conditions.
        :type filter: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either ListJobsResponse or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~storage_import_export.models.ListJobsResponse]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.ListJobsResponse"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2016-11-01"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            if self._config.accept_language is not None:
                header_parameters['Accept-Language'] = self._serialize.header("self._config.accept_language", self._config.accept_language, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_by_subscription.metadata['url']  # type: ignore
                path_format_arguments = {
                    'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if top is not None:
                    query_parameters['$top'] = self._serialize.query("top", top, 'int')
                if filter is not None:
                    query_parameters['$filter'] = self._serialize.query("filter", filter, 'str')
                query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('ListJobsResponse', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.ErrorResponse, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_by_subscription.metadata = {'url': '/subscriptions/{subscriptionId}/providers/Microsoft.ImportExport/jobs'}  # type: ignore

    def list_by_resource_group(
        self,
        resource_group_name,  # type: str
        top=None,  # type: Optional[int]
        filter=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.ListJobsResponse"]
        """Returns all active and completed jobs in a resource group.

        :param resource_group_name: The resource group name uniquely identifies the resource group
         within the user subscription.
        :type resource_group_name: str
        :param top: An integer value that specifies how many jobs at most should be returned. The value
         cannot exceed 100.
        :type top: int
        :param filter: Can be used to restrict the results to certain conditions.
        :type filter: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either ListJobsResponse or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~storage_import_export.models.ListJobsResponse]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.ListJobsResponse"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2016-11-01"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            if self._config.accept_language is not None:
                header_parameters['Accept-Language'] = self._serialize.header("self._config.accept_language", self._config.accept_language, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_by_resource_group.metadata['url']  # type: ignore
                path_format_arguments = {
                    'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
                    'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if top is not None:
                    query_parameters['$top'] = self._serialize.query("top", top, 'int')
                if filter is not None:
                    query_parameters['$filter'] = self._serialize.query("filter", filter, 'str')
                query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('ListJobsResponse', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.ErrorResponse, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_by_resource_group.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ImportExport/jobs'}  # type: ignore

    def get(
        self,
        job_name,  # type: str
        resource_group_name,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.JobResponse"
        """Gets information about an existing job.

        :param job_name: The name of the import/export job.
        :type job_name: str
        :param resource_group_name: The resource group name uniquely identifies the resource group
         within the user subscription.
        :type resource_group_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JobResponse, or the result of cls(response)
        :rtype: ~storage_import_export.models.JobResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.JobResponse"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2016-11-01"

        # Construct URL
        url = self.get.metadata['url']  # type: ignore
        path_format_arguments = {
            'jobName': self._serialize.url("job_name", job_name, 'str'),
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.accept_language is not None:
            header_parameters['Accept-Language'] = self._serialize.header("self._config.accept_language", self._config.accept_language, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('JobResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ImportExport/jobs/{jobName}'}  # type: ignore

    def update(
        self,
        job_name,  # type: str
        resource_group_name,  # type: str
        tags=None,  # type: Optional[object]
        cancel_requested=None,  # type: Optional[bool]
        state=None,  # type: Optional[str]
        return_address=None,  # type: Optional["models.ReturnAddress"]
        return_shipping=None,  # type: Optional["models.ReturnShipping"]
        delivery_package=None,  # type: Optional["models.PackageInfomation"]
        log_level=None,  # type: Optional[str]
        backup_drive_manifest=None,  # type: Optional[bool]
        drive_list=None,  # type: Optional[List["models.DriveStatus"]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.JobResponse"
        """Updates specific properties of a job. You can call this operation to notify the Import/Export
        service that the hard drives comprising the import or export job have been shipped to the
        Microsoft data center. It can also be used to cancel an existing job.

        :param job_name: The name of the import/export job.
        :type job_name: str
        :param resource_group_name: The resource group name uniquely identifies the resource group
         within the user subscription.
        :type resource_group_name: str
        :param tags: Specifies the tags that will be assigned to the job.
        :type tags: object
        :param cancel_requested: If specified, the value must be true. The service will attempt to
         cancel the job.
        :type cancel_requested: bool
        :param state: If specified, the value must be Shipping, which tells the Import/Export service
         that the package for the job has been shipped. The ReturnAddress and DeliveryPackage properties
         must have been set either in this request or in a previous request, otherwise the request will
         fail.
        :type state: str
        :param return_address: Specifies the return address information for the job.
        :type return_address: ~storage_import_export.models.ReturnAddress
        :param return_shipping: Specifies the return carrier and customer's account with the carrier.
        :type return_shipping: ~storage_import_export.models.ReturnShipping
        :param delivery_package: Contains information about the package being shipped by the customer
         to the Microsoft data center.
        :type delivery_package: ~storage_import_export.models.PackageInfomation
        :param log_level: Indicates whether error logging or verbose logging is enabled.
        :type log_level: str
        :param backup_drive_manifest: Indicates whether the manifest files on the drives should be
         copied to block blobs.
        :type backup_drive_manifest: bool
        :param drive_list: List of drives that comprise the job.
        :type drive_list: list[~storage_import_export.models.DriveStatus]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JobResponse, or the result of cls(response)
        :rtype: ~storage_import_export.models.JobResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.JobResponse"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.UpdateJobParameters(tags=tags, cancel_requested=cancel_requested, state=state, return_address=return_address, return_shipping=return_shipping, delivery_package=delivery_package, log_level=log_level, backup_drive_manifest=backup_drive_manifest, drive_list=drive_list)
        api_version = "2016-11-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.update.metadata['url']  # type: ignore
        path_format_arguments = {
            'jobName': self._serialize.url("job_name", job_name, 'str'),
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.accept_language is not None:
            header_parameters['Accept-Language'] = self._serialize.header("self._config.accept_language", self._config.accept_language, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'UpdateJobParameters')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('JobResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ImportExport/jobs/{jobName}'}  # type: ignore

    def create(
        self,
        job_name,  # type: str
        resource_group_name,  # type: str
        client_tenant_id=None,  # type: Optional[str]
        location=None,  # type: Optional[str]
        tags=None,  # type: Optional[object]
        storage_account_id=None,  # type: Optional[str]
        job_type=None,  # type: Optional[str]
        return_address=None,  # type: Optional["models.ReturnAddress"]
        return_shipping=None,  # type: Optional["models.ReturnShipping"]
        shipping_information=None,  # type: Optional["models.ShippingInformation"]
        delivery_package=None,  # type: Optional["models.PackageInfomation"]
        return_package=None,  # type: Optional["models.PackageInfomation"]
        diagnostics_path=None,  # type: Optional[str]
        log_level=None,  # type: Optional[str]
        backup_drive_manifest=None,  # type: Optional[bool]
        state=None,  # type: Optional[str]
        cancel_requested=None,  # type: Optional[bool]
        percent_complete=None,  # type: Optional[int]
        incomplete_blob_list_uri=None,  # type: Optional[str]
        drive_list=None,  # type: Optional[List["models.DriveStatus"]]
        provisioning_state=None,  # type: Optional[str]
        blob_listblob_path=None,  # type: Optional[str]
        blob_path=None,  # type: Optional[List[str]]
        blob_path_prefix=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.JobResponse"
        """Creates a new job or updates an existing job in the specified subscription.

        :param job_name: The name of the import/export job.
        :type job_name: str
        :param resource_group_name: The resource group name uniquely identifies the resource group
         within the user subscription.
        :type resource_group_name: str
        :param client_tenant_id: The tenant ID of the client making the request.
        :type client_tenant_id: str
        :param location: Specifies the supported Azure location where the job should be created.
        :type location: str
        :param tags: Specifies the tags that will be assigned to the job.
        :type tags: object
        :param storage_account_id: The resource identifier of the storage account where data will be
         imported to or exported from.
        :type storage_account_id: str
        :param job_type: The type of job.
        :type job_type: str
        :param return_address: Specifies the return address information for the job.
        :type return_address: ~storage_import_export.models.ReturnAddress
        :param return_shipping: Specifies the return carrier and customer's account with the carrier.
        :type return_shipping: ~storage_import_export.models.ReturnShipping
        :param shipping_information: Contains information about the Microsoft datacenter to which the
         drives should be shipped.
        :type shipping_information: ~storage_import_export.models.ShippingInformation
        :param delivery_package: Contains information about the package being shipped by the customer
         to the Microsoft data center.
        :type delivery_package: ~storage_import_export.models.PackageInfomation
        :param return_package: Contains information about the package being shipped from the Microsoft
         data center to the customer to return the drives. The format is the same as the deliveryPackage
         property above. This property is not included if the drives have not yet been returned.
        :type return_package: ~storage_import_export.models.PackageInfomation
        :param diagnostics_path: The virtual blob directory to which the copy logs and backups of drive
         manifest files (if enabled) will be stored.
        :type diagnostics_path: str
        :param log_level: Default value is Error. Indicates whether error logging or verbose logging
         will be enabled.
        :type log_level: str
        :param backup_drive_manifest: Default value is false. Indicates whether the manifest files on
         the drives should be copied to block blobs.
        :type backup_drive_manifest: bool
        :param state: Current state of the job.
        :type state: str
        :param cancel_requested: Indicates whether a request has been submitted to cancel the job.
        :type cancel_requested: bool
        :param percent_complete: Overall percentage completed for the job.
        :type percent_complete: int
        :param incomplete_blob_list_uri: A blob path that points to a block blob containing a list of
         blob names that were not exported due to insufficient drive space. If all blobs were exported
         successfully, then this element is not included in the response.
        :type incomplete_blob_list_uri: str
        :param drive_list: List of up to ten drives that comprise the job. The drive list is a required
         element for an import job; it is not specified for export jobs.
        :type drive_list: list[~storage_import_export.models.DriveStatus]
        :param provisioning_state: Specifies the provisioning state of the job.
        :type provisioning_state: str
        :param blob_listblob_path: The relative URI to the block blob that contains the list of blob
         paths or blob path prefixes as defined above, beginning with the container name. If the blob is
         in root container, the URI must begin with $root.
        :type blob_listblob_path: str
        :param blob_path: A collection of blob-path strings.
        :type blob_path: list[str]
        :param blob_path_prefix: A collection of blob-prefix strings.
        :type blob_path_prefix: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JobResponse, or the result of cls(response)
        :rtype: ~storage_import_export.models.JobResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.JobResponse"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.PutJobParameters(location=location, tags=tags, storage_account_id=storage_account_id, job_type=job_type, return_address=return_address, return_shipping=return_shipping, shipping_information=shipping_information, delivery_package=delivery_package, return_package=return_package, diagnostics_path=diagnostics_path, log_level=log_level, backup_drive_manifest=backup_drive_manifest, state=state, cancel_requested=cancel_requested, percent_complete=percent_complete, incomplete_blob_list_uri=incomplete_blob_list_uri, drive_list=drive_list, provisioning_state=provisioning_state, blob_listblob_path=blob_listblob_path, blob_path=blob_path, blob_path_prefix=blob_path_prefix)
        api_version = "2016-11-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create.metadata['url']  # type: ignore
        path_format_arguments = {
            'jobName': self._serialize.url("job_name", job_name, 'str'),
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.accept_language is not None:
            header_parameters['Accept-Language'] = self._serialize.header("self._config.accept_language", self._config.accept_language, 'str')
        if client_tenant_id is not None:
            header_parameters['x-ms-client-tenant-id'] = self._serialize.header("client_tenant_id", client_tenant_id, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'PutJobParameters')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if response.status_code == 200:
            deserialized = self._deserialize('JobResponse', pipeline_response)

        if response.status_code == 201:
            deserialized = self._deserialize('JobResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ImportExport/jobs/{jobName}'}  # type: ignore

    def delete(
        self,
        job_name,  # type: str
        resource_group_name,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Deletes an existing job. Only jobs in the Creating or Completed states can be deleted.

        :param job_name: The name of the import/export job.
        :type job_name: str
        :param resource_group_name: The resource group name uniquely identifies the resource group
         within the user subscription.
        :type resource_group_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2016-11-01"

        # Construct URL
        url = self.delete.metadata['url']  # type: ignore
        path_format_arguments = {
            'jobName': self._serialize.url("job_name", job_name, 'str'),
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.accept_language is not None:
            header_parameters['Accept-Language'] = self._serialize.header("self._config.accept_language", self._config.accept_language, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ImportExport/jobs/{jobName}'}  # type: ignore
