# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------


# pylint: disable=protected-access

# pylint: disable=no-self-use


import argparse
from collections import defaultdict
from knack.util import CLIError


class AddAdlsGen2FileDataSetMapping(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.adls_gen2_file_data_set_mapping = action

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'data-set-id':
                d['data_set_id'] = v[0]

            elif kl == 'file-path':
                d['file_path'] = v[0]

            elif kl == 'file-system':
                d['file_system'] = v[0]

            elif kl == 'output-type':
                d['output_type'] = v[0]

            elif kl == 'resource-group':
                d['resource_group'] = v[0]

            elif kl == 'storage-account-name':
                d['storage_account_name'] = v[0]

            elif kl == 'subscription-id':
                d['subscription_id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter adls-gen2-file-data-set-mapping. All possible keys'
                    ' are: data-set-id, file-path, file-system, output-type, resource-group, storage-account-name,'
                    ' subscription-id'.format(k)
                )

        d['kind'] = 'AdlsGen2File'

        return d


class AddAdlsGen2FileSystemDataSetMapping(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.adls_gen2_file_system_data_set_mapping = action

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'data-set-id':
                d['data_set_id'] = v[0]

            elif kl == 'file-system':
                d['file_system'] = v[0]

            elif kl == 'resource-group':
                d['resource_group'] = v[0]

            elif kl == 'storage-account-name':
                d['storage_account_name'] = v[0]

            elif kl == 'subscription-id':
                d['subscription_id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter adls-gen2-file-system-data-set-mapping. All possible'
                    ' keys are: data-set-id, file-system, resource-group, storage-account-name, subscription-id'.format(
                        k
                    )
                )

        d['kind'] = 'AdlsGen2FileSystem'

        return d


class AddAdlsGen2FolderDataSetMapping(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.adls_gen2_folder_data_set_mapping = action

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'data-set-id':
                d['data_set_id'] = v[0]

            elif kl == 'file-system':
                d['file_system'] = v[0]

            elif kl == 'folder-path':
                d['folder_path'] = v[0]

            elif kl == 'resource-group':
                d['resource_group'] = v[0]

            elif kl == 'storage-account-name':
                d['storage_account_name'] = v[0]

            elif kl == 'subscription-id':
                d['subscription_id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter adls-gen2-folder-data-set-mapping. All possible keys'
                    ' are: data-set-id, file-system, folder-path, resource-group, storage-account-name, subscription-id'
                    .format(k)
                )

        d['kind'] = 'AdlsGen2Folder'

        return d


class AddBlobContainerDataSetMapping(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.blob_container_data_set_mapping = action

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'container-name':
                d['container_name'] = v[0]

            elif kl == 'data-set-id':
                d['data_set_id'] = v[0]

            elif kl == 'resource-group':
                d['resource_group'] = v[0]

            elif kl == 'storage-account-name':
                d['storage_account_name'] = v[0]

            elif kl == 'subscription-id':
                d['subscription_id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter blob-container-data-set-mapping. All possible keys'
                    ' are: container-name, data-set-id, resource-group, storage-account-name, subscription-id'.format(k)
                )

        d['kind'] = 'Container'

        return d


class AddBlobDataSetMapping(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.blob_data_set_mapping = action

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'container-name':
                d['container_name'] = v[0]

            elif kl == 'data-set-id':
                d['data_set_id'] = v[0]

            elif kl == 'file-path':
                d['file_path'] = v[0]

            elif kl == 'output-type':
                d['output_type'] = v[0]

            elif kl == 'resource-group':
                d['resource_group'] = v[0]

            elif kl == 'storage-account-name':
                d['storage_account_name'] = v[0]

            elif kl == 'subscription-id':
                d['subscription_id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter blob-data-set-mapping. All possible keys are:'
                    ' container-name, data-set-id, file-path, output-type, resource-group, storage-account-name,'
                    ' subscription-id'.format(k)
                )

        d['kind'] = 'Blob'

        return d


class AddBlobFolderDataSetMapping(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.blob_folder_data_set_mapping = action

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'container-name':
                d['container_name'] = v[0]

            elif kl == 'data-set-id':
                d['data_set_id'] = v[0]

            elif kl == 'prefix':
                d['prefix'] = v[0]

            elif kl == 'resource-group':
                d['resource_group'] = v[0]

            elif kl == 'storage-account-name':
                d['storage_account_name'] = v[0]

            elif kl == 'subscription-id':
                d['subscription_id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter blob-folder-data-set-mapping. All possible keys are:'
                    ' container-name, data-set-id, prefix, resource-group, storage-account-name, subscription-id'
                    .format(k)
                )

        d['kind'] = 'BlobFolder'

        return d


class AddKustoClusterDataSetMapping(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.kusto_cluster_data_set_mapping = action

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'data-set-id':
                d['data_set_id'] = v[0]

            elif kl == 'kusto-cluster-resource-id':
                d['kusto_cluster_resource_id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter kusto-cluster-data-set-mapping. All possible keys'
                    ' are: data-set-id, kusto-cluster-resource-id'.format(k)
                )

        d['kind'] = 'KustoCluster'

        return d


class AddKustoDatabaseDataSetMapping(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.kusto_database_data_set_mapping = action

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'data-set-id':
                d['data_set_id'] = v[0]

            elif kl == 'kusto-cluster-resource-id':
                d['kusto_cluster_resource_id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter kusto-database-data-set-mapping. All possible keys'
                    ' are: data-set-id, kusto-cluster-resource-id'.format(k)
                )

        d['kind'] = 'KustoDatabase'

        return d


class AddKustoTableDataSetMapping(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.kusto_table_data_set_mapping = action

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'data-set-id':
                d['data_set_id'] = v[0]

            elif kl == 'kusto-cluster-resource-id':
                d['kusto_cluster_resource_id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter kusto-table-data-set-mapping. All possible keys are:'
                    ' data-set-id, kusto-cluster-resource-id'.format(k)
                )

        d['kind'] = 'KustoTable'

        return d


class AddSqldbTableDataSetMapping(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.sqldb_table_data_set_mapping = action

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'database-name':
                d['database_name'] = v[0]

            elif kl == 'data-set-id':
                d['data_set_id'] = v[0]

            elif kl == 'schema-name':
                d['schema_name'] = v[0]

            elif kl == 'sql-server-resource-id':
                d['sql_server_resource_id'] = v[0]

            elif kl == 'table-name':
                d['table_name'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter sqldb-table-data-set-mapping. All possible keys are:'
                    ' database-name, data-set-id, schema-name, sql-server-resource-id, table-name'.format(k)
                )

        d['kind'] = 'SqlDBTable'

        return d


class AddSqldwTableDataSetMapping(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.sqldw_table_data_set_mapping = action

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'data-set-id':
                d['data_set_id'] = v[0]

            elif kl == 'data-warehouse-name':
                d['data_warehouse_name'] = v[0]

            elif kl == 'schema-name':
                d['schema_name'] = v[0]

            elif kl == 'sql-server-resource-id':
                d['sql_server_resource_id'] = v[0]

            elif kl == 'table-name':
                d['table_name'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter sqldw-table-data-set-mapping. All possible keys are:'
                    ' data-set-id, data-warehouse-name, schema-name, sql-server-resource-id, table-name'.format(k)
                )

        d['kind'] = 'SqlDWTable'

        return d


class AddSynapseWorkspaceSqlPoolTableDataSetMapping(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.synapse_workspace_sql_pool_table_data_set_mapping = action

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'data-set-id':
                d['data_set_id'] = v[0]

            elif kl == 'synapse-workspace-sql-pool-table-resource-id':
                d['synapse_workspace_sql_pool_table_resource_id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter synapse-workspace-sql-pool-table-data-set-mapping.'
                    ' All possible keys are: data-set-id, synapse-workspace-sql-pool-table-resource-id'.format(k)
                )

        d['kind'] = 'SynapseWorkspaceSqlPoolTable'

        return d


class AddScheduledSynchronizationSetting(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.scheduled_synchronization_setting = action

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'recurrence-interval':
                d['recurrence_interval'] = v[0]

            elif kl == 'synchronization-time':
                d['synchronization_time'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter scheduled-synchronization-setting. All possible keys'
                    ' are: recurrence-interval, synchronization-time'.format(k)
                )

        d['kind'] = 'ScheduleBased'

        return d


class AddScheduledTrigger(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.scheduled_trigger = action

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'recurrence-interval':
                d['recurrence_interval'] = v[0]

            elif kl == 'synchronization-mode':
                d['synchronization_mode'] = v[0]

            elif kl == 'synchronization-time':
                d['synchronization_time'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter scheduled-trigger. All possible keys are:'
                    ' recurrence-interval, synchronization-mode, synchronization-time'.format(k)
                )

        d['kind'] = 'ScheduleBased'

        return d
