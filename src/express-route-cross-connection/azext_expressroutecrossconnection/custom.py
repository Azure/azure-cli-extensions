# --------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
#
# Code generated by aaz-dev-tools
# --------------------------------------------------------------------------------------------

# pylint: disable=too-many-lines
# pylint: disable=too-many-statements, protected-access
from .aaz.latest.network.cross_connection import (ListArpTables as _CrossConnectionListArpTables,
                                                  ListRouteTables as _CrossConnectionListRouteTables,
                                                  SummarizeRouteTable as _CrossConnectionSummarizeRouteTable)
from .aaz.latest.network.cross_connection.peering import Create as _PeeringCreate, Update as _PeeringUpdate
from azure.cli.core.aaz import has_value
from knack.log import get_logger


logger = get_logger(__name__)


class CrossConnectionListArpTables(_CrossConnectionListArpTables):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZArgEnum
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.path._required = True
        args_schema.path._id_part = None
        args_schema.path.enum = AAZArgEnum({'primary': 'primary', 'secondary': 'primary'})
        args_schema.peering_name._required = True
        args_schema.peering_name._id_part = None
        return args_schema


class CrossConnectionSummarizeRouteTable(_CrossConnectionSummarizeRouteTable):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZArgEnum
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.path._required = True
        args_schema.path._id_part = None
        args_schema.path.enum = AAZArgEnum({'primary': 'primary', 'secondary': 'primary'})
        args_schema.peering_name._required = True
        args_schema.peering_name._id_part = None
        return args_schema


class CrossConnectionListRouteTables(_CrossConnectionListRouteTables):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZArgEnum
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.path._required = True
        args_schema.path._id_part = None
        args_schema.path.enum = AAZArgEnum({'primary': 'primary', 'secondary': 'primary'})
        args_schema.peering_name._required = True
        args_schema.peering_name._id_part = None
        return args_schema


def create_express_route_cross_connection_peering(
        cmd, client, resource_group_name, cross_connection_name, peering_type, peer_asn, vlan_id,
        primary_peer_address_prefix, secondary_peer_address_prefix, shared_key=None,
        advertised_public_prefixes=None, customer_asn=None, routing_registry_name=None):
    (ExpressRouteCrossConnectionPeering, ExpressRouteCircuitPeeringConfig, ExpressRoutePeeringType) = \
        cmd.get_models('ExpressRouteCrossConnectionPeering', 'ExpressRouteCircuitPeeringConfig',
                       'ExpressRoutePeeringType')

    peering = ExpressRouteCrossConnectionPeering(
        peering_type=peering_type, peer_asn=peer_asn, vlan_id=vlan_id,
        primary_peer_address_prefix=primary_peer_address_prefix,
        secondary_peer_address_prefix=secondary_peer_address_prefix,
        shared_key=shared_key)

    if peering_type == ExpressRoutePeeringType.microsoft_peering.value:
        peering.microsoft_peering_config = ExpressRouteCircuitPeeringConfig(
            advertised_public_prefixes=advertised_public_prefixes,
            customer_asn=customer_asn,
            routing_registry_name=routing_registry_name)

    return client.create_or_update(resource_group_name, cross_connection_name, peering_type, peering)


class PeeringCreate(_PeeringCreate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZStrArg, AAZListArg, AAZIntArg, AAZArgEnum
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.primary_peer_subnet = AAZStrArg(
            options=['--primary-peer-subnet'],
            help='/30 subnet used to configure IP addresses for primary interface.',
            required=True
        )
        args_schema.secondary_peer_subnet = AAZStrArg(
            options=['--secondary-peer-subnet'],
            help='/30 subnet used to configure IP addresses for secondary interface.',
            required=True
        )
        args_schema.advertised_public_prefixes = AAZListArg(
            options=['--advertised-public-prefixes'],
            help='Space-separated list of prefixes to be advertised through the BGP peering.',
            arg_group='Microsoft Peering'
        )
        args_schema.advertised_public_prefixes.Element = AAZStrArg()
        args_schema.customer_asn = AAZIntArg(
            options=['--customer-asn'],
            help='Autonomous system number of the customer.',
            arg_group='Microsoft Peering'
        )
        args_schema.routing_registry_name = AAZStrArg(
            options=['--routing-registry-name'],
            help='Internet Routing Registry / Regional Internet Registry.',
            arg_group='Microsoft Peering'
        )
        args_schema.routing_registry_name.enum = AAZArgEnum({'AFRINIC': 'AFRINIC', 'ALTDB': 'ALTDB',
                                                             'APNIC': 'APNIC', 'ARIN': 'ARIN', 'LACNIC': 'LACNIC',
                                                             'LEVEL3': 'LEVEL3', 'RADB': 'RADB', 'RIPENCC': 'RIPENCC'})
        args_schema.peer_asn._required = True
        args_schema.peering_type._required = True
        args_schema.vlan_id._required = True
        args_schema.name._required = False
        args_schema.name._registered = False
        args_schema.microsoft_peering_config._registered = False
        args_schema.ipv6_peering_config._registered = False
        args_schema.primary_peer_address_prefix._registered = False
        args_schema.secondary_peer_address_prefix._registered = False
        return args_schema

    def pre_operations(self):
        args = self.ctx.args
        args.name = args.peering_type
        args.primary_peer_address_prefix = args.primary_peer_subnet
        args.secondary_peer_address_prefix = args.secondary_peer_subnet
        if args.peering_type.to_serialized_data().lower() == 'microsoftpeering':
            args.microsoft_peering_config.advertised_public_prefixes = args.advertised_public_prefixes
            args.microsoft_peering_config.customer_asn = args.customer_asn
            args.microsoft_peering_config.routing_registry_name = args.routing_registry_name


def _create_or_update_ipv6_peering(cmd, config, primary_peer_address_prefix, secondary_peer_address_prefix,
                                   advertised_public_prefixes, customer_asn, routing_registry_name):
    if config:
        # update scenario
        if primary_peer_address_prefix:
            config.primary_peer_address_prefix = primary_peer_address_prefix

        if secondary_peer_address_prefix:
            config.secondary_peer_address_prefix = secondary_peer_address_prefix

        if advertised_public_prefixes:
            config.microsoft_peering_config.advertised_public_prefixes = advertised_public_prefixes

        if customer_asn:
            config.microsoft_peering_config.customer_asn = customer_asn

        if routing_registry_name:
            config.microsoft_peering_config.routing_registry_name = routing_registry_name
    else:
        # create scenario

        IPv6Config, MicrosoftPeeringConfig = cmd.get_models(
            'Ipv6ExpressRouteCircuitPeeringConfig', 'ExpressRouteCircuitPeeringConfig')
        microsoft_config = MicrosoftPeeringConfig(advertised_public_prefixes=advertised_public_prefixes,
                                                  customer_asn=customer_asn,
                                                  routing_registry_name=routing_registry_name)
        config = IPv6Config(primary_peer_address_prefix=primary_peer_address_prefix,
                            secondary_peer_address_prefix=secondary_peer_address_prefix,
                            microsoft_peering_config=microsoft_config)

    return config


def update_express_route_peering(cmd, instance, peer_asn=None, primary_peer_address_prefix=None,
                                 secondary_peer_address_prefix=None, vlan_id=None, shared_key=None,
                                 advertised_public_prefixes=None, customer_asn=None,
                                 routing_registry_name=None, ip_version='IPv4'):

    # update settings common to all peering types
    if peer_asn is not None:
        instance.peer_asn = peer_asn

    if vlan_id is not None:
        instance.vlan_id = vlan_id

    if shared_key is not None:
        instance.shared_key = shared_key

    if ip_version == 'IPv6':
        # update is the only way to add IPv6 peering options
        instance.ipv6_peering_config = _create_or_update_ipv6_peering(cmd, instance.ipv6_peering_config,
                                                                      primary_peer_address_prefix,
                                                                      secondary_peer_address_prefix,
                                                                      advertised_public_prefixes, customer_asn,
                                                                      routing_registry_name)
    else:
        # IPv4 Microsoft Peering (or non-Microsoft Peering)
        if primary_peer_address_prefix is not None:
            instance.primary_peer_address_prefix = primary_peer_address_prefix

        if secondary_peer_address_prefix is not None:
            instance.secondary_peer_address_prefix = secondary_peer_address_prefix

        try:
            if advertised_public_prefixes is not None:
                instance.microsoft_peering_config.advertised_public_prefixes = advertised_public_prefixes

            if customer_asn is not None:
                instance.microsoft_peering_config.customer_asn = customer_asn

            if routing_registry_name is not None:
                instance.microsoft_peering_config.routing_registry_name = routing_registry_name
        except AttributeError:
            from knack.util import CLIError
            raise CLIError('--advertised-public-prefixes, --customer-asn and --routing-registry-name are only '
                           'applicable for Microsoft Peering.')

    return instance


class PeeringUpdate(_PeeringUpdate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZStrArg, AAZListArg, AAZIntArg, AAZArgEnum
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.primary_peer_subnet = AAZStrArg(
            options=['--primary-peer-subnet'],
            help='/30 subnet used to configure IP addresses for primary interface.',
        )
        args_schema.secondary_peer_subnet = AAZStrArg(
            options=['--secondary-peer-subnet'],
            help='/30 subnet used to configure IP addresses for secondary interface.',
        )
        args_schema.advertised_public_prefixes = AAZListArg(
            options=['--advertised-public-prefixes'],
            help='Space-separated list of prefixes to be advertised through the BGP peering.',
            arg_group='Microsoft Peering'
        )
        args_schema.advertised_public_prefixes.Element = AAZStrArg()
        args_schema.customer_asn = AAZIntArg(
            options=['--customer-asn'],
            help='Autonomous system number of the customer.',
            arg_group='Microsoft Peering'
        )
        args_schema.routing_registry_name = AAZStrArg(
            options=['--routing-registry-name'],
            help='Internet Routing Registry / Regional Internet Registry.',
            arg_group='Microsoft Peering'
        )
        args_schema.routing_registry_name.enum = AAZArgEnum({'AFRINIC': 'AFRINIC', 'ALTDB': 'ALTDB',
                                                             'APNIC': 'APNIC', 'ARIN': 'ARIN', 'LACNIC': 'LACNIC',
                                                             'LEVEL3': 'LEVEL3', 'RADB': 'RADB', 'RIPENCC': 'RIPENCC'})
        args_schema.ip_version = AAZStrArg(
            options=['--ip-version'],
            help='The IP version to update Microsoft Peering settings for.',
            enum={'IPv4': 'IPv4', 'IPv6': 'IPv6'},
            default='IPv4',
            arg_group='Microsoft Peering'
        )
        args_schema.peering_type._registered = False
        args_schema.microsoft_peering_config._registered = False
        args_schema.ipv6_peering_config._registered = False
        args_schema.primary_peer_address_prefix._registered = False
        args_schema.secondary_peer_address_prefix._registered = False
        return args_schema

    def pre_instance_update(self, instance):
        args = self.ctx.args
        if has_value(args.ip_version) and args.ip_version.to_serialized_data() == 'IPv6':
            if has_value(args.primary_peer_subnet):
                args.ipv6_peering_config.primary_peer_address_prefix = args.primary_peer_subnet

            if has_value(args.secondary_peer_subnet):
                args.ipv6_peering_config.secondary_peer_address_prefix = args.secondary_peer_subnet

            if has_value(args.advertised_public_prefixes):
                args.ipv6_peering_config.microsoft_peering_config.advertised_public_prefixes = \
                    args.advertised_public_prefixes

            if has_value(args.customer_asn):
                args.ipv6_peering_config.microsoft_peering_config.customer_asn = args.customer_asn

            if has_value(args.routing_registry_name):
                args.ipv6_peering_config.microsoft_peering_config.routing_registry_name = args.routing_registry_name
        else:
            if instance.properties.peering_type.lower() != 'microsoftpeering' and \
                    (has_value(args.advertised_public_prefixes) or has_value(args.customer_asn) or
                     has_value(args.routing_registry_name)):
                from azure.cli.core.azclierror import ArgumentUsageError
                raise ArgumentUsageError('--advertised-public-prefixes, --customer-asn and --routing-registry-name '
                                         'are only applicable for Microsoft Peering.')

            if has_value(args.primary_peer_subnet):
                args.primary_peer_address_prefix = args.primary_peer_subnet

            if has_value(args.secondary_peer_subnet):
                args.secondary_peer_address_prefix = args.secondary_peer_subnet

            if has_value(args.advertised_public_prefixes):
                args.microsoft_peering_config.advertised_public_prefixes = args.advertised_public_prefixes

            if has_value(args.customer_asn):
                args.microsoft_peering_config.customer_asn = args.customer_asn

            if has_value(args.routing_registry_name):
                args.microsoft_peering_config.routing_registry_name = args.routing_registry_name
