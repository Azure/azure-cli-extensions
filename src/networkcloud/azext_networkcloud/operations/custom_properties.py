# --------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
#
# Custom code that is added in addition to auto-generated by aaz-dev code.
# --------------------------------------------------------------------------------------------
# pylint: disable=too-many-lines,no-member,inconsistent-return-statements
# pylint: disable=too-many-statements,too-few-public-methods

"""
Helper class for all POST commands that return extra properties back to the customer
"""

import os
import subprocess
import tarfile
import time
import urllib

from azure.cli.core.aaz import has_value
from azure.cli.core.azclierror import AzureInternalError
from knack.log import get_logger

logger = get_logger(__name__)


def _safe_remove_file(file_path, max_retries=3, delay=0.1):
    """
    Safely remove a file with retry logic to handle Windows file locking issues.
    Args:
        file_path (str): Path to the file to be removed
        max_retries (int): Maximum number of retry attempts
        delay (float): Delay in seconds between retry attempts
    """
    if not os.path.exists(file_path):
        return

    for attempt in range(max_retries + 1):
        try:
            os.remove(file_path)
            logger.info("Successfully removed temporary file: %s", file_path)
            return
        except PermissionError as e:
            if attempt < max_retries:
                logger.warning(
                    "Failed to remove file %s (attempt %d/%d): %s. Retrying in %s seconds...",
                    file_path,
                    attempt + 1,
                    max_retries + 1,
                    str(e),
                    delay,
                )
                time.sleep(delay)
                delay *= 2  # Exponential backoff
            else:
                logger.error(
                    "Failed to remove temporary file %s after %d attempts: %s",
                    file_path,
                    max_retries + 1,
                    str(e),
                )
                # Don't raise the exception, just log it to avoid breaking the main operation
        except OSError as e:
            logger.error("Unexpected error removing file %s: %s", file_path, str(e))
            return


def _get_az_command():
    """Get the appropriate az command for the current platform"""
    if os.name == "nt":  # Windows
        # Common Azure CLI installation paths on Windows
        possible_paths = [
            r"C:\Program Files (x86)\Microsoft SDKs\Azure\CLI2\wbin\az.cmd",
            r"C:\Program Files\Microsoft SDKs\Azure\CLI2\wbin\az.cmd",
            # Try az.exe as well
            r"C:\Program Files (x86)\Microsoft SDKs\Azure\CLI2\wbin\az.exe",
            r"C:\Program Files\Microsoft SDKs\Azure\CLI2\wbin\az.exe",
        ]
        for path in possible_paths:
            if os.path.exists(path):
                return path

    # Default to 'az' for other platforms or if not found in common paths
    return "az"


class CustomActionProperties:
    """Helper class for all POST commands that return extra properties back to the customer"""

    @staticmethod
    def is_within_directory(directory, target):
        """
        Ensure the target path is within the intended directory
        """
        abs_directory = os.path.abspath(directory)
        abs_target = os.path.abspath(target)
        return os.path.commonpath([abs_directory]) == os.path.commonpath(
            [abs_directory, abs_target]
        )

    @staticmethod
    def safe_extract(tar, path="."):
        """
        Validates each file's path before extraction to prevent malicious files from escaping the target directory
        """
        for member in tar.getmembers():
            member_path = os.path.join(path, member.name)
            if not CustomActionProperties.is_within_directory(path, member_path):
                raise ValueError(
                    f"Path traversal detected: {member_path} is outside target directory {path}"
                )
        tar.extractall(path)

    # Custom handling of response will display the output head and the result_URL/result_ref
    # it will also save files into output directory if provided
    @staticmethod
    def _output(parent_cmd, *args, **kwargs):  # pylint: disable=unused-argument
        args = parent_cmd.ctx.args
        properties = parent_cmd.ctx.vars.instance.properties

        # Display the output head to the console
        if has_value(properties.output_head):
            logger.warning(properties.output_head.to_serialized_data())
            logger.warning("\n================================")

        # Display the result URL
        if (
            has_value(properties.resultUrl)
            and properties.resultUrl.to_serialized_data() != ""
        ):
            result_url = properties.resultUrl.to_serialized_data()
            logger.warning(
                "Script execution result can be found in storage account: \n %s \n",
                result_url,
            )
            # extract result to the provided directory
            if has_value(args.output):
                output_directory = (
                    args.output
                    if isinstance(args.output, str)
                    else args.output.to_serialized_data()
                )

                try:
                    with urllib.request.urlopen(result_url) as result:
                        with tarfile.open(fileobj=result, mode="r:gz") as tar:
                            CustomActionProperties.safe_extract(tar, output_directory)
                            logger.warning(
                                "Extracted results are available in directory: %s",
                                output_directory,
                            )
                except Exception as excep:
                    raise AzureInternalError(
                        f"failed to retrieve output, error {excep}"
                    ) from excep
        elif (
            has_value(properties.resultRef)
            and properties.resultRef.to_serialized_data() != ""
        ):
            result_ref = properties.resultRef.to_serialized_data()
            # parse the resultRef to get .gz filename
            try:
                parsed_url = urllib.parse.urlparse(result_ref)
                path = parsed_url.path
                downloaded_blob_name = path.split("/")[-1]
            except Exception as ex:
                error_message = (
                    f"failed to parse resultRef URL for download. Error: {str(ex)}"
                )
                logger.error(error_message)
                raise AzureInternalError(error_message) from ex

            logger.warning(
                "Script execution result can be downloaded from storage account using the "
                "command: \n az storage blob download --blob-url %s --file %s --auth-mode login  > /dev/null 2>&1 \n",
                result_ref,
                downloaded_blob_name,
            )
            # extract result to the provided directory
            if has_value(args.output):
                output_directory = (
                    args.output
                    if isinstance(args.output, str)
                    else args.output.to_serialized_data()
                )
                # Get the appropriate az command for this platform
                az_command = _get_az_command()

                # download the blob using "az storage blob download --blob-url %s --auth-mode login"
                download_command = [
                    az_command,
                    "storage",
                    "blob",
                    "download",
                    "--blob-url",
                    result_ref,
                    "--file",
                    downloaded_blob_name,
                    "--auth-mode",
                    "login",
                ]
                try:
                    result = subprocess.run(
                        download_command, check=True, capture_output=True, text=True
                    )
                    logger.info("Blob downloaded successfully.")
                except subprocess.CalledProcessError as e:
                    error_message = (
                        f"Failed to download blob. Error: {e.stderr.strip()}"
                    )
                    logger.error(error_message)
                    raise AzureInternalError(error_message) from e

                try:
                    # Extract the downloaded blob
                    with tarfile.open(downloaded_blob_name, mode="r:gz") as tar:
                        CustomActionProperties.safe_extract(tar, output_directory)
                        logger.warning(
                            "Extracted results are available in directory: %s",
                            output_directory,
                        )
                except tarfile.TarError as e:
                    error_message = f"Failed to extract blob. Error: {str(e)}"
                    logger.error(error_message)
                    raise AzureInternalError(error_message) from e
                finally:
                    # Clean up the downloaded file with retry logic for Windows
                    _safe_remove_file(downloaded_blob_name)
        else:
            result = parent_cmd.deserialize_output(
                parent_cmd.ctx.vars.instance, client_flatten=True
            )
            return result
