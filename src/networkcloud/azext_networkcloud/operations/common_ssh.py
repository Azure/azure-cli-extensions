# --------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
#
# Custom code that is added in addition to auto-generated by aaz-dev code.
# --------------------------------------------------------------------------------------------
"""
Provides Ssh Key customization
"""
# pylint: disable=line-too-long,wildcard-import,too-many-nested-blocks,no-self-argument,no-method-argument

import os

from azure.cli.core import keys
from azure.cli.core.aaz import AAZBoolArg, AAZListArg, AAZStrArg
from azure.cli.core.aaz._base import has_value
from azure.cli.core.azclierror import InvalidArgumentValueError
from knack.log import get_logger

logger = get_logger(__name__)


class CustomSshOptions:
    """Custom class providing common ssh operations"""

    @staticmethod
    def generate_ssh_keys():
        """generates ssh keys in user .ssh folder"""

        key_name = "id_rsa_generated"
        private_key_path = os.path.join(os.path.expanduser("~"), ".ssh", key_name)
        public_key_path = os.path.join(
            os.path.expanduser("~"), ".ssh", f"{key_name}.pub"
        )
        logger.warning(
            "Attempted to find or generate SSH key files %s and %s.pub under ~/.ssh to allow SSH access "
            "to the vm. If using machines without permanent storage, back up "
            "your keys to a safe location.",
            key_name,
            key_name,
        )
        return [{"keyData": keys.generate_ssh_keys(private_key_path, public_key_path)}]

    @staticmethod
    def get_ssh_keys_from_path(values):
        """get ssh keys from the provided path"""

        key_list = []
        for path in values:
            # Casting is necessary to get away from the custom type AAZSimpleType wrapping the string we want
            path = str(path)
            if os.path.isdir(path):
                content = ""
                for key in os.listdir(path):
                    if key.endswith(".pub"):
                        with open(
                            os.path.join(
                                path,
                                key,
                            ),
                            "r",
                            encoding="utf-8",
                        ) as k:
                            content = k.read()
                        try:
                            if keys.is_valid_ssh_rsa_public_key(content):
                                key_list.append({"keyData": content})
                        except Exception as exception:
                            raise InvalidArgumentValueError(
                                f"Unsupported Key {key} is provided.\nContent:\n{content}."
                            ) from exception
                if len(key_list) == 0:
                    raise InvalidArgumentValueError(
                        f"No public keys found in the path: {path}"
                    )
            elif os.path.isfile(path):
                with open(path, "r", encoding="utf-8") as k:
                    content = k.read()
                try:
                    if keys.is_valid_ssh_rsa_public_key(content):
                        key_list.append({"keyData": content})
                except Exception as excep:
                    raise InvalidArgumentValueError(
                        f"Unsupported Key {path} is provided.\nContent:\n{content}"
                    ) from excep
            else:
                raise InvalidArgumentValueError(
                    f"An invalid directory or key was provided: {path}"
                )
        return key_list

    @staticmethod
    def add_ssh_key_action(values):
        """validate and add ssh key to the list"""

        key_data = []
        for key in values:
            # Casting is necessary to get away from the custom type AAZSimpleType wrapping the string we want
            key = str(key)
            try:
                if keys.is_valid_ssh_rsa_public_key(key):
                    key_data.append({"keyData": key})
            except Exception as excep:
                raise InvalidArgumentValueError(
                    f"Unsupported Key is provided.\nContent:\n{key}"
                ) from excep
        return key_data

    @staticmethod
    # pylint: disable=unused-argument
    def build_ssh_arg_schema(args_schema, is_update, group):
        ssh_help = "The list of space-separated SSH public keys."
        args_schema.ssh_key_values = AAZListArg(
            options=["--ssh-key-values"],
            arg_group=group,
            help=ssh_help,
        )
        args_schema.ssh_key_values.Element = AAZStrArg()
        args_schema.generate_ssh_keys = AAZBoolArg(
            options=["--generate-ssh-keys"],
            arg_group=group,
            help="Generate SSH public and private key files if missing. The keys will "
            + "be stored under '~/.ssh'.",
        )
        args_schema.generate_ssh_keys.Element = AAZStrArg()
        args_schema.ssh_dest_key_path = AAZListArg(
            options=["--ssh-dest-key-path"],
            arg_group=group,
            help="The list of space-separated paths to ssh public keys. A file path can be "
            + "provided or a directory. If a directory is provided will attempt to load all the "
            + "public keys (.pub) found.",
        )
        args_schema.ssh_dest_key_path.Element = AAZStrArg()
        return args_schema

    @classmethod
    def add_ssh_config(cls, args):
        ssh_keys = []
        if has_value(args.generate_ssh_keys) and bool(args.generate_ssh_keys):
            ssh_keys += cls.generate_ssh_keys()
        if has_value(args.ssh_dest_key_path):
            ssh_keys += cls.get_ssh_keys_from_path(list(args.ssh_dest_key_path))
        if has_value(args.ssh_key_values):
            ssh_keys += cls.add_ssh_key_action(list(args.ssh_key_values))
        return ssh_keys

    @classmethod
    def has_ssh_config(cls, args):
        has_ssh_config = False
        if has_value(args.generate_ssh_keys) and bool(args.generate_ssh_keys):
            has_ssh_config = True
        if has_value(args.ssh_dest_key_path):
            has_ssh_config = True
        if has_value(args.ssh_key_values):
            has_ssh_config = True
        return has_ssh_config
