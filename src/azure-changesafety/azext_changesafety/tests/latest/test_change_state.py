# --------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
#
# Code generated by aaz-dev-tools
# --------------------------------------------------------------------------------------------

import copy
import sys
import types
from types import SimpleNamespace
from unittest import mock

from azure.cli.testsdk import *  # pylint: disable=wildcard-import,unused-wildcard-import

from azext_changesafety.custom import (
    ChangeStateCreate,
    ChangeStateDelete,
    ChangeStateShow,
    ChangeStateUpdate,
    _inject_change_definition_into_content,
    _inject_targets_into_result,
    _normalize_targets_arg,
)
from azure.cli.core.aaz import AAZAnyType, has_value
from azure.cli.core.aaz._arg_action import AAZArgActionOperations, _ELEMENT_APPEND_KEY


class ChangeStateScenario(ScenarioTest):
    FAKE_SUBSCRIPTION_ID = "00000000-0000-0000-0000-000000000000"
    _SCENARIO_STATE = {}

    class _DummyPoller:  # pylint: disable=too-few-public-methods
        def result(self, timeout=None):  # pylint: disable=unused-argument
            return None

        def wait(self, timeout=None):  # pylint: disable=unused-argument
            return None

        def done(self):
            return True

        def add_done_callback(self, func):
            if func:
                func(self)

    @staticmethod
    def _dummy_ctx_with_change_definition(payload):
        dummy = SimpleNamespace()
        dummy.to_serialized_data = lambda: payload
        return SimpleNamespace(vars=SimpleNamespace(change_definition=dummy))

    @classmethod
    def _ensure_msrestazure_stub(cls):
        if 'msrestazure' in sys.modules:
            return

        msrestazure = types.ModuleType('msrestazure')
        azure_operation = types.ModuleType('msrestazure.azure_operation')

        class AzureOperationPoller:  # pylint: disable=too-few-public-methods
            def _delay(self, *args, **kwargs):  # pylint: disable=unused-argument
                return

        azure_operation.AzureOperationPoller = AzureOperationPoller
        arm_polling = types.ModuleType('msrestazure.polling.arm_polling')

        class ARMPolling:  # pylint: disable=too-few-public-methods
            def _delay(self, *args, **kwargs):  # pylint: disable=unused-argument
                return

        arm_polling.ARMPolling = ARMPolling
        polling = types.ModuleType('msrestazure.polling')
        polling.arm_polling = arm_polling

        msrestazure.azure_operation = azure_operation
        msrestazure.polling = polling

        sys.modules['msrestazure'] = msrestazure
        sys.modules['msrestazure.azure_operation'] = azure_operation
        sys.modules['msrestazure.polling'] = polling
        sys.modules['msrestazure.polling.arm_polling'] = arm_polling

    @staticmethod
    def _get_arg_value(cmd, arg_name, default=None):
        arg = getattr(cmd.ctx.args, arg_name, None)
        if arg is None or not has_value(arg):
            return default
        return arg.to_serialized_data()

    @staticmethod
    def _build_mock_instance(name, resource_group, subscription_id, change_type, rollout_type, targets, comments=None):
        return {
            "id": f"/subscriptions/{subscription_id}/resourceGroups/{resource_group}/providers/Microsoft.ChangeSafety/changeStates/{name}",
            "name": name,
            "type": "Microsoft.ChangeSafety/changeStates",
            "location": "eastus",
            "properties": {
                "changeType": change_type,
                "rolloutType": rollout_type,
                "comments": comments,
                "changeDefinition": {
                    "kind": "Targets",
                    "name": name,
                    "details": {
                        "targets": targets or []
                    }
                }
            }
        }

    @staticmethod
    def _mock_create_execute(cmd):
        cls = ChangeStateScenario
        cmd.pre_operations()
        name = cls._get_arg_value(cmd, "change_state_name", "mock-change")
        resource_group = cls._get_arg_value(cmd, "resource_group", "mock-rg")
        subscription_id = cmd.ctx.subscription_id or cls.FAKE_SUBSCRIPTION_ID
        change_type = cls._get_arg_value(cmd, "change_type", "ManualTouch")
        rollout_type = cls._get_arg_value(cmd, "rollout_type", "Normal")
        comments = cls._get_arg_value(cmd, "comments")
        targets = copy.deepcopy(cmd._parsed_targets or [])
        instance = cls._build_mock_instance(
            name=name,
            resource_group=resource_group,
            subscription_id=subscription_id,
            change_type=change_type,
            rollout_type=rollout_type,
            targets=targets,
            comments=comments,
        )
        cls._SCENARIO_STATE["instance"] = copy.deepcopy(instance)
        cmd.ctx.set_var("instance", copy.deepcopy(instance), schema_builder=lambda: AAZAnyType())
        cmd.post_operations()
        return iter(())

    @staticmethod
    def _mock_update_execute(cmd):
        cls = ChangeStateScenario
        cmd._raw_targets = [token for token in (cmd._raw_targets or []) if token and token != 'Undefined']  # pylint: disable=protected-access
        cmd.pre_operations()
        current = copy.deepcopy(cls._SCENARIO_STATE.get("instance"))
        if current is None:
            name = cls._get_arg_value(cmd, "change_state_name", "mock-change")
            resource_group = cls._get_arg_value(cmd, "resource_group", "mock-rg")
            subscription_id = cmd.ctx.subscription_id or cls.FAKE_SUBSCRIPTION_ID
            current = cls._build_mock_instance(
                name=name,
                resource_group=resource_group,
                subscription_id=subscription_id,
                change_type="ManualTouch",
                rollout_type="Normal",
                targets=[],
            )
        new_change_type = cls._get_arg_value(cmd, "change_type")
        new_rollout = cls._get_arg_value(cmd, "rollout_type")
        new_comments = cls._get_arg_value(cmd, "comments")
        if new_change_type:
            current["properties"]["changeType"] = new_change_type
        if new_rollout:
            current["properties"]["rolloutType"] = new_rollout
        if new_comments is not None:
            current["properties"]["comments"] = new_comments
        if cmd._parsed_targets:  # pylint: disable=protected-access
            current["properties"]["changeDefinition"]["details"]["targets"] = copy.deepcopy(cmd._parsed_targets)  # pylint: disable=protected-access
        cls._SCENARIO_STATE["instance"] = copy.deepcopy(current)
        cmd.ctx.set_var("instance", copy.deepcopy(current), schema_builder=lambda: AAZAnyType())
        cmd.post_operations()
        return iter(())

    @staticmethod
    def _mock_show_execute(cmd):
        cls = ChangeStateScenario
        cmd.pre_operations()
        instance = copy.deepcopy(cls._SCENARIO_STATE.get("instance"))
        cmd.ctx.set_var("instance", instance, schema_builder=lambda: AAZAnyType())
        cmd.post_operations()
        return iter(())

    @staticmethod
    def _mock_delete_execute(cmd):
        cls = ChangeStateScenario
        cmd.pre_operations()
        cls._SCENARIO_STATE.pop("instance", None)
        cmd.post_operations()
        return iter(())

    @staticmethod
    def _mock_build_lro_poller(cmd, executor, extract_result):  # pylint: disable=unused-argument
        executor()
        return ChangeStateScenario._DummyPoller()  # pylint: disable=protected-access

    def setUp(self):
        type(self)._ensure_msrestazure_stub()
        super().setUp()
        type(self)._SCENARIO_STATE.clear()
        self._patchers = [
            mock.patch('azext_changesafety.custom.ChangeStateCreate._execute_operations', new=type(self)._mock_create_execute),
            mock.patch('azext_changesafety.custom.ChangeStateUpdate._execute_operations', new=type(self)._mock_update_execute),
            mock.patch('azext_changesafety.custom.ChangeStateShow._execute_operations', new=type(self)._mock_show_execute),
            mock.patch('azext_changesafety.custom.ChangeStateDelete._execute_operations', new=type(self)._mock_delete_execute),
            mock.patch('azext_changesafety.custom.ChangeStateDelete.build_lro_poller', new=type(self)._mock_build_lro_poller),
        ]
        for patcher in self._patchers:
            patcher.start()
            self.addCleanup(patcher.stop)

    def test_normalize_targets_from_operations(self):
        operations = AAZArgActionOperations.__new__(AAZArgActionOperations)
        operations._ops = [  # pylint: disable=protected-access
            ((_ELEMENT_APPEND_KEY,), "env=prod"),
            ((0, "resourceId"), "/subscriptions/000/resourceGroups/rg/providers/Microsoft.Web/sites/app"),
            ((0, "operation"), "delete"),
            ((1,), "subscriptionId=00000000-0000-0000-0000-000000000000"),
        ]

        normalized = _normalize_targets_arg(operations)

        assert normalized == [
            "env=prod,resourceId=/subscriptions/000/resourceGroups/rg/providers/Microsoft.Web/sites/app,operation=delete",
            "subscriptionId=00000000-0000-0000-0000-000000000000",
        ]

    def test_normalize_targets_from_serializable_value(self):
        class DummySerializable:
            def to_serialized_data(self):
                return ["rg=my-rg", None, "", "operation=show"]

        normalized = _normalize_targets_arg(DummySerializable())

        assert normalized == ["rg=my-rg", "operation=show"]

    def test_normalize_targets_from_list_of_strings(self):
        raw_targets = [" resourceId=/foo ", "", "operation=PUT", None]

        normalized = _normalize_targets_arg(raw_targets)

        assert normalized == ["resourceId=/foo", "operation=PUT"]

    def test_normalize_targets_with_none_returns_empty(self):
        assert _normalize_targets_arg(None) == []

    def test_inject_change_definition_into_content_adds_properties(self):
        ctx = self._dummy_ctx_with_change_definition({"details": {"targets": []}})
        content = {"properties": {"existing": "value"}}

        result = _inject_change_definition_into_content(content, ctx)

        assert result["properties"]["existing"] == "value"
        assert result["properties"]["changeDefinition"] == {"details": {"targets": []}}

    def test_inject_change_definition_with_empty_payload_noop(self):
        ctx = self._dummy_ctx_with_change_definition({})
        original = {"properties": {"foo": "bar"}}

        result = _inject_change_definition_into_content(original.copy(), ctx)

        assert result == original

    def test_inject_targets_into_result_updates_nested_properties(self):
        data = {"properties": {"changeDefinition": {"details": {}}}}
        targets = [{"resourceId": "/foo"}]

        _inject_targets_into_result(data, targets)

        assert data["properties"]["changeDefinition"]["details"]["targets"] == targets

    def test_inject_targets_does_not_override_existing(self):
        existing = [{"resourceId": "/existing"}]
        data = {"changeDefinition": {"details": {"targets": existing.copy()}}}
        new_targets = [{"resourceId": "/new"}]

        _inject_targets_into_result(data, new_targets)

        assert data["changeDefinition"]["details"]["targets"] == existing

    def test_change_state_cli_scenario(self):
        resource_group = "rgChangeSafetyScenario"
        change_state_name = self.create_random_name('chg', 12)
        target_resource = (
            f"/subscriptions/{self.FAKE_SUBSCRIPTION_ID}/resourceGroups/{resource_group}/"
            "providers/Microsoft.Compute/virtualMachines/myVm"
        )
        self.kwargs.update({
            "rg": resource_group,
            "name": change_state_name,
            "change_type": "ManualTouch",
            "rollout_type": "Normal",
            "updated_rollout": "Emergency",
            "targets": f"resourceId={target_resource},operation=PATCH",
        })

        create_checks = [
            JMESPathCheck('name', change_state_name),
            JMESPathCheck('properties.changeType', 'ManualTouch'),
            JMESPathCheck('properties.rolloutType', 'Normal'),
            JMESPathCheck('properties.changeDefinition.details.targets[0].resourceId', target_resource),
            JMESPathCheck('properties.changeDefinition.details.targets[0].httpMethod', 'PATCH'),
        ]
        self.cmd(
            'az changesafety changestate create -g {rg} -n {name} '
            '--change-type {change_type} --rollout-type {rollout_type} '
            '--targets "{targets}" --comments "Initial deployment"',
            checks=create_checks,
        )

        update_checks = [
            JMESPathCheck('properties.rolloutType', 'Emergency'),
            JMESPathCheck('properties.comments', 'Escalated rollout'),
        ]
        self.cmd(
            'az changesafety changestate update -g {rg} -n {name} '
            '--rollout-type {updated_rollout} --comments "Escalated rollout"',
            checks=update_checks,
        )

        self.cmd(
            'az changesafety changestate show -g {rg} -n {name}',
            checks=[
                JMESPathCheck('properties.comments', 'Escalated rollout'),
                JMESPathCheck('properties.changeDefinition.details.targets[0].resourceId', target_resource),
            ],
        )

        self.cmd('az changesafety changestate delete -g {rg} -n {name} -y')
        self.assertNotIn("instance", type(self)._SCENARIO_STATE)
