# --------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
#
# Code generated by aaz-dev-tools
# --------------------------------------------------------------------------------------------

# pylint: disable=line-too-long

"""Custom command overrides for azure-changesafety CLI extension.

This module provides customizations for ChangeRecord CRUD operations:
- ChangeRecordCreate: Custom --targets parsing, --stagemap-name shortcut, schedule defaults
- ChangeRecordUpdate: Preserves changeDefinition during GET+PUT cycle (AAZ schema workaround)
- ChangeRecordShow: Custom schema to expose details.targets array
- ChangeRecordDelete: Help examples only
"""

import datetime
from argparse import SUPPRESS

from knack.log import get_logger
from azure.cli.core.aaz import (
    has_value,
    AAZAnyType,
    AAZAnyTypeArg,
    AAZListArg,
    AAZStrArg,
    AAZObjectType,
    AAZStrType,
    AAZListType,
)
from azure.cli.core.aaz._arg_action import (  # pylint: disable=protected-access
    AAZArgActionOperations,
    AAZPromptInputOperation,
    _ELEMENT_APPEND_KEY,
)
from azure.cli.core.azclierror import InvalidArgumentValueError
from azext_changesafety.aaz.latest.changesafety.changerecord import (
    Create as _ChangeRecordCreate,
    Update as _ChangeRecordUpdate,
    Show as _ChangeRecordShow,
    Delete as _ChangeRecordDelete,
)
# Import for schema building - used by _build_custom_show_schema
from azext_changesafety.aaz.latest.changesafety.changerecord._show import (
    Show as _GeneratedShow,
)


logger = get_logger(__name__)

# -----------------------------------------------------------------------------
# Constants
# -----------------------------------------------------------------------------
CHANGE_DEFINITION_KIND_TARGETS = "Targets"
CHANGE_DEFINITION_KIND_API_OPERATIONS = "ApiOperations"

# Mapping of user-friendly key names to API field names for --targets parsing
TARGET_KEY_MAPPING = {
    'resourceid': 'resourceId',
    'subscriptionid': 'subscriptionId',
    'resourcegroupname': 'resourceGroupName',
    'resourcegroup': 'resourceGroupName',
    'rg': 'resourceGroupName',
    'resourcetype': 'resourceType',
    'resourcename': 'resourceName',
    'httpmethod': 'httpMethod',
    'method': 'httpMethod',
    'operation': 'httpMethod',
}


# -----------------------------------------------------------------------------
# Helper Functions
# -----------------------------------------------------------------------------

def _build_any_type():
    """Return an AAZAnyType instance for schema_builder callbacks.

    This is needed because schema_builder expects a callable that returns a schema type.
    Using a function instead of a lambda keeps linters happy.
    """
    return AAZAnyType()


def _apply_stage_map_shortcut(ctx):
    """Translate --stagemap-name into the stage_map resourceId payload.

    This shared helper allows users to specify just the StageMap name instead of
    the full resource ID. It builds the resource ID using the current subscription.

    Args:
        ctx: The AAZ command context containing args and subscription_id.

    Raises:
        InvalidArgumentValueError: If both --stage-map and --stagemap-name are provided,
            or if subscription_id is not available.
    """
    stage_map_arg = getattr(ctx.args, "stage_map", None)
    stage_map_name_arg = getattr(ctx.args, "stagemap_name", None)
    has_stage_map = has_value(stage_map_arg)
    has_stage_map_name = has_value(stage_map_name_arg)

    if has_stage_map and has_stage_map_name:
        raise InvalidArgumentValueError(
            "Use either --stage-map or --stagemap-name/--stage-map-name, not both."
        )

    if not has_stage_map_name:
        return

    subscription_id = getattr(ctx, "subscription_id", None)
    if not subscription_id:
        raise InvalidArgumentValueError(
            "A subscription is required to resolve the StageMap scope."
        )

    resource_id = (
        f"/subscriptions/{subscription_id}/providers/"
        f"Microsoft.ChangeSafety/stageMaps/{stage_map_name_arg.to_serialized_data()}"
    )
    logger.debug("Resolved StageMap resourceId from name: %s", resource_id)
    ctx.args.stage_map = {"resource_id": resource_id}


def _inject_change_definition_into_content(content, ctx):
    """Attach the computed changeDefinition payload to the serialized request content."""
    change_definition_value = getattr(ctx.vars, "change_definition", None)
    if change_definition_value is None:
        return content

    change_definition = change_definition_value.to_serialized_data()
    if not change_definition:
        return content

    if content is None:
        content = {}
    properties = content.setdefault("properties", {})
    properties["changeDefinition"] = change_definition
    return content


def _preserve_change_definition_in_content(content, ctx):
    """Preserve the original changeDefinition from GET response in the update request.

    The changeDefinition cannot be modified after creation, so we must preserve
    the original value from the GET response to avoid sending an empty/invalid
    changeDefinition in the PUT request.
    """
    if content is None:
        return content

    # Get the original changeDefinition captured from the raw GET response
    original_change_definition = getattr(ctx, "_original_change_definition", None)

    if original_change_definition is not None:
        properties = content.get("properties")
        if properties is not None:
            # Replace the corrupted changeDefinition with the original from the GET response
            properties["changeDefinition"] = original_change_definition
            logger.debug("Preserved original changeDefinition in update request")

    return content


def _normalize_targets_arg(raw_targets):  # pylint: disable=too-many-branches
    """Return a list of raw target strings from the parsed CLI argument."""
    if raw_targets is None:
        return []

    if isinstance(raw_targets, AAZArgActionOperations):
        return _normalize_aaz_operations(raw_targets)

    if hasattr(raw_targets, 'to_serialized_data'):
        values = raw_targets.to_serialized_data()
    elif isinstance(raw_targets, list):
        values = raw_targets
    else:
        values = [raw_targets]

    return [str(v).strip() for v in values if v is not None and str(v).strip()]


def _normalize_aaz_operations(raw_targets):
    """Process AAZArgActionOperations to extract target strings."""
    elements = []
    for keys, data in raw_targets._ops:  # pylint: disable=protected-access
        logger.debug("Processing target op keys=%s data=%s", keys, data)
        if isinstance(data, AAZPromptInputOperation):
            data = data()

        normalized_value = _normalize_data_value(data)
        idx, key_name = _extract_index_and_key(keys, len(elements))

        if key_name:
            # AAZ parsed "key=value,..." - reconstruct the full target string
            full_target = f"{key_name}={normalized_value}" if normalized_value else key_name
            _append_or_set_element(elements, idx, full_target)
        else:
            _append_or_set_element(elements, idx, normalized_value)

    return [value for value in elements if value]


def _normalize_data_value(data):
    """Convert data to a normalized string value."""
    if isinstance(data, (list, tuple)):
        return ','.join(str(v) for v in data if v is not None)
    return str(data) if data is not None else ''


def _extract_index_and_key(keys, current_length):
    """Extract index and key name from AAZ operation keys."""
    idx = None
    key_name = None
    for key in keys:
        if key == _ELEMENT_APPEND_KEY:
            idx = current_length
        elif isinstance(key, int):
            idx = key
        elif isinstance(key, str):
            key_name = key
    return idx, key_name


def _append_or_set_element(elements, idx, value):
    """Append or set an element in the list at the given index."""
    if idx is not None:
        while len(elements) <= idx:
            elements.append('')
        elements[idx] = value
    else:
        elements.append(value)


def _inject_targets_into_result(data, targets):
    """Ensure changeDefinition.details.targets is present in the command output."""
    if not targets or data is None:
        return

    def process(item):
        if not isinstance(item, dict):
            return
        containers = []
        if isinstance(item.get('properties'), dict):
            containers.append(item['properties'])
        containers.append(item)
        for container in containers:
            change_def = container.get('changeDefinition')
            if isinstance(change_def, dict):
                details = change_def.setdefault('details', {})
                if isinstance(details, dict) and not details.get('targets'):
                    details['targets'] = targets

    if isinstance(data, list):
        for entry in data:
            process(entry)
    else:
        process(data)


def _build_custom_show_schema():
    """Build a custom schema for Show command that includes details.targets.

    The generated AAZ schema doesn't know about the free-form 'details' object
    structure, so we extend it to properly deserialize the targets array.

    Returns:
        AAZObjectType: The extended schema with targets array definition.
    """
    # Get the base schema from the generated code
    # pylint: disable-next=protected-access
    base_schema = _GeneratedShow.ChangeRecordsGet._build_schema_on_200()

    # Inject schema for details.targets - the generated code doesn't know this structure
    change_definition = base_schema.properties.change_definition
    details = change_definition.details
    details.targets = AAZListType(flags={"read_only": True})
    details.targets.Element = AAZObjectType()
    details.targets.Element.resourceId = AAZStrType()
    details.targets.Element.subscriptionId = AAZStrType()
    details.targets.Element.resourceGroupName = AAZStrType()
    details.targets.Element.resourceType = AAZStrType()
    details.targets.Element.resourceName = AAZStrType()
    details.targets.Element.httpMethod = AAZStrType()

    return base_schema


# -----------------------------------------------------------------------------
# Command Classes
# -----------------------------------------------------------------------------

class ChangeRecordCreate(_ChangeRecordCreate):
    """Custom Create command with --targets parsing and --stagemap-name shortcut."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._raw_targets = []
        self._parsed_targets = None

    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        schema = super()._build_arguments_schema(*args, **kwargs)
        if not hasattr(schema, "change_definition"):
            schema.change_definition = AAZAnyTypeArg(  # type: ignore[attr-defined]
                options=["--change-definition"],
                arg_group="Properties",
                help=SUPPRESS,
                nullable=True,
                blank={},
            )
        if not hasattr(schema, "stagemap_name"):
            schema.stagemap_name = AAZStrArg(  # type: ignore[attr-defined]
                options=["--stagemap-name", "--stage-map-name"],
                arg_group="Properties",
                help=(
                    "StageMap name in the current subscription scope. Automatically builds "
                    "the stage map resource ID."
                ),
            )
        if not hasattr(schema, "targets"):
            schema.targets = AAZListArg(
                options=["--targets"],
                help=(
                    "Target definitions expressed as key=value pairs separated by commas or semicolons. "
                    "Example: --targets \"resourceId=RESOURCE_ID,operation=delete\""
                ),
            )
            schema.targets.Element = AAZStrArg()
        return schema

    def _handler(self, command_args):
        # Extract targets before calling parent handler so we can accept flexible input formats.
        self._raw_targets = []
        self._parsed_targets = None
        command_args = dict(command_args) if command_args else {}
        raw_targets = command_args.pop('targets', None)
        if raw_targets is not None:
            self._raw_targets = _normalize_targets_arg(raw_targets)
        return super()._handler(command_args)

    def pre_operations(self):
        super().pre_operations()
        self._ensure_schedule_defaults()
        _apply_stage_map_shortcut(self.ctx)

        change_definition_arg = getattr(self.ctx.args, "change_definition", None)
        change_definition_value = None
        self._raw_targets = [t for t in (self._raw_targets or []) if t and str(t) != 'Undefined']
        if has_value(change_definition_arg):
            change_definition_value = self._parse_change_definition_arg(change_definition_arg)
            if self._raw_targets:
                raise InvalidArgumentValueError("Use either --change-definition or --targets, not both.")

        if change_definition_value is None and not self._raw_targets:
            raise InvalidArgumentValueError('--targets is required unless you provide --change-definition JSON.')

        # Build and set the changeDefinition with targets
        change_definition = change_definition_value or self._build_change_definition()
        logger.debug("Final changeDefinition for create: %s", change_definition)
        self.ctx.set_var(
            'change_definition',
            change_definition,
            schema_builder=_build_any_type,
        )

    def _ensure_schedule_defaults(self):
        """Populate anticipated start/end time defaults when the user omits them."""
        now = datetime.datetime.now(datetime.timezone.utc)
        start_arg = getattr(self.ctx.args, "anticipated_start_time", None)
        end_arg = getattr(self.ctx.args, "anticipated_end_time", None)
        start_dt = self._parse_datetime_value(start_arg) if has_value(start_arg) else None
        if start_dt is None:
            start_dt = now
            self.ctx.args.anticipated_start_time = self._to_iso8601(start_dt)
        if not has_value(end_arg):
            self.ctx.args.anticipated_end_time = self._to_iso8601(start_dt + datetime.timedelta(hours=8))

    @staticmethod
    def _to_iso8601(value):
        serialized = value.isoformat(timespec="seconds")
        return serialized.replace("+00:00", "Z")

    @staticmethod
    def _parse_datetime_value(value):
        text = None
        if value is None:
            return None
        if hasattr(value, "to_serialized_data"):
            text = value.to_serialized_data()
        elif isinstance(value, str):
            text = value
        if not text:
            return None
        try:
            return datetime.datetime.fromisoformat(str(text).replace("Z", "+00:00"))
        except ValueError:
            return None

    def _parse_change_definition_arg(self, change_definition_arg):
        data = change_definition_arg.to_serialized_data()
        if data is None:
            return None
        if not isinstance(data, dict):
            raise InvalidArgumentValueError("--change-definition must be valid JSON object.")
        return data

    def _build_change_definition(self):
        """Build the changeDefinition object with targets"""
        targets = self._parse_targets(self._raw_targets)
        self._parsed_targets = targets
        change_arg = self.ctx.args.change_record_name
        change_name = (
            change_arg.to_serialized_data()
            if has_value(change_arg)
            else "Change Definition"
        )

        return {
            'kind': CHANGE_DEFINITION_KIND_TARGETS,
            'name': change_name,
            'details': {
                'targets': targets
            }
        }

    @staticmethod
    def _parse_key_value_segment(segment):
        """Parse a single key=value segment and return (mapped_key, value)."""
        if '=' not in segment:
            raise InvalidArgumentValueError('Each --targets entry must be in key=value format.')
        key, value = segment.split('=', 1)
        key = key.strip()
        value = value.strip()
        if not key or not value:
            raise InvalidArgumentValueError('Each --targets entry must include a non-empty key and value.')
        normalized_key = key.lower()
        if normalized_key in TARGET_KEY_MAPPING:
            mapped_key = TARGET_KEY_MAPPING[normalized_key]
            if mapped_key == 'httpMethod' and value:
                value = value.upper()
            return mapped_key, value
        return key, value

    @staticmethod
    def _tokenize_target(token):
        """Split a target token into segments, handling both ; and , delimiters."""
        if token is None:
            return []
        segments = []
        for part in str(token).split(';'):
            segments.extend(segment.strip() for segment in part.split(',') if segment.strip())
        return segments

    @staticmethod
    def _parse_targets(raw_targets):
        if not raw_targets:
            raise InvalidArgumentValueError('--targets is required and must include key=value pairs.')
        parsed_targets = []
        for token in raw_targets:
            segments = ChangeRecordCreate._tokenize_target(token)
            if not segments:
                continue
            target_entry = {}
            for segment in segments:
                mapped_key, value = ChangeRecordCreate._parse_key_value_segment(segment)
                target_entry[mapped_key] = value
            if target_entry:
                parsed_targets.append(target_entry)
        if not parsed_targets:
            raise InvalidArgumentValueError('--targets must include at least one key=value pair.')
        return parsed_targets

    def _output(self, *args, **kwargs):
        result = super()._output(*args, **kwargs)
        _inject_targets_into_result(result, self._parsed_targets)
        return result

    class ChangeRecordsCreateOrUpdateAtSubscriptionLevel(
            _ChangeRecordCreate.ChangeRecordsCreateOrUpdateAtSubscriptionLevel):
        """Override PUT at subscription level to inject custom changeDefinition."""

        @property
        def content(self):
            content = super().content
            return _inject_change_definition_into_content(content, self.ctx)

    class ChangeRecordsCreateOrUpdate(
            _ChangeRecordCreate.ChangeRecordsCreateOrUpdate):
        """Override PUT at resource group level to inject custom changeDefinition."""

        @property
        def content(self):
            content = super().content
            return _inject_change_definition_into_content(content, self.ctx)


class ChangeRecordUpdate(_ChangeRecordUpdate):
    """Custom update command that preserves changeDefinition from GET response.

    The changeDefinition cannot be modified after creation due to API constraints.
    This class works around an AAZ framework limitation where the GET+PUT update
    pattern corrupts the free-form 'details' object (it becomes empty {}).

    Solution: We capture the raw changeDefinition from the GET HTTP response before
    the AAZ schema loses the details, then restore it in the PUT request content.
    """

    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        schema = super()._build_arguments_schema(*args, **kwargs)
        # Hide --change-definition since it cannot be updated after creation
        if hasattr(schema, "change_definition"):
            setattr(schema.change_definition, '_registered', False)  # pylint: disable=protected-access
        if not hasattr(schema, "stagemap_name"):
            schema.stagemap_name = AAZStrArg(  # type: ignore[attr-defined]
                options=["--stagemap-name", "--stage-map-name"],
                arg_group="Properties",
                help=(
                    "StageMap name in the current subscription scope. Automatically builds "
                    "the stage map resource ID."
                ),
            )
        return schema

    def pre_operations(self):
        super().pre_operations()
        _apply_stage_map_shortcut(self.ctx)

    class ChangeRecordsGetAtSubscriptionLevel(
            _ChangeRecordUpdate.ChangeRecordsGetAtSubscriptionLevel):
        """Override GET at subscription level to capture original changeDefinition."""

        def on_200(self, session):
            # Capture raw changeDefinition from HTTP response before schema loses details
            data = self.deserialize_http_content(session)
            if data and "properties" in data and "changeDefinition" in data["properties"]:
                # pylint: disable-next=protected-access
                self.ctx._original_change_definition = data["properties"]["changeDefinition"]
                logger.debug("Captured raw changeDefinition from GET response: %s",
                             self.ctx._original_change_definition)  # pylint: disable=protected-access
            return super().on_200(session)

    class ChangeRecordsGet(_ChangeRecordUpdate.ChangeRecordsGet):
        """Override GET at resource group level to capture original changeDefinition."""

        def on_200(self, session):
            # Capture raw changeDefinition from HTTP response before schema loses details
            data = self.deserialize_http_content(session)
            if data and "properties" in data and "changeDefinition" in data["properties"]:
                # pylint: disable-next=protected-access
                self.ctx._original_change_definition = data["properties"]["changeDefinition"]
                logger.debug("Captured raw changeDefinition from GET response: %s",
                             self.ctx._original_change_definition)  # pylint: disable=protected-access
            return super().on_200(session)

    class ChangeRecordsCreateOrUpdateAtSubscriptionLevel(
            _ChangeRecordUpdate.ChangeRecordsCreateOrUpdateAtSubscriptionLevel):
        """Override PUT at subscription level to preserve original changeDefinition."""

        @property
        def content(self):
            content = super().content
            # Preserve original changeDefinition - it cannot be updated
            return _preserve_change_definition_in_content(content, self.ctx)

    class ChangeRecordsCreateOrUpdate(
            _ChangeRecordUpdate.ChangeRecordsCreateOrUpdate):
        """Override PUT at resource group level to preserve original changeDefinition."""

        @property
        def content(self):
            content = super().content
            # Preserve original changeDefinition - it cannot be updated
            return _preserve_change_definition_in_content(content, self.ctx)


class ChangeRecordShow(_ChangeRecordShow):
    """Custom Show command with extended schema for details.targets."""

    class ChangeRecordsGetAtSubscriptionLevel(_ChangeRecordShow.ChangeRecordsGetAtSubscriptionLevel):
        """Override to use custom schema that includes targets array."""

        def on_200(self, session):
            data = self.deserialize_http_content(session)
            self.ctx.set_var(
                "instance",
                data,
                schema_builder=_build_custom_show_schema
            )

    class ChangeRecordsGet(_ChangeRecordShow.ChangeRecordsGet):
        """Override to use custom schema that includes targets array."""

        def on_200(self, session):
            data = self.deserialize_http_content(session)
            self.ctx.set_var(
                "instance",
                data,
                schema_builder=_build_custom_show_schema
            )


class ChangeRecordDelete(_ChangeRecordDelete):
    """Delete command - only customized for help examples."""


ChangeRecordCreate.AZ_HELP = {
    **ChangeRecordCreate.AZ_HELP,
    "examples": [
        {
            "name": "Create a ChangeRecord for deleting a Traffic Manager profile",
            "text": (
                "az changesafety changerecord create -g MyResourceGroup -n delete-trafficmanager "
                "--change-type ManualTouch --rollout-type Hotfix "
                "--targets \"resourceId=/subscriptions/00000000-0000-0000-0000-000000000000/"
                "resourceGroups/MyResourceGroup/providers/Microsoft.Network/"
                "trafficManagerProfiles/myProfile,operation=DELETE\" "
                "--description \"Delete Traffic Manager profile\""
            ),
        },
        {
            "name": "Create with StageMap reference and status link",
            "text": (
                "az changesafety changerecord create -g MyResourceGroup -n changerecord002 "
                "--change-type ManualTouch --rollout-type Normal "
                "--stage-map \"{resource-id:/subscriptions/00000000-0000-0000-0000-000000000000/"
                "resourceGroups/MyResourceGroup/providers/Microsoft.ChangeSafety/stageMaps/rolloutStageMap}\" "
                "--targets \"resourceId=/subscriptions/00000000-0000-0000-0000-000000000000/"
                "resourceGroups/MyResourceGroup/providers/Microsoft.Compute/virtualMachines/myVm,operation=PATCH\" "
                "--links \"[{name:status,uri:'https://contoso.com/change/rollout-002'}]\"\n"
            ),
        },
        {
            "name": "Create a ChangeRecord for a VM rollout",
            "text": (
                "az changesafety changerecord create -g MyResourceGroup -n changerecord001 "
                "--change-type AppDeployment --rollout-type Normal "
                "--targets \"resourceId=/subscriptions/00000000-0000-0000-0000-000000000000/"
                "resourceGroups/MyResourceGroup/providers/Microsoft.Compute/virtualMachines/myVm,operation=PUT\""
            ),
        },
        {
            "name": "Create with StageMap name and default schedule",
            "text": (
                "az changesafety changerecord create -g MyResourceGroup -n changerecord003 "
                "--change-type ManualTouch --rollout-type Normal --stagemap-name rolloutStageMap "
                "--targets \"resourceId=/subscriptions/00000000-0000-0000-0000-000000000000/"
                "resourceGroups/MyResourceGroup/providers/Microsoft.Compute/virtualMachines/myVm,operation=DELETE\""
            ),
        },
        {
            "name": "Create targeting an entire subscription (broad scope)",
            "text": (
                "az changesafety changerecord create -g MyResourceGroup -n subscription-wide-change "
                "--change-type ManualTouch --rollout-type Normal "
                "--targets \"subscriptionId=00000000-0000-0000-0000-000000000000,operation=PUT\""
            ),
        },
        {
            "name": "Create targeting a resource group (medium scope)",
            "text": (
                "az changesafety changerecord create -g MyResourceGroup -n rg-level-change "
                "--change-type ManualTouch --rollout-type Normal "
                "--targets \"subscriptionId=00000000-0000-0000-0000-000000000000,"
                "resourceGroupName=MyResourceGroup,operation=DELETE\""
            ),
        },
        {
            "name": "Create with multiple targets at different scopes",
            "text": (
                "az changesafety changerecord create -g MyResourceGroup -n multi-scope-change "
                "--change-type ManualTouch --rollout-type Normal "
                "--targets \"subscriptionId=00000000-0000-0000-0000-000000000000,operation=PUT\" "
                "--targets \"subscriptionId=00000000-0000-0000-0000-000000000000,"
                "resourceGroupName=MyResourceGroup,operation=DELETE\" "
                "--targets \"resourceId=/subscriptions/00000000-0000-0000-0000-000000000000/"
                "resourceGroups/MyResourceGroup/providers/Microsoft.Compute/"
                "virtualMachines/myVm,operation=PATCH\""
            ),
        },
    ],
}

ChangeRecordUpdate.AZ_HELP = {
    **ChangeRecordUpdate.AZ_HELP,
    "examples": [
        {
            "name": "Adjust rollout type and add a comment",
            "text": (
                "az changesafety changerecord update -g MyResourceGroup -n changerecord001 "
                "--rollout-type Emergency --comments \"Escalated to emergency rollout\""
            ),
        },
        {
            "name": "Update scheduling window",
            "text": (
                "az changesafety changerecord update -g MyResourceGroup -n changerecord001 "
                "--anticipated-start-time \"2024-09-01T08:00:00Z\" "
                "--anticipated-end-time \"2024-09-01T12:00:00Z\""
            ),
        },
        {
            "name": "Update description",
            "text": (
                "az changesafety changerecord update -g MyResourceGroup -n changerecord001 "
                "--description \"Updated rollout for production deployment\""
            ),
        },
    ],
}

ChangeRecordDelete.AZ_HELP = {
    **ChangeRecordDelete.AZ_HELP,
    "examples": [
        {
            "name": "Delete a ChangeRecord without confirmation",
            "text": "az changesafety changerecord delete -g MyResourceGroup -n changerecord001 --yes",
        },
    ],
}

ChangeRecordShow.AZ_HELP = {
    **ChangeRecordShow.AZ_HELP,
    "examples": [
        {
            "name": "Show a ChangeRecord",
            "text": "az changesafety changerecord show -g MyResourceGroup -n changerecord001",
        },
    ],
}


# -----------------------------------------------------------------------------
# StageMap Help Examples
# -----------------------------------------------------------------------------
# pylint: disable=wrong-import-position
from azext_changesafety.aaz.latest.changesafety.stagemap import (  # noqa: E402
    Create as _StageMapCreate,
    Show as _StageMapShow,
    Update as _StageMapUpdate,
    Delete as _StageMapDelete,
    List as _StageMapList,
)

_StageMapCreate.AZ_HELP = {
    **_StageMapCreate.AZ_HELP,
    "short-summary": "Create a StageMap resource.",
    "long-summary": (
        "A StageMap defines the stages through which a change progresses during rollout. "
        "Each stage has a name and sequence number. Stages are executed in order of their "
        "sequence values."
    ),
    "examples": [
        {
            "name": "Create a simple two-stage StageMap",
            "text": (
                "az changesafety stagemap create --subscription 00000000-0000-0000-0000-000000000000 "
                "--stage-map-name rolloutStageMap "
                "--stages \"[{name:Canary,sequence:1},{name:Production,sequence:2}]\""
            ),
        },
        {
            "name": "Create a StageMap with three regional stages",
            "text": (
                "az changesafety stagemap create --subscription 00000000-0000-0000-0000-000000000000 "
                "--stage-map-name regional-rollout "
                "--stages \"[{name:WestUS,sequence:1},{name:EastUS,sequence:2},{name:Global,sequence:3}]\""
            ),
        },
    ],
}

_StageMapShow.AZ_HELP = {
    **_StageMapShow.AZ_HELP,
    "short-summary": "Get details for a StageMap resource.",
    "examples": [
        {
            "name": "Show a StageMap",
            "text": (
                "az changesafety stagemap show --subscription 00000000-0000-0000-0000-000000000000 "
                "--stage-map-name rolloutStageMap"
            ),
        },
    ],
}

_StageMapUpdate.AZ_HELP = {
    **_StageMapUpdate.AZ_HELP,
    "short-summary": "Update an existing StageMap resource.",
    "long-summary": (
        "Modify the stages defined in a StageMap. When updating, provide the complete "
        "list of stages as the update replaces the existing stages array."
    ),
    "examples": [
        {
            "name": "Add a new stage to an existing StageMap",
            "text": (
                "az changesafety stagemap update --subscription 00000000-0000-0000-0000-000000000000 "
                "--stage-map-name rolloutStageMap "
                "--stages \"[{name:Canary,sequence:1},{name:Pilot,sequence:2},{name:Production,sequence:3}]\""
            ),
        },
    ],
}

_StageMapDelete.AZ_HELP = {
    **_StageMapDelete.AZ_HELP,
    "short-summary": "Delete a StageMap resource.",
    "long-summary": (
        "Delete a StageMap that is no longer needed. Note that StageMap resources "
        "that are currently referenced by active ChangeRecord resources cannot be deleted."
    ),
    "examples": [
        {
            "name": "Delete a StageMap",
            "text": (
                "az changesafety stagemap delete --subscription 00000000-0000-0000-0000-000000000000 "
                "--stage-map-name rolloutStageMap --yes"
            ),
        },
    ],
}

_StageMapList.AZ_HELP = {
    **_StageMapList.AZ_HELP,
    "short-summary": "List StageMap resources in a subscription.",
    "examples": [
        {
            "name": "List all StageMaps in the subscription",
            "text": "az changesafety stagemap list --subscription 00000000-0000-0000-0000-000000000000",
        },
    ],
}


# -----------------------------------------------------------------------------
# StageProgression Help Examples
# -----------------------------------------------------------------------------
# pylint: disable=wrong-import-position
from azext_changesafety.aaz.latest.changesafety.stageprogression import (  # noqa: E402
    Create as _StageProgressionCreate,
    Show as _StageProgressionShow,
    Update as _StageProgressionUpdate,
    Delete as _StageProgressionDelete,
    List as _StageProgressionList,
)

_StageProgressionCreate.AZ_HELP = {
    **_StageProgressionCreate.AZ_HELP,
    "short-summary": "Create a StageProgression to track stage progress.",
    "long-summary": (
        "A StageProgression records the execution status of a specific stage defined "
        "in a StageMap. Use this to track which stages have started, completed, or failed "
        "during a change rollout."
    ),
    "examples": [
        {
            "name": "Create a StageProgression for the Canary stage",
            "text": (
                "az changesafety stageprogression create "
                "--subscription 00000000-0000-0000-0000-000000000000 "
                "--change-record-name myChangeRecord "
                "-n canary-progression "
                "--stage-reference Canary "
                "--status InProgress"
            ),
        },
        {
            "name": "Create a StageProgression with comments",
            "text": (
                "az changesafety stageprogression create "
                "--subscription 00000000-0000-0000-0000-000000000000 "
                "--change-record-name myChangeRecord "
                "-n prod-stage "
                "--stage-reference Production "
                "--status InProgress "
                "--comments \"Starting production rollout\""
            ),
        },
    ],
}

_StageProgressionShow.AZ_HELP = {
    **_StageProgressionShow.AZ_HELP,
    "short-summary": "Get details for a StageProgression.",
    "examples": [
        {
            "name": "Show a StageProgression",
            "text": (
                "az changesafety stageprogression show "
                "--subscription 00000000-0000-0000-0000-000000000000 "
                "--change-record-name myChangeRecord "
                "-n canary-progression"
            ),
        },
    ],
}

_StageProgressionUpdate.AZ_HELP = {
    **_StageProgressionUpdate.AZ_HELP,
    "short-summary": "Update a StageProgression status or comments.",
    "long-summary": (
        "Update the status of a StageProgression to reflect the current state of "
        "the stage execution. Common status transitions are InProgress -> Completed "
        "or InProgress -> Failed."
    ),
    "examples": [
        {
            "name": "Mark a stage as completed",
            "text": (
                "az changesafety stageprogression update "
                "--subscription 00000000-0000-0000-0000-000000000000 "
                "--change-record-name myChangeRecord "
                "-n canary-progression "
                "--status Completed "
                "--comments \"Canary validation passed\""
            ),
        }
    ],
}

_StageProgressionDelete.AZ_HELP = {
    **_StageProgressionDelete.AZ_HELP,
    "short-summary": "Delete a StageProgression.",
    "examples": [
        {
            "name": "Delete a StageProgression",
            "text": (
                "az changesafety stageprogression delete "
                "--subscription 00000000-0000-0000-0000-000000000000 "
                "--change-record-name myChangeRecord "
                "-n canary-progression --yes"
            ),
        },
    ],
}

_StageProgressionList.AZ_HELP = {
    **_StageProgressionList.AZ_HELP,
    "short-summary": "List all StageProgressions for a ChangeRecord.",
    "examples": [
        {
            "name": "List StageProgressions for a ChangeRecord",
            "text": (
                "az changesafety stageprogression list "
                "--subscription 00000000-0000-0000-0000-000000000000 "
                "--change-record-name myChangeRecord"
            ),
        },
    ],
}
