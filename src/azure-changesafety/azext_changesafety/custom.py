# --------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
#
# Code generated by aaz-dev-tools
# --------------------------------------------------------------------------------------------

"""Custom command overrides for azure-changesafety CLI extension.

This module provides customizations for ChangeRecord CRUD operations:
- ChangeRecordCreate: Custom --targets parsing, --stagemap-name shortcut, schedule defaults
- ChangeRecordUpdate: Preserves changeDefinition during GET+PUT cycle (AAZ schema workaround)
- ChangeRecordShow: Custom schema to expose details.targets array
- ChangeRecordDelete: Help examples only
"""

import datetime
from argparse import SUPPRESS

from knack.log import get_logger
from azure.cli.core.aaz import (
    has_value,
    AAZAnyType,
    AAZAnyTypeArg,
    AAZListArg,
    AAZObjectArg,
    AAZStrArg,
    AAZObjectType,
    AAZStrType,
    AAZListType,
)
from azure.cli.core.aaz._arg_action import (  # pylint: disable=protected-access
    AAZArgActionOperations,
    AAZPromptInputOperation,
    _ELEMENT_APPEND_KEY,
)
from azure.cli.core.azclierror import InvalidArgumentValueError
from azext_changesafety.aaz.latest.changesafety.changerecord import (
    Create as _ChangeRecordCreate,
    Update as _ChangeRecordUpdate,
    Show as _ChangeRecordShow,
    Delete as _ChangeRecordDelete,
)
# Import for schema building - used by _build_custom_show_schema
from azext_changesafety.aaz.latest.changesafety.changerecord._show import (
    Show as _GeneratedShow,
)


logger = get_logger(__name__)

# -----------------------------------------------------------------------------
# Constants
# -----------------------------------------------------------------------------
CHANGE_DEFINITION_KIND_TARGETS = "Targets"
CHANGE_DEFINITION_KIND_API_OPERATIONS = "ApiOperations"

# Mapping of user-friendly key names to API field names for --targets parsing
TARGET_KEY_MAPPING = {
    'resourceid': 'resourceId',
    'subscriptionid': 'subscriptionId',
    'resourcegroupname': 'resourceGroupName',
    'resourcegroup': 'resourceGroupName',
    'rg': 'resourceGroupName',
    'resourcetype': 'resourceType',
    'resourcename': 'resourceName',
    'httpmethod': 'httpMethod',
    'method': 'httpMethod',
    'operation': 'httpMethod',
}


# -----------------------------------------------------------------------------
# Helper Functions
# -----------------------------------------------------------------------------

def _build_any_type():
    """Return an AAZAnyType instance for schema_builder callbacks.

    This is needed because schema_builder expects a callable that returns a schema type.
    Using a function instead of a lambda keeps linters happy.
    """
    return AAZAnyType()


def _apply_stage_map_shortcut(ctx):
    """Translate --stagemap-name into the stage_map resourceId payload.

    This shared helper allows users to specify just the StageMap name instead of
    the full resource ID. It builds the resource ID using the current subscription.

    Args:
        ctx: The AAZ command context containing args and subscription_id.

    Raises:
        InvalidArgumentValueError: If both --stage-map and --stagemap-name are provided,
            or if subscription_id is not available.
    """
    stage_map_arg = getattr(ctx.args, "stage_map", None)
    stage_map_name_arg = getattr(ctx.args, "stagemap_name", None)
    has_stage_map = has_value(stage_map_arg)
    has_stage_map_name = has_value(stage_map_name_arg)

    if has_stage_map and has_stage_map_name:
        raise InvalidArgumentValueError(
            "Use either --stage-map or --stagemap-name/--stage-map-name, not both."
        )

    if not has_stage_map_name:
        return

    subscription_id = getattr(ctx, "subscription_id", None)
    if not subscription_id:
        raise InvalidArgumentValueError(
            "A subscription is required to resolve the StageMap scope."
        )

    resource_id = (
        f"/subscriptions/{subscription_id}/providers/"
        f"Microsoft.ChangeSafety/stageMaps/{stage_map_name_arg.to_serialized_data()}"
    )
    logger.debug("Resolved StageMap resourceId from name: %s", resource_id)
    ctx.args.stage_map = {"resource_id": resource_id}


def _inject_change_definition_into_content(content, ctx):
    """Attach the computed changeDefinition payload to the serialized request content."""
    change_definition_value = getattr(ctx.vars, "change_definition", None)
    if change_definition_value is None:
        return content

    change_definition = change_definition_value.to_serialized_data()
    if not change_definition:
        return content

    if content is None:
        content = {}
    properties = content.setdefault("properties", {})
    properties["changeDefinition"] = change_definition
    return content


def _preserve_change_definition_in_content(content, ctx):
    """Preserve the original changeDefinition from GET response in the update request.

    The changeDefinition cannot be modified after creation, so we must preserve
    the original value from the GET response to avoid sending an empty/invalid
    changeDefinition in the PUT request.
    """
    if content is None:
        return content

    # Get the original changeDefinition captured from the raw GET response
    original_change_definition = getattr(ctx, "_original_change_definition", None)

    if original_change_definition is not None:
        properties = content.get("properties")
        if properties is not None:
            # Replace the corrupted changeDefinition with the original from the GET response
            properties["changeDefinition"] = original_change_definition
            logger.debug("Preserved original changeDefinition in update request")

    return content


def _normalize_targets_arg(raw_targets):
    """Return a list of raw target strings from the parsed CLI argument."""
    if raw_targets is None:
        return []

    if isinstance(raw_targets, AAZArgActionOperations):
        elements = []
        for keys, data in raw_targets._ops:
            logger.debug("Processing target op keys=%s data=%s", keys, data)
            if isinstance(data, AAZPromptInputOperation):
                data = data()

            normalized_value = ''
            if isinstance(data, (list, tuple)):
                normalized_value = ','.join(str(v) for v in data if v is not None)
            elif data is not None:
                normalized_value = str(data)

            idx = None
            key_name = None
            for key in keys:
                if key == _ELEMENT_APPEND_KEY:
                    idx = len(elements)
                elif isinstance(key, int):
                    idx = key
                elif isinstance(key, str):
                    key_name = key

            if idx is None:
                idx = len(elements) - 1 if elements else 0
            while len(elements) <= idx:
                elements.append('')

            if key_name:
                combined = f"{key_name}={normalized_value}" if normalized_value else key_name
                elements[idx] = f"{elements[idx]},{combined}" if elements[idx] else combined
            else:
                elements[idx] = normalized_value

        return [value for value in elements if value]

    if hasattr(raw_targets, 'to_serialized_data'):
        values = raw_targets.to_serialized_data()
    elif isinstance(raw_targets, list):
        values = raw_targets
    else:
        values = [raw_targets]

    normalized_values = []
    for value in values:
        if value is None:
            continue
        text = str(value).strip()
        if text:
            normalized_values.append(text)
    return normalized_values


def _inject_targets_into_result(data, targets):
    """Ensure changeDefinition.details.targets is present in the command output."""
    if not targets or data is None:
        return

    def process(item):
        if not isinstance(item, dict):
            return
        containers = []
        if isinstance(item.get('properties'), dict):
            containers.append(item['properties'])
        containers.append(item)
        for container in containers:
            change_def = container.get('changeDefinition')
            if isinstance(change_def, dict):
                details = change_def.setdefault('details', {})
                if isinstance(details, dict) and not details.get('targets'):
                    details['targets'] = targets

    if isinstance(data, list):
        for entry in data:
            process(entry)
    else:
        process(data)


def _build_custom_show_schema():
    """Build a custom schema for Show command that includes details.targets.

    The generated AAZ schema doesn't know about the free-form 'details' object
    structure, so we extend it to properly deserialize the targets array.

    Returns:
        AAZObjectType: The extended schema with targets array definition.
    """
    # Get the base schema from the generated code
    base_schema = _GeneratedShow.ChangeRecordsGet._build_schema_on_200()

    # Inject schema for details.targets - the generated code doesn't know this structure
    change_definition = base_schema.properties.change_definition
    details = change_definition.details
    details.targets = AAZListType(flags={"read_only": True})
    details.targets.Element = AAZObjectType()
    details.targets.Element.resourceId = AAZStrType()
    details.targets.Element.subscriptionId = AAZStrType()
    details.targets.Element.resourceGroupName = AAZStrType()
    details.targets.Element.resourceType = AAZStrType()
    details.targets.Element.resourceName = AAZStrType()
    details.targets.Element.httpMethod = AAZStrType()

    return base_schema


# -----------------------------------------------------------------------------
# Command Classes
# -----------------------------------------------------------------------------

class ChangeRecordCreate(_ChangeRecordCreate):
    """Custom Create command with --targets parsing and --stagemap-name shortcut."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._raw_targets = []
        self._parsed_targets = None

    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        schema = super()._build_arguments_schema(*args, **kwargs)
        if not hasattr(schema, "change_definition"):
            schema.change_definition = AAZAnyTypeArg(  # type: ignore[attr-defined]
                options=["--change-definition"],
                arg_group="Properties",
                help=SUPPRESS,
                nullable=True,
                blank={},
            )
        if not hasattr(schema, "stagemap_name"):
            schema.stagemap_name = AAZStrArg(  # type: ignore[attr-defined]
                options=["--stagemap-name", "--stage-map-name"],
                arg_group="Properties",
                help=(
                    "StageMap name in the current subscription scope. Automatically builds "
                    "the stage map resource ID."
                ),
            )
        if not hasattr(schema, "targets"):
            schema.targets = AAZListArg(
                options=["--targets"],
                help=(
                    "Target definitions expressed as key=value pairs separated by commas or semicolons. "
                    "Example: --targets \"resourceId=RESOURCE_ID,operation=delete\""
                ),
            )
            schema.targets.Element = AAZStrArg()
        return schema

    def _handler(self, command_args):
        # Extract targets before calling parent handler so we can accept flexible input formats.
        self._raw_targets = []
        self._parsed_targets = None
        command_args = dict(command_args) if command_args else {}
        raw_targets = command_args.pop('targets', None)
        if raw_targets is not None:
            self._raw_targets = _normalize_targets_arg(raw_targets)
        return super()._handler(command_args)

    def pre_operations(self):
        super().pre_operations()
        self._ensure_schedule_defaults()
        _apply_stage_map_shortcut(self.ctx)

        change_definition_arg = getattr(self.ctx.args, "change_definition", None)
        change_definition_value = None
        self._raw_targets = [t for t in (self._raw_targets or []) if t and str(t) != 'Undefined']
        if has_value(change_definition_arg):
            change_definition_value = self._parse_change_definition_arg(change_definition_arg)
            if self._raw_targets:
                raise InvalidArgumentValueError("Use either --change-definition or --targets, not both.")

        if change_definition_value is None and not self._raw_targets:
            raise InvalidArgumentValueError('--targets is required unless you provide --change-definition JSON.')

        # Build and set the changeDefinition with targets
        change_definition = change_definition_value or self._build_change_definition()
        logger.debug("Final changeDefinition for create: %s", change_definition)
        self.ctx.set_var(
            'change_definition',
            change_definition,
            schema_builder=_build_any_type,
        )

    def _ensure_schedule_defaults(self):
        """Populate anticipated start/end time defaults when the user omits them."""
        now = datetime.datetime.now(datetime.timezone.utc)
        start_arg = getattr(self.ctx.args, "anticipated_start_time", None)
        end_arg = getattr(self.ctx.args, "anticipated_end_time", None)
        start_dt = self._parse_datetime_value(start_arg) if has_value(start_arg) else None
        if start_dt is None:
            start_dt = now
            self.ctx.args.anticipated_start_time = self._to_iso8601(start_dt)
        if not has_value(end_arg):
            self.ctx.args.anticipated_end_time = self._to_iso8601(start_dt + datetime.timedelta(hours=8))

    @staticmethod
    def _to_iso8601(value):
        serialized = value.isoformat(timespec="seconds")
        return serialized.replace("+00:00", "Z")

    @staticmethod
    def _parse_datetime_value(value):
        text = None
        if value is None:
            return None
        if hasattr(value, "to_serialized_data"):
            text = value.to_serialized_data()
        elif isinstance(value, str):
            text = value
        if not text:
            return None
        try:
            return datetime.datetime.fromisoformat(str(text).replace("Z", "+00:00"))
        except ValueError:
            return None

    def _parse_change_definition_arg(self, change_definition_arg):
        data = change_definition_arg.to_serialized_data()
        if data is None:
            return None
        if not isinstance(data, dict):
            raise InvalidArgumentValueError("--change-definition must be valid JSON object.")
        return data

    def _build_change_definition(self):
        """Build the changeDefinition object with targets"""
        targets = self._parse_targets(self._raw_targets)
        self._parsed_targets = targets
        change_arg = self.ctx.args.change_record_name
        change_name = (
            change_arg.to_serialized_data()
            if has_value(change_arg)
            else "Change Definition"
        )

        return {
            'kind': CHANGE_DEFINITION_KIND_TARGETS,
            'name': change_name,
            'details': {
                'targets': targets
            }
        }

    @staticmethod
    def _parse_targets(raw_targets):
        if raw_targets is None:
            raise InvalidArgumentValueError('--targets is required and must include key=value pairs.')
        if not raw_targets:
            raise InvalidArgumentValueError('--targets is required and must include key=value pairs.')
        parsed_targets = []
        for token in raw_targets:
            if token is None:
                continue
            segments = []
            for part in str(token).split(';'):
                segments.extend(segment.strip() for segment in part.split(',') if segment.strip())
            if not segments:
                continue
            target_entry = {}
            for segment in segments:
                if '=' not in segment:
                    raise InvalidArgumentValueError('Each --targets entry must be in key=value format.')
                key, value = segment.split('=', 1)
                key = key.strip()
                value = value.strip()
                if not key or not value:
                    raise InvalidArgumentValueError('Each --targets entry must include a non-empty key and value.')
                normalized_key = key.lower()
                if normalized_key in TARGET_KEY_MAPPING:
                    mapped_key = TARGET_KEY_MAPPING[normalized_key]
                    if mapped_key == 'httpMethod' and value:
                        value = value.upper()
                    target_entry[mapped_key] = value
                else:
                    target_entry[key] = value
            if not target_entry:
                continue
            parsed_targets.append(target_entry)
        if not parsed_targets:
            raise InvalidArgumentValueError('--targets must include at least one key=value pair.')
        return parsed_targets

    def _output(self, *args, **kwargs):
        result = super()._output(*args, **kwargs)
        _inject_targets_into_result(result, self._parsed_targets)
        return result

    class ChangeRecordsCreateOrUpdateAtSubscriptionLevel(
            _ChangeRecordCreate.ChangeRecordsCreateOrUpdateAtSubscriptionLevel):
        @property
        def content(self):
            content = super().content
            return _inject_change_definition_into_content(content, self.ctx)

    class ChangeRecordsCreateOrUpdate(
            _ChangeRecordCreate.ChangeRecordsCreateOrUpdate):
        @property
        def content(self):
            content = super().content
            return _inject_change_definition_into_content(content, self.ctx)


class ChangeRecordUpdate(_ChangeRecordUpdate):
    """Custom update command that preserves changeDefinition from GET response.

    The changeDefinition cannot be modified after creation due to API constraints.
    This class works around an AAZ framework limitation where the GET+PUT update
    pattern corrupts the free-form 'details' object (it becomes empty {}).

    Solution: We capture the raw changeDefinition from the GET HTTP response before
    the AAZ schema loses the details, then restore it in the PUT request content.
    """

    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        schema = super()._build_arguments_schema(*args, **kwargs)
        # Hide --change-definition since it cannot be updated after creation
        if hasattr(schema, "change_definition"):
            setattr(schema.change_definition, '_registered', False)  # pylint: disable=protected-access
        if not hasattr(schema, "stagemap_name"):
            schema.stagemap_name = AAZStrArg(  # type: ignore[attr-defined]
                options=["--stagemap-name", "--stage-map-name"],
                arg_group="Properties",
                help=(
                    "StageMap name in the current subscription scope. Automatically builds "
                    "the stage map resource ID."
                ),
            )
        return schema

    def pre_operations(self):
        super().pre_operations()
        _apply_stage_map_shortcut(self.ctx)

    class ChangeRecordsGetAtSubscriptionLevel(
            _ChangeRecordUpdate.ChangeRecordsGetAtSubscriptionLevel):
        def on_200(self, session):
            # Capture raw changeDefinition from HTTP response before schema loses details
            data = self.deserialize_http_content(session)
            if data and "properties" in data and "changeDefinition" in data["properties"]:
                self.ctx._original_change_definition = data["properties"]["changeDefinition"]
                logger.debug("Captured raw changeDefinition from GET response: %s", 
                           self.ctx._original_change_definition)
            return super().on_200(session)

    class ChangeRecordsGet(_ChangeRecordUpdate.ChangeRecordsGet):
        def on_200(self, session):
            # Capture raw changeDefinition from HTTP response before schema loses details
            data = self.deserialize_http_content(session)
            if data and "properties" in data and "changeDefinition" in data["properties"]:
                self.ctx._original_change_definition = data["properties"]["changeDefinition"]
                logger.debug("Captured raw changeDefinition from GET response: %s", 
                           self.ctx._original_change_definition)
            return super().on_200(session)

    class ChangeRecordsCreateOrUpdateAtSubscriptionLevel(
            _ChangeRecordUpdate.ChangeRecordsCreateOrUpdateAtSubscriptionLevel):
        @property
        def content(self):
            content = super().content
            # Preserve original changeDefinition - it cannot be updated
            return _preserve_change_definition_in_content(content, self.ctx)

    class ChangeRecordsCreateOrUpdate(
            _ChangeRecordUpdate.ChangeRecordsCreateOrUpdate):
        @property
        def content(self):
            content = super().content
            # Preserve original changeDefinition - it cannot be updated
            return _preserve_change_definition_in_content(content, self.ctx)


class ChangeRecordShow(_ChangeRecordShow):
    """Custom Show command with extended schema for details.targets."""

    class ChangeRecordsGetAtSubscriptionLevel(_ChangeRecordShow.ChangeRecordsGetAtSubscriptionLevel):
        """Override to use custom schema that includes targets array."""

        def on_200(self, session):
            data = self.deserialize_http_content(session)
            self.ctx.set_var(
                "instance",
                data,
                schema_builder=_build_custom_show_schema
            )

    class ChangeRecordsGet(_ChangeRecordShow.ChangeRecordsGet):
        """Override to use custom schema that includes targets array."""

        def on_200(self, session):
            data = self.deserialize_http_content(session)
            self.ctx.set_var(
                "instance",
                data,
                schema_builder=_build_custom_show_schema
            )


class ChangeRecordDelete(_ChangeRecordDelete):
    """Delete command - only customized for help examples."""


ChangeRecordCreate.AZ_HELP = {
    **ChangeRecordCreate.AZ_HELP,
    "examples": [
        {
            "name": "Create with StageMap reference and status link",
            "text": (
                "az changesafety changerecord create -g MyResourceGroup -n changerecord002 "
                "--change-type ManualTouch --rollout-type Normal "
                "--stage-map \"{resource-id:/subscriptions/00000000-0000-0000-0000-000000000000/"
                "resourceGroups/MyResourceGroup/providers/Microsoft.ChangeSafety/stageMaps/rolloutStageMap}\" "
                "--targets \"resourceId=/subscriptions/00000000-0000-0000-0000-000000000000/"
                "resourceGroups/MyResourceGroup/providers/Microsoft.Compute/virtualMachines/myVm,operation=PATCH\" "
                "--links \"[{name:status,uri:'https://contoso.com/change/rollout-002'}]\"\n"
                "az changesafety changerecord delete -g MyResourceGroup -n changerecord002 --yes"
            ),
        },
        {
            "name": "Create a ChangeRecord for a VM rollout",
            "text": (
                "az changesafety changerecord create -g MyResourceGroup -n changerecord001 "
                "--change-type AppDeployment --rollout-type Normal "
                "--targets \"resourceId=/subscriptions/00000000-0000-0000-0000-000000000000/"
                "resourceGroups/MyResourceGroup/providers/Microsoft.Compute/virtualMachines/myVm,operation=PUT\""
            ),
        },
        {
            "name": "Create a ChangeRecord for deleting a Traffic Manager profile",
            "text": (
                "az changesafety changerecord create -g MyResourceGroup -n delete-trafficmanager "
                "--change-type ManualTouch --rollout-type Hotfix "
                "--targets \"resourceId=/subscriptions/00000000-0000-0000-0000-000000000000/"
                "resourceGroups/MyResourceGroup/providers/Microsoft.Network/trafficManagerProfiles/myProfile,operation=DELETE\" "
                "--description \"Delete Traffic Manager profile\""
            ),
        },
        {
            "name": "Create with StageMap name and default schedule",
            "text": (
                "az changesafety changerecord create -g MyResourceGroup -n changerecord003 "
                "--change-type ManualTouch --rollout-type Normal --stagemap-name rolloutStageMap "
                "--targets \"resourceId=/subscriptions/00000000-0000-0000-0000-000000000000/"
                "resourceGroups/MyResourceGroup/providers/Microsoft.Compute/virtualMachines/myVm,operation=DELETE\""
            ),
        },
    ],
}

ChangeRecordUpdate.AZ_HELP = {
    **ChangeRecordUpdate.AZ_HELP,
    "examples": [
        {
            "name": "Adjust rollout type and add a comment",
            "text": (
                "az changesafety changerecord update -g MyResourceGroup -n changerecord001 "
                "--rollout-type Emergency --comments \"Escalated to emergency rollout\""
            ),
        },
        {
            "name": "Update scheduling window",
            "text": (
                "az changesafety changerecord update -g MyResourceGroup -n changerecord001 "
                "--anticipated-start-time \"2024-09-01T08:00:00Z\" "
                "--anticipated-end-time \"2024-09-01T12:00:00Z\""
            ),
        },
        {
            "name": "Update description",
            "text": (
                "az changesafety changerecord update -g MyResourceGroup -n changerecord001 "
                "--description \"Updated rollout for production deployment\""
            ),
        },
    ],
}

ChangeRecordDelete.AZ_HELP = {
    **ChangeRecordDelete.AZ_HELP,
    "examples": [
        {
            "name": "Delete a ChangeRecord without confirmation",
            "text": "az changesafety changerecord delete -g MyResourceGroup -n changerecord001 --yes",
        },
    ],
}

ChangeRecordShow.AZ_HELP = {
    **ChangeRecordShow.AZ_HELP,
    "examples": [
        {
            "name": "Show a ChangeRecord",
            "text": "az changesafety changerecord show -g MyResourceGroup -n changerecord001",
        },
    ],
}
