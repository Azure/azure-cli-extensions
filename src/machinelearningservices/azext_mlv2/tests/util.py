# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------

import base64
import json
import os
import re
import secrets
from contextlib import contextmanager
from itertools import product
from typing import Dict, List, Tuple, Union, overload
from urllib.parse import urlparse

from azure.ai.ml._artifacts._constants import ARTIFACT_ORIGIN, LEGACY_ARTIFACT_DIRECTORY
from azure.ai.ml.constants._common import ANONYMOUS_COMPONENT_NAME, AZUREML_PRIVATE_FEATURES_ENV_VAR
from azure.cli.testsdk.scenario_tests import RecordingProcessor
from azure.cli.testsdk.scenario_tests.const import MOCKED_SUBSCRIPTION_ID
from azure.cli.testsdk.scenario_tests.utilities import is_text_payload

from ._vcr_constants import MockReplacers


def _create_replacements_dictionary():
    """Create a replacement dictionary."""
    replacements = {}
    replacements[r"datasets/.+/versions"] = "datasets/{}/versions".format(MockReplacers.MOCKED_DATASETS_NAME)
    replacements[r'/resourceGroups/[^/,?"]+'] = "/resourceGroups/{}".format(MockReplacers.MOCKED_RESOURCE_GROUP_NAME)
    replacements[r'/resourcegroups/[^/,?"]+'] = "/resourcegroups/{}".format(MockReplacers.MOCKED_RESOURCE_GROUP_NAME)
    replacements[r"/operationStatuses/[^/,?]+"] = "/operationStatuses/{}".format(
        MockReplacers.MOCKED_OPERATION_STATUSES_NAME
    )
    replacements[r"/computeOperationsStatus/[^/,?]+"] = "/computeOperationsStatus/{}".format(
        MockReplacers.MOCKED_OPERATION_STATUSES_NAME
    )
    replacements[r"/deployments/[^/,?]+"] = "/deployments/{}".format(MockReplacers.MOCKED_DEPLOYMENTS_NAME)
    replacements[r"/workspaces/[^/]+"] = "/workspaces/{}".format(MockReplacers.MOCKED_WORKSPACES_NAME)
    replacements[r"data/.+/versions"] = "data/{}/versions".format(MockReplacers.MOCKED_DATA_NAME)
    replacements[r"environments/.+[^'CliV2AnonymousEnvironment']/versions"] = "environments/{}/versions".format(
        MockReplacers.MOCKED_ENVIRONMENTS_NAME
    )
    replacements[r"/CliV2AnonymousEnvironment/versions/[^/]+"] = "/CliV2AnonymousEnvironment/versions/{}".format(
        MockReplacers.MOCKED_ANONYMOUS_ENVIRONMENTS_NAME
    )
    # For anonymous components, the component name is fixed while its version is generated by a hash function
    # Add specific replacement here to handle the change of hash function & fit original anonymous component format
    replacements[r"components/" + ANONYMOUS_COMPONENT_NAME + r"/versions/[^/,?]+"] = "components/{}/versions/1".format(
        MockReplacers.MOCKED_COMPONENTS_NAME
    )
    replacements[r"components/.+/versions"] = "components/{}/versions".format(MockReplacers.MOCKED_COMPONENTS_NAME)
    replacements[r"/codes/[^/]+"] = "/codes/{}".format(MockReplacers.MOCKED_CODES_NAME)
    replacements[r"/codes/.+/versions"] = "/codes/{}".format(MockReplacers.MOCKED_CODES_NAME)
    replacements[r"/models/[^/]+"] = "/models/{}".format(MockReplacers.MOCKED_MODELS_NAME)
    replacements[r"components/[^/]+"] = "components/{}".format(MockReplacers.MOCKED_COMPONENTS_NAME)
    replacements[r"az-ml-artifacts"] = "{}".format(MockReplacers.MOCKED_AZ_ML_ARTIFACTS_NAME)
    return replacements


# Pop a key from a dictionary, supporting constructions such as: key.subkey
def _pop_deep_key(obj: Dict, key: str):
    keys = key.split(".", 1)
    if keys[0] in obj:
        # If not nested key, remove the key at the current level
        if len(keys) == 1:
            obj.pop(keys[0])
        # Else, a nested key, remove from one level down
        else:
            _pop_deep_key(obj[keys[0]], key=keys[1])


def _remove_filtered_fields(*yaml_objs: Dict, filter: List[str] = None):
    filter = filter or []
    for yaml_obj, filter_val in product(yaml_objs, filter):
        _pop_deep_key(yaml_obj, key=filter_val)


def assert_same(*yaml_objs: Dict, filter: List[str] = None):
    filter = filter or []
    if len(yaml_objs) < 2:
        raise ValueError("the length of yaml object to compare should be at least 2")

    _remove_filtered_fields(*yaml_objs, filter=filter)
    base_to_compare = yaml_objs[0]
    for obj in yaml_objs[1:]:
        assert obj == base_to_compare


def _get_content_type(entity):
    # 'headers' is a field of 'request', but it is a dict-key in 'response'
    headers = getattr(entity, "headers", None)
    if headers is None:
        headers = entity.get("headers")

    content_type = None
    if headers:
        content_type = headers.get("content-type", None)
        if content_type:
            # content-type could an array from response, let us extract it out
            content_type = content_type[0] if isinstance(content_type, list) else content_type
            content_type = content_type.split(";")[0].lower()
    return content_type


def is_text_payload(entity):
    text_content_list = ["application/json", "application/xml", "text/", "application/test-content"]

    content_type = _get_content_type(entity)
    if content_type:
        return any(content_type.startswith(x) for x in text_content_list)
    return True


def generate_token() -> str:
    """Generate a base64-encoded key to use for access token."""
    return base64.b64encode(secrets.token_bytes(16)).decode(encoding="UTF-8")


class PathsReplacer(RecordingProcessor):
    def __init__(self, regexstr_replacement: Dict[str, str]) -> None:
        self.regexstr_replacement = regexstr_replacement

    def process_request(self, request):
        try:
            u = urlparse(request.uri)
            path = u.path

            for regexstr in self.regexstr_replacement:
                regex = re.compile(regexstr)

                if regex.search(path):
                    replacement = self.regexstr_replacement[regexstr]
                    path = regex.sub(replacement, path)

            u = u._replace(path=path)

            request.uri = u.geturl()
            return request
        except Exception:
            return request


class ResponseReplacer(RecordingProcessor):
    def __init__(self, regexstr_replacement: Dict[str, str]) -> None:
        self.regexstr_replacement = regexstr_replacement

    def process_response(self, response):  # pylint: disable=no-self-use
        @overload
        def as_text_or_binary(response: bytes, regex: str, replacement: str) -> Tuple[bytes, re.Pattern, bytes]:
            ...

        @overload
        def as_text_or_binary(response: str, regex: str, replacement: str) -> Tuple[str, re.Pattern, str]:
            ...

        def as_text_or_binary(
            response: Union[bytes, str], regex: str, replacement: str
        ) -> Union[Tuple[bytes, re.Pattern, bytes], Tuple[str, re.Pattern, str]]:
            if isinstance(response, bytes):
                return (response, re.compile(regex.encode("utf-8")), replacement.encode("utf-8"))
            return (response, re.compile(regex), replacement)

        if is_text_payload(response) and response["body"]["string"]:
            for regex_string in self.regexstr_replacement:
                response_body, regex, replacement = as_text_or_binary(
                    response["body"]["string"], regex_string, self.regexstr_replacement[regex_string]
                )

                if regex.search(response_body):
                    response_body = regex.sub(replacement, response_body)
            response["body"]["string"] = response_body
        return response


class MiscResponseReplacer(ResponseReplacer):
    def __init__(self) -> None:
        replacements = {}
        replacements[r'/resourceGroups/[^/,?"]+'] = "/resourceGroups/000000000000000"
        super().__init__(replacements)


class ResourcePathsReplacer(PathsReplacer):
    # Add here all resource paths and their ids to ignore
    def __init__(self) -> None:
        replacements = _create_replacements_dictionary()
        super().__init__(replacements)


class QueryStringParReplacer(RecordingProcessor):
    def __init__(self, parameter_name: str, replacement: str) -> None:
        self.parameter_name = parameter_name
        self.replacement = replacement

    def process_request(self, request):  # pylint: disable=no-self-use
        try:
            u = urlparse(request.uri)
            assert self.parameter_name in u.query
            u = u._replace(
                query=re.sub(self.parameter_name + r"=[^&]+", f"{self.parameter_name}={self.replacement}", u.query)
            )
            request.uri = u.geturl()
            return request
        except Exception:
            return request


class APIVersionReplacer(QueryStringParReplacer):
    def __init__(self) -> None:
        super().__init__("api-version", MockReplacers.MOCKED_API_VERSION)


class SkipTokenReplacer(QueryStringParReplacer):
    def __init__(self) -> None:
        super().__init__("skipToken", MockReplacers.MOCKED_SKIP_TOKEN)


class HeaderRemover(RecordingProcessor):
    def __init__(self, header: str) -> None:
        self.header = header

    def process_request(self, request):  # pylint: disable=no-self-use
        try:
            request.headers.pop(self.header, None)
            return request
        except Exception:
            return request

    def process_response(self, response):  # pylint: disable=no-self-use
        try:
            response["headers"].pop(self.header, None)
            return response
        except Exception:
            return response


class MD5HeaderRemover(HeaderRemover):
    def __init__(self) -> None:
        super().__init__("content-md5")


class UserAgentRemover(HeaderRemover):
    def __init__(self) -> None:
        super().__init__("user-agent")


class AzureBlobReplacer(RecordingProcessor):
    """
    Replace https://storagea5jlura67u2una.blob.core.windows.net/azureml-blobstore-09911d39-adba-4943-950e-1c1540bf2711/LocalUpload/7e05d06d-2462-446d-a683-61aa383be019/python/sample1.csv
    to https://xxxxxxxxxxxxxxxxxxxxxx.blob.core.windows.net/azureml-blobstore-00000000-0000-0000-0000-000000000000/LocalUpload/00000000-0000-0000-0000-00000000000/python/sample1.csv
    """

    def process_request(self, request):  # pylint: disable=no-self-use
        try:
            u = urlparse(request.uri)
            _, *rest = u.netloc.split(".")
            assert ".".join(rest) == "blob.core.windows.net"
            empty, _, container, _, *path = u.path.split("/")
            if container in [ARTIFACT_ORIGIN, LEGACY_ARTIFACT_DIRECTORY]:
                container = MockReplacers.MOCKED_CONTAINER_NAME
            u = u._replace(netloc="xxxxxxxxxxxxxxxxxxxxxx." + ".".join(rest))
            u = u._replace(
                path="/".join(
                    [
                        empty,
                        "azureml-blobstore-00000000-0000-0000-0000-000000000000",
                        container,
                        "00000000-0000-0000-0000-00000000000",
                    ]
                    + path
                )
            )
            if u.query:
                u = u._replace(query=MockReplacers.MOCKED_SAS_TOKEN)
            request.uri = u.geturl()
            return request
        except Exception as e:
            return request


class RegistryDiscoveryReplacer(RecordingProcessor):
    """Replaces values returned by registrymanagement discovery to use mocked values"""

    REGISTRY_DISCOVERY_ENDPOINT_RE = re.compile("^/registrymanagement/v1.0/registries/[^/]+/discovery$")

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.__should_process_next_response = False

    def process_request(self, request):
        u = urlparse(request.uri)
        self.__should_process_next_response = bool(self.REGISTRY_DISCOVERY_ENDPOINT_RE.match(u.path))

        return request

    def process_response(self, response):
        if not self.__should_process_next_response:
            return response

        if not (is_text_payload(response) and response["body"]["string"]):
            return response

        response_body = json.loads(response["body"]["string"])

        # Replace the subscriptionId so that requests can match
        response_body["subscriptionId"] = MOCKED_SUBSCRIPTION_ID

        response["body"]["string"] = json.dumps(response_body)
        return response


class HostNormalizer(RecordingProcessor):
    def process_request(self, request):
        try:
            u = urlparse(request.uri)
            _, *rest = u.netloc.split(".")
            rest_joined = ".".join(rest)
            assert rest_joined == "management.azure.com"
            u = u._replace(netloc=rest_joined)
            request.uri = u.geturl()
            return request
        except Exception:
            return request


class AzureBlobJobLogReplacer(RecordingProcessor):
    """
    Replace https://saksuentvqrx4zu.blob.core.windows.net/azureml?prefix=ExperimentRun%2Fdcid.test-job-000001%2Fuser_logs%2F&restype=container&comp=list
    to https://xxxxxxxxxxxxxxxxxxxxxx.blob.core.windows.net/0000000000000?prefix=0000000000000000%2F&restype=container&comp=list
    """

    def process_request(self, request):  # pylint: disable=no-self-use
        try:
            u = urlparse(request.uri)
            _, *rest = u.netloc.split(".")
            assert ".".join(rest) == "blob.core.windows.net"
            u = u._replace(netloc="xxxxxxxxxxxxxxxxxxxxxx." + ".".join(rest))
            query = u.query.split(r"%2F&")
            u = u._replace(query="prefix=000000000000000" + r"%2F&" + query[1])
            request.uri = u.geturl()
            return request
        except Exception:
            return request


def IsValidGuid(str):
    regex = "^[{]?[0-9a-fA-F]{8}" + "-([0-9a-fA-F]{4}-)" + "{3}[0-9a-fA-F]{12}[}]?$"

    p = re.compile(regex)

    if str == None:
        return False

    if re.search(p, str):
        return True
    else:
        return False


@contextmanager
def private_flag():
    private_flag = None
    if AZUREML_PRIVATE_FEATURES_ENV_VAR in os.environ:
        private_flag = os.environ[AZUREML_PRIVATE_FEATURES_ENV_VAR]

    try:
        # Modify the operation
        os.environ[AZUREML_PRIVATE_FEATURES_ENV_VAR] = "true"
        yield
    finally:
        # Undo the modification
        if private_flag:
            os.environ[AZUREML_PRIVATE_FEATURES_ENV_VAR] = private_flag
        else:
            os.environ.pop(AZUREML_PRIVATE_FEATURES_ENV_VAR)


class HashResponseBodyReplacer(ResponseReplacer):
    def __init__(self) -> None:
        super().__init__(regexstr_replacement={r'&hash=[^/,?"]+': f"&hash={MockReplacers.MOCKED_HASH}"})


class HashQueryParamReplacer(QueryStringParReplacer):
    def __init__(self) -> None:
        super().__init__("hash", MockReplacers.MOCKED_HASH)
