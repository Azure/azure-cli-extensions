# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------
import time
from typing import Any

from azure.cli.testsdk import ScenarioTest
from azure.cli.testsdk.scenario_tests.const import MOCKED_SUBSCRIPTION_ID
from azure.cli.testsdk.scenario_tests.recording_processors import ContentLengthProcessor

from ._vcr_constants import MockReplacers
from .recording_processors import RecordingRedactor
from .util import (
    APIVersionReplacer,
    AzureBlobJobLogReplacer,
    AzureBlobReplacer,
    HashQueryParamReplacer,
    HashResponseBodyReplacer,
    HostNormalizer,
    MD5HeaderRemover,
    MiscResponseReplacer,
    RegistryDiscoveryReplacer,
    ResourcePathsReplacer,
    SkipTokenReplacer,
    generate_token,
)


class MLBaseScenarioTest(ScenarioTest):
    def __init__(self, method_name: Any) -> None:
        super().__init__(
            method_name,
            recording_processors=[
                # After replacing body content with processors like GeneralNameReplacer and SingleValueReplacer
                # Content-Length header will not match the actual length of body.
                # We should re-compute Content-Length header with the new body.
                ContentLengthProcessor(),
                MD5HeaderRemover(),
                AzureBlobReplacer(),
                ResourcePathsReplacer(),
                MiscResponseReplacer(),
                APIVersionReplacer(),
                SkipTokenReplacer(),
                AzureBlobJobLogReplacer(),
                RegistryDiscoveryReplacer(),
                HostNormalizer(),
                RecordingRedactor(
                    keys=MockReplacers.CONSTANTS_TO_SCRUB_IN_BODY, replacement=MockReplacers.MOCKED_REPLACEMENT_VALUE
                ),
                HashResponseBodyReplacer(),
                HashQueryParamReplacer(),
            ],
            replay_processors=[
                MD5HeaderRemover(),
                AzureBlobReplacer(),
                ResourcePathsReplacer(),
                MiscResponseReplacer(),
                APIVersionReplacer(),
                SkipTokenReplacer(),
                AzureBlobJobLogReplacer(),
                HostNormalizer(),
                HashResponseBodyReplacer(),
                HashQueryParamReplacer(),
            ],
        )
        self.kwargs.update(
            {
                "subscription": self.get_subscription_id(),
                "modelName2": self.create_random_name(prefix="test-model2-", length=24),
                "onlineManagedDeploymentName": self.create_random_name(prefix="test-onl-mgr-dep-", length=24),
                "onlineManagedDeploymentName2": self.create_random_name(prefix="test-onl-mgr-dep-", length=24),
                # Using static endpoint to avoid endpoint creation for each deployment test
                # Update the name here if changing it during cassette recording
                "endpointForDeploymentTest": "march-1",
                "batchEndpointName": "test-batch-ept-1223423",
                "batchEndpointNameAllCaps": "TEST-BATCH-EPT-1223423",
                "datastorePath": "azureml://datastores/workspaceblobstore/paths/LocalUpload/d6682949913d69b83b1502194b114c21/",
                "jobPath": "azureml://jobs/84bfa115-ad18-4aa7-8815-c991d7b7afdf/outputs/artifacts/paths/model/",
                "mlflowPath": "runs:/84bfa115-ad18-4aa7-8815-c991d7b7afdf/model/",
                "encoded_account_key": generate_token(),
                "encoded_account_key_to_update": generate_token(),
                "kerberos_principal": generate_token(),
                "commandJobName": "test-cjob-000011",
                "sweepJobName": "test-sjob-000012",
                "pipelineJobName": "test-pjob-000021",
                "scheduleName": "test-schedule-000001",
                "automlRegressionJobName": "test-amlregjob-000015",
                "automlClassificationJobName": "test-amlclijob-000016",
                "automlForecastingJobName": "test-amlforjob-000016",
                "automlImageClassificationJobName": "test-amlforimgclassificationjob-000021",
                "automlImageClassificationMultilabelJobName": "test-amlforimageclsmltlabeljob-000022",
                "automlImageInstanceSegmentationJobName": "test-amlforimginstancesegjob-000023",
                "automlImageObjectDetectionJobName": "test-amlforimageobjdetectjob-000024",
                "automlImageClassificationAutoModeJobName": "test-amlforimgclassificationjob-000025",
                "automlImageClassificationMultilabelAutoModeJobName": "test-amlforimageclsmltlabeljob-000026",
                "automlImageInstanceSegmentationAutoModeJobName": "test-amlforimginstancesegjob-000027",
                "automlImageObjectDetectionAutoModeJobName": "test-amlforimageobjdetectjob-000028",
                "automlTextClassificationJobName": "test-amltextclsjob-000018",
                "automlTextMultilabelJobName": "test-amltextmuljob-000019",
                "automlTextNERJobName": "test-amltextnerjob-000020",
                "componentName": "test_component_000012",
                "computeName": "testcomp007",
                "dataV2Name": "test-data-000022",
                "datasetName": "test-dataset-000002",
                # start datastores
                "blobDatastoreName": "testblobds000008",
                "hdfsKeyTabDatastoreName": "testhdfsds000009",
                "hdfsPwDatastoreName": "testhdfsds000010",
                "fileDatastoreName": "testfileds000011",
                "blobCredlessDatastoreName": "testblobds000012",
                "adlsgen1CredlessDatastoreName": "testadlsgen1000013",
                "adlsgen2CredlessDatastoreName": "testadlsgen2000014",
                "adlsgen1DatastoreName": "testadlsgen1000015",
                "adlsgen2DatastoreName": "testadlsgen2000016",
                # end datastores
                "environmentName": "test-environment-000004",
                "modelName": "test-model-000003",
                "connectionName": "test-ws-conn000018",
                "batchDeploymentName": "test-batch-dep-000017",
                "onlineEndpointName": "test-onl-endpt-000005",
                "onlineEndpointNameBackup": "test-onl-endpt-000009",
                # use testOnlineEndpointName when creating/editing
                # cli tests with online endpoint and deployment
                # so that you don't expire the endpoint/deployment names used by
                # other tests if you test gets stuck halfway through
                "testOnlineEndpointName": "test-endpt-00005",
                "workspaceName": "test-ws-000006",
                "onlineDeploymentName": "test-onl-mgr-dep-000011",
                "onlineManagedDeploymentName2": "test-onl-mgr-dep-000012",
            }
        )

        self.addCleanup(prevent_cassette_from_leaking_across_tests)

    def tearDown(self):
        # os.environ = self.original_env
        # # Autorest.Python 2.x
        # assert not [t for t in threading.enumerate() if t.name.startswith("AzureOperationPoller")], \
        #     "You need to call 'result' or 'wait' on all AzureOperationPoller you have created"
        # # Autorest.Python 3.x
        # assert not [t for t in threading.enumerate() if t.name.startswith("LROPoller")], \
        #     "You need to call 'result' or 'wait' on all LROPoller you have created"
        """
        We don't want Azure CLI's teardown to check that LROPoller threads terminate.
        """


def prevent_cassette_from_leaking_across_tests() -> None:
    """Prevent VCRpy from using a cassette for the wrong test in rare cases.

    .. warning::

       THIS IS A HACK

    .. note::

        We observed that, rarely (~3 tests out of 120), some tests would fail because
        there was no matching request in the recording. Curiously, the test was
        trying to match against requests that weren't present in the recording
        file for the executing test.

        Neither the number nor the exact failing tests were consistent. Re-running pytest
        could make the number change, and shuffling the order of tests would change which
        tests fail. But the failing tests were often tests that ran after an `(archive|restore)_in_registry`
        test (e.g. `test_model_restore_in_registry`, `test_environment_archive_in_registry`,
        `test_component_restore_registry`), and it would fail because the test was matching
        against the registry test cassette.

        When a test fails, the azure-cli-testsdk was setting the **correct** cassette to use for the
        test. But vcrpy's patches to urllib3 that it uses to intercept network traffic were still referring
        to the wrong cassette.

        A search through the issues for the vcrpy project pulled up an issue that seemed
        to have similar symptoms: a cassette leaking across tests causing test failures.

    .. see-also::

        https://github.com/kevin1024/vcrpy/issues/327
    """

    # The linked GitHub issue suggests that there is a possible race condition
    # that only occurs if a test starts soon after a preceding one.
    #
    # A hacky solution would be to just delay the next test for some amount of time.
    time.sleep(0.05)
