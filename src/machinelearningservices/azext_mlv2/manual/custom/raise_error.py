# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------
import json
import traceback

from azure.ai.ml._exception_helper import format_create_validation_error
from azure.ai.ml.constants._common import LIMITED_RESULTSET_WARNING_FORMAT
from azure.ai.ml.exceptions import ValidationErrorType, ValidationException
from azure.cli.core import azclierror
from azure.cli.core.style import Style, print_styled_text
from azure.common import AzureException
from azure.core.exceptions import AzureError, HttpResponseError, ODataV4Format
from colorama import init
from jmespath.exceptions import JMESPathError
from knack.cli import CLIError
from knack.log import get_logger
from marshmallow.exceptions import ValidationError as SchemaValidationError
from msrest.exceptions import ClientRequestError, HttpOperationError, ValidationError
from requests.exceptions import HTTPError, SSLError

module_logger = get_logger()

init()


def print_styled_text_with_level(level, text):
    if not isinstance(text, str):
        text = str(text)
    print_styled_text(
        [
            (
                level,
                text,
            )
        ]
    )


def _extract_error_from_details(error_details):
    """
    Converts error message to ARMErrorFormat (if possible)
    and builds error message from it. Otherwise raise exception
    by using message for error passed.
    """
    if isinstance(error_details, str):
        return error_details
    try:
        if hasattr(error_details, "message"):
            json_error = json.loads(error_details.message)
        else:
            json_error = json.loads(error_details)
        formatted_error = ODataV4Format(json_object=json_error)
        return formatted_error.message_details()
    except Exception:  # pylint: disable=broad-exception-caught
        module_logger.debug("Error parsing details of deployment failed error : %s", error_details.message)
        return error_details.message_details()


def _handle_deployment_failed_error(error_response):
    """
    Extracts error message from error details and returns an exception
    """
    if error_response.error.details:
        details = error_response.error.details
        for error_details in details:
            # For time being only handling first element. Assuming there will be only one error message
            # coming from service side rather then clubbing multiple together
            return _extract_error_from_details(error_details)
    return error_response


def log_and_raise_error(error, debug=False, yaml_operation=False):

    # Log error with some custom details that will show up in the AZCli telemetry,
    # 'ml.cli.event' and 'ml.cli.info' have been approved by Azure CLI team to be used in telemetry
    # and be allowed by the GDPR filter.

    custom_properties_error = {
        "ml.cli.event": {
            "error_code": "",
            # TODO: as the security team detected and raised the concern that `raw_msg` may contain
            #       sensitive information, e.g. storage key, when some of the developers made mistake,
            #       this field will be set as empty string until we figure out a reliable way to
            #       mask/filter the sensitive information.
            "raw_msg": "",
        }
    }

    # use an f-string to automatically call str() on error
    if debug:
        module_logger.error(traceback.print_exc())

    if isinstance(error, HttpResponseError):
        module_logger.debug("Received HttpResponseError: %s", traceback.format_exc())

        if error.error and isinstance(error.error, ODataV4Format):
            if error.error and error.error.code and error.error.code == "DeploymentFailed":
                processed_error = _handle_deployment_failed_error(error_response=error)
                cli_error = azclierror.DeploymentError(processed_error)
            else:
                cli_error = error

            custom_properties_error["ml.cli.event"]["error_code"] = str(error.error.code)
            # custom_properties_error["ml.cli.event"]["raw_msg"] = error.error.message
        elif (
            hasattr(error, "response")
            and hasattr(error.response, "internal_response")
            and error.response.internal_response.text
        ):
            cli_error = HttpResponseError(error.response.internal_response.text)
            cli_error.response = error.response
            # custom_properties_error["ml.cli.event"]["raw_msg"] = error.response.internal_response.text
        else:
            cli_error = error
    # For common error types listed below, let AzureCLI error handling to process it so the error
    # can be classified properly. https://github.com/Azure/azure-cli/blob/
    # 110f7b402020f3d3ebd2bfb923ac5a01d026cdd1/src/azure-cli-core/azure/cli/core/util.py#L207
    elif isinstance(error, SchemaValidationError):
        module_logger.debug(traceback.format_exc())

        # For any other error, wrap as 'CLIError' otherwise AzureCLI will treat it as unexpected error
        try:
            cli_error = CLIError(
                format_create_validation_error(error.messages[0], yaml_operation=yaml_operation, cli=True)
            )
        except (
            NotImplementedError,
            KeyError,
        ):  # TODO: Remove KeyError once Job and Component validation errors are covered
            cli_error = error
    elif isinstance(error, ValidationException):
        module_logger.debug(traceback.format_exc())

        custom_properties_error["ml.cli.event"]["error_code"] = str(error.error_type)
        # custom_properties_error["ml.cli.event"]["raw_msg"] = error.no_personal_data_message

        # For any other error, wrap as 'CLIError' otherwise AzureCLI will treat it as unexpected error
        try:
            if error.error_type == ValidationErrorType.GENERIC:
                cli_error = error
            else:
                cli_error = CLIError(
                    format_create_validation_error(
                        error, yaml_operation=yaml_operation, cli=True, raw_error=error.raw_error
                    )
                )
        except NotImplementedError:
            cli_error = error
    elif isinstance(
        error,
        (
            azclierror.AzCLIError,
            JMESPathError,
            SSLError,
            ValidationError,
            CLIError,
            AzureError,
            AzureException,
            ClientRequestError,
            HttpOperationError,
            HTTPError,
            KeyboardInterrupt,
        ),
    ):
        custom_properties_error["ml.cli.event"]["error_code"] = str(error.__class__.__name__)
        # custom_properties_error["ml.cli.event"]["raw_msg"] = str(error)

        cli_error = error
    else:
        module_logger.debug(traceback.format_exc())

        custom_properties_error["ml.cli.event"]["error_code"] = str(error.__class__.__name__)
        # custom_properties_error["ml.cli.event"]["raw_msg"] = str(error)

        # For any other error, wrap as 'CLIError' otherwise AzureCLI will treat it as unexpected error
        cli_error = CLIError(
            f"Met error {type(error)}:{error}\nPlease check log by running the command with '--debug' for more details."
        )

    # TODO: with the security warning mentioned above, bypass this logging until we found a better way to mask the keys
    # # dictionary objects aren't populated to Kusto, so we need to serialize it to a string
    # serialized_event_dictionary = json.dumps(custom_properties_error["ml.cli.event"])
    # custom_properties_error["ml.cli.event"] = serialized_event_dictionary
    # azclierror.telemetry.add_extension_event("ml", custom_properties_error)

    raise cli_error


def print_limited_result_set_warning(max_results):
    print_styled_text_with_level(Style.WARNING, str(LIMITED_RESULTSET_WARNING_FORMAT.format(max_results)))
