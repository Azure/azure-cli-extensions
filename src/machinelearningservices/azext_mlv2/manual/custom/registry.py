# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------
from itertools import islice

from azure.ai.ml.constants._common import Scope
from azure.ai.ml.entities import Registry
from azure.ai.ml.entities._load_functions import load_registry

from .raise_error import log_and_raise_error
from .utils import _dump_entity_with_warnings, get_ml_client


def ml_registry_list(cmd, *, resource_group_name=None, max_results=None):
    # Note, this means that subscription-scoped calls can only be made if the user's default RG is
    # NOT set. Not ideal, but we need an official spec to do anything else.
    scope = Scope.RESOURCE_GROUP if resource_group_name else Scope.SUBSCRIPTION
    # ml_client needs a non-null rg input, even if we're doing a subscription-scoped search.
    resource_group_name = resource_group_name if resource_group_name else "noRG"
    ml_client, debug = get_ml_client(cli_ctx=cmd.cli_ctx, resource_group_name=resource_group_name)
    try:
        if max_results:
            results = islice(ml_client.registries.list(scope=scope), int(max_results))
        else:
            results = ml_client.registries.list(scope=scope)
        return [_dump_entity_with_warnings(x) for x in results]
    except Exception as err:  # pylint: disable=broad-exception-caught
        log_and_raise_error(err, debug)


def ml_registry_show(cmd, resource_group_name, name):
    ml_client, debug = get_ml_client(cli_ctx=cmd.cli_ctx, resource_group_name=resource_group_name)

    try:
        reg = ml_client.registries.get(name)
        return _dump_entity_with_warnings(reg)
    except Exception as err:  # pylint: disable=broad-exception-caught
        log_and_raise_error(err, debug)


# used by the generic update command to verify that an updated registry exists before calling ml_registry_update
def _ml_registry_show(cmd, resource_group_name, name=None, file=None):
    if name is None:
        no_name_err = ValueError(
            "Command 'registry update' was provided with neither a name nor a YAML file containing a named registry"
        )
        if file is not None:
            local_reg = load_registry(source=file)
            if local_reg is None:
                raise no_name_err
            name = local_reg.name
        else:
            raise no_name_err

    ml_client, debug = get_ml_client(cli_ctx=cmd.cli_ctx, resource_group_name=resource_group_name)

    try:
        return ml_client.registries.get(name)
    except Exception as err:  # pylint: disable=broad-exception-caught
        log_and_raise_error(err, debug)


def ml_registry_create(
    cmd,
    resource_group_name,
    name=None,
    display_name=None,
    tags=None,
    public_network_access=None,
    params_override=None,
    file=None,
    no_wait=False,
):
    ml_client, debug = get_ml_client(cli_ctx=cmd.cli_ctx, resource_group_name=resource_group_name)

    params_override = params_override or []
    if name:
        params_override.append({"name": name})
    if display_name:
        params_override.append({"display_name": display_name})
    if tags:
        params_override.append({"tags": tags})
    # Currently broken - takes default location and inputs that as
    # override
    # if location:
    #    params_override.append({"location": location})
    if public_network_access is not None:
        params_override.append({"public_network_access": public_network_access})
    try:
        registry = load_registry(source=file, params_override=params_override)

        reg = ml_client.registries.begin_create(registry=registry, no_wait=no_wait)
        return _dump_entity_with_warnings(reg) if reg else None
    except Exception as err:  # pylint: disable=broad-exception-caught
        log_and_raise_error(err, debug)


# Functions mostly like the create command, but makes sure that the registry exists
# first before making an upsert request.
def ml_registry_update(
    cmd,
    resource_group_name,
    name=None,
    display_name=None,
    tags=None,
    public_network_access=None,
    file=None,
    parameters: Registry = None,  # expected to be the registry returned by the related _ml_registry_show call.
    no_wait=False,
):
    ml_client, debug = get_ml_client(cli_ctx=cmd.cli_ctx, resource_group_name=resource_group_name)

    params_override = []
    if name:
        params_override.append({"name": name})
    if display_name:
        params_override.append({"display_name": display_name})
    if tags:
        params_override.append({"tags": tags})
    if public_network_access is not None:
        params_override.append({"public_network_access": public_network_access})
    try:
        registry = None
        if file is not None:
            registry = load_registry(source=file, params_override=params_override)
        else:
            # use registry from _ml_registry_show call if no YAML registry is provided
            # This makes --set and --add clargs mutually exclusive with --file.
            # There's isn't a clean way around this since it's impossible to tell
            # what's an original value and what's a modified value from
            # --set or --add in the parameters input by the time we're in this
            # code block. (unless we try serious black magic that's bound to cause other problems.)
            registry = parameters
        reg = ml_client.registries.begin_create(registry=registry, no_wait=no_wait)
        return _dump_entity_with_warnings(reg) if reg else None
    except Exception as err:  # pylint: disable=broad-exception-caught
        log_and_raise_error(err, debug)


def ml_registry_delete(cmd, resource_group_name=None, name=None):
    ml_client, debug = get_ml_client(cli_ctx=cmd.cli_ctx, resource_group_name=resource_group_name)

    try:
        return ml_client.registries.begin_delete(name=name)
    except Exception as err:  # pylint: disable=broad-exception-caught
        log_and_raise_error(err, debug)
