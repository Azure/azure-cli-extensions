# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------
# ---------------------------------------------------------
from itertools import islice
from typing import Dict

from marshmallow import EXCLUDE

from azure.ai.ml._restclient.v2022_10_01_preview.models import ScheduleListViewType
from azure.ai.ml.entities import JobSchedule, Schedule
from azure.ai.ml.entities._load_functions import load_schedule
from azure.cli.core.commands import LongRunningOperation

from ._telemetry.structure import ScheduleInfo
from .raise_error import log_and_raise_error, print_limited_result_set_warning
from .utils import _dump_entity_with_warnings, get_ml_client, telemetry_log_info


def ml_schedule_list(
    cmd,
    resource_group_name,
    workspace_name=None,
    max_results=None,
    include_disabled=False,
    disabled_only=False,
):
    return _ml_schedule_list(
        cmd=cmd,
        resource_group_name=resource_group_name,
        workspace_name=workspace_name,
        max_results=max_results,
        include_disabled=include_disabled,
        disabled_only=disabled_only,
    )


def ml_schedule_show(cmd, resource_group_name, name, workspace_name=None):
    return _ml_schedule_show(
        cmd=cmd,
        resource_group_name=resource_group_name,
        workspace_name=workspace_name,
        name=name,
    )


def ml_schedule_create(
    cmd,
    file,
    resource_group_name,
    workspace_name=None,
    name=None,
    params_override=None,
    no_wait=False,
):
    return _ml_schedule_create(
        cmd=cmd,
        file=file,
        resource_group_name=resource_group_name,
        workspace_name=workspace_name,
        name=name,
        no_wait=no_wait,
        params_override=params_override,
    )


def ml_schedule_update(cmd, resource_group_name, workspace_name, parameters: Dict = None, no_wait=False):
    ml_client, debug = get_ml_client(
        cli_ctx=cmd.cli_ctx, resource_group_name=resource_group_name, workspace_name=workspace_name
    )

    try:
        # 1. load parameters into schedule entity
        # Set unknown to EXCLUDE so that marshmallow doesn't raise on dump only fields.
        schedule_class, _ = Schedule._resolve_cls_and_type(parameters, [])  # pylint: disable=protected-access
        if schedule_class == JobSchedule:
            schedule = JobSchedule._load_from_rest_dict(data=parameters, unknown=EXCLUDE)  # pylint: disable=protected-access
        else:
            schedule = schedule_class._load(parameters)  # pylint: disable=protected-access
        # 2. update the schedule
        result = ml_client.begin_create_or_update(schedule)
        if not no_wait:
            result = LongRunningOperation(cmd.cli_ctx)(result)
        return _dump_entity_with_warnings(result)
    except Exception as err:  # pylint: disable=broad-exception-caught
        log_and_raise_error(err, debug)


def ml_schedule_disable(cmd, resource_group_name, workspace_name, name, no_wait=False):
    ml_client, debug = get_ml_client(
        cli_ctx=cmd.cli_ctx, resource_group_name=resource_group_name, workspace_name=workspace_name
    )
    try:
        result = ml_client.schedules.begin_disable(name=name)
        if not no_wait:
            result = LongRunningOperation(cmd.cli_ctx)(result)
        return _dump_entity_with_warnings(result)
    except Exception as err:  # pylint: disable=broad-exception-caught
        log_and_raise_error(err, debug)


def ml_schedule_enable(cmd, resource_group_name, workspace_name, name, no_wait=False):
    ml_client, debug = get_ml_client(
        cli_ctx=cmd.cli_ctx, resource_group_name=resource_group_name, workspace_name=workspace_name
    )
    try:
        result = ml_client.schedules.begin_enable(name=name)
        if not no_wait:
            result = LongRunningOperation(cmd.cli_ctx)(result)
        return _dump_entity_with_warnings(result)
    except Exception as err:  # pylint: disable=broad-exception-caught
        log_and_raise_error(err, debug)


def ml_schedule_delete(cmd, resource_group_name, workspace_name, name, no_wait=False):
    ml_client, debug = get_ml_client(
        cli_ctx=cmd.cli_ctx, resource_group_name=resource_group_name, workspace_name=workspace_name
    )
    try:
        result = ml_client.schedules.begin_delete(name=name)
        if not no_wait:
            result = LongRunningOperation(cmd.cli_ctx)(result)
        return result
    except Exception as err:  # pylint: disable=broad-exception-caught
        log_and_raise_error(err, debug)


def ml_schedule_trigger(cmd, resource_group_name, workspace_name, name):
    ml_client, debug = get_ml_client(
        cli_ctx=cmd.cli_ctx, resource_group_name=resource_group_name, workspace_name=workspace_name
    )
    try:
        result = ml_client.schedules.trigger(name=name)
        return result._to_dict()  # pylint: disable=protected-access
    except Exception as err:  # pylint: disable=broad-exception-caught
        log_and_raise_error(err, debug)


def get_schedule_list_view_type(include_disabled: bool, disabled_only: bool) -> ScheduleListViewType:
    if include_disabled and disabled_only:
        raise ValueError("Cannot provide both disabled-only and include-disabled.")
    if include_disabled:
        return ScheduleListViewType.ALL
    if disabled_only:
        return ScheduleListViewType.DISABLED_ONLY
    return ScheduleListViewType.ENABLED_ONLY


def _ml_schedule_list(
    cmd,
    resource_group_name,
    max_results,
    include_disabled,
    disabled_only,
    workspace_name=None,
):
    ml_client, debug = get_ml_client(
        cli_ctx=cmd.cli_ctx,
        resource_group_name=resource_group_name,
        workspace_name=workspace_name,
    )

    try:
        list_view_type = get_schedule_list_view_type(include_disabled=include_disabled, disabled_only=disabled_only)
        if max_results:
            print_limited_result_set_warning(max_results)
            results = islice(
                ml_client.schedules.list(list_view_type=list_view_type),
                int(max_results),
            )
        else:
            results = ml_client.schedules.list(list_view_type=list_view_type)
        return [_dump_entity_with_warnings(x) for x in results]

    except Exception as err:  # pylint: disable=broad-exception-caught
        log_and_raise_error(err, debug)


def _ml_schedule_show(cmd, resource_group_name, name, workspace_name=None):
    ml_client, debug = get_ml_client(
        cli_ctx=cmd.cli_ctx,
        resource_group_name=resource_group_name,
        workspace_name=workspace_name,
    )

    try:
        schedule = ml_client.schedules.get(name=name)
        return _dump_entity_with_warnings(schedule)
    except Exception as err:  # pylint: disable=broad-exception-caught
        log_and_raise_error(err, debug)


def _ml_schedule_create(cmd, file, resource_group_name, params_override, name, workspace_name=None, no_wait=False):
    ml_client, debug = get_ml_client(
        cli_ctx=cmd.cli_ctx,
        resource_group_name=resource_group_name,
        workspace_name=workspace_name,
    )
    params_override = params_override or []

    schedule_info = ScheduleInfo()

    try:
        # 1. update override params
        if name:
            params_override.append({"name": name})
        # 2. load to schedule schema
        schedule = load_schedule(source=file, params_override=params_override)

        if schedule and hasattr(schedule, "create_monitor"):
            if schedule.create_monitor.monitoring_signals:
                signal_list = []
                for signal in schedule.create_monitor.monitoring_signals.values():
                    signal_list.append(signal.type)

                schedule_info.signal_type = signal_list
            if schedule.create_monitor.monitoring_target:
                schedule_info.task_type = schedule.create_monitor.monitoring_target.ml_task
        # 3. create schedule
        result = ml_client.begin_create_or_update(schedule)
        if not no_wait:
            result = LongRunningOperation(cmd.cli_ctx)(result)
        return _dump_entity_with_warnings(result)
    except Exception as err:  # pylint: disable=broad-exception-caught
        log_and_raise_error(err, debug)
    finally:
        telemetry_log_info(schedule_info.__dict__)
