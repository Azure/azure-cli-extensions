# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------
from knack.log import get_logger
from azure.cli.core.commands import LongRunningOperation
from azure.ai.ml.entities import FqdnDestination, ServiceTagDestination, PrivateEndpointDestination
from .raise_error import log_and_raise_error
from .utils import _dump_entity_with_warnings, get_ml_client
module_logger = get_logger()


def ml_workspace_outbound_rule_show(cmd, resource_group_name, workspace_name, rule):
    ml_client, debug = get_ml_client(cli_ctx=cmd.cli_ctx, resource_group_name=resource_group_name)
    try:
        result = ml_client.workspace_outbound_rules.get(
            workspace_name=workspace_name,
            outbound_rule_name=rule,
            resource_group=resource_group_name
        )
        return _dump_entity_with_warnings(result)
    except Exception as err:  # pylint: disable=broad-exception-caught
        log_and_raise_error(err, debug)


def ml_workspace_outbound_rule_list(cmd, resource_group_name, workspace_name):
    ml_client, debug = get_ml_client(cli_ctx=cmd.cli_ctx, resource_group_name=resource_group_name)
    try:
        results = ml_client.workspace_outbound_rules.list(
            workspace_name=workspace_name,
            resource_group=resource_group_name
        )

        return [_dump_entity_with_warnings(x) for x in results]
    except Exception as err:  # pylint: disable=broad-exception-caught
        log_and_raise_error(err, debug)


def ml_workspace_outbound_rule_set(
    cmd,
    resource_group_name,
    workspace_name,
    rule,
    type,  # pylint: disable=redefined-builtin
    destination=None,
    service_tag=None,
    protocol=None,
    port_ranges=None,
    address_prefixes=None,
    service_resource_id=None,
    subresource_target=None,
    spark_enabled=None,
    fqdns=None,
    no_wait=False
):
    ml_client, debug = get_ml_client(cli_ctx=cmd.cli_ctx, resource_group_name=resource_group_name)
    if type == "fqdn":
        # Check required and forbidden parameters for fqdn type
        required_params = destination is not None
        forbidden_params = (
            service_tag is not None or protocol is not None or
            port_ranges is not None or service_resource_id is not None or
            subresource_target is not None
        )
        if not required_params or forbidden_params:
            log_and_raise_error('fqdn outbound rule should specify the following parameter: "--destination"')
        rule = FqdnDestination(name=rule, destination=destination)
    elif type == "service_tag":
        # Check required and forbidden parameters for service_tag type
        required_params = (
            service_tag is not None and protocol is not None and port_ranges is not None
        )
        forbidden_params = (
            destination is not None or service_resource_id is not None or
            subresource_target is not None
        )
        if not required_params or forbidden_params:
            log_and_raise_error(
                'service_tag outbound rule should specify the following parameters: '
                '"--service-tag", "--protocol", and "--port-ranges", [Optional]: "--address-prefixes"'
            )
        if address_prefixes is not None:
            address_prefixes = [prefix.strip() for prefix in address_prefixes.split(',')]
        rule = ServiceTagDestination(
            name=rule,
            service_tag=service_tag,
            protocol=protocol,
            port_ranges=port_ranges,
            address_prefixes=address_prefixes
        )
    elif type == "private_endpoint":
        # Check required and forbidden parameters for private_endpoint type
        required_params = (
            service_resource_id is not None and subresource_target is not None
        )
        forbidden_params = (
            destination is not None or service_tag is not None or
            protocol is not None or port_ranges is not None
        )
        if not required_params or forbidden_params:
            log_and_raise_error(
                'private_endpoint outbound rule should specify the following parameters: '
                '"--service-resource-id", and "--subresource-target". [Optional]: "--spark-enabled", "--fqdns"'
            )
        if fqdns is not None:
            fqdns = [fqdn.strip() for fqdn in fqdns.split(',')]
        rule = PrivateEndpointDestination(
            name=rule,
            service_resource_id=service_resource_id,
            subresource_target=subresource_target,
            spark_enabled=spark_enabled,
            fqdns=fqdns
        )
    else:
        log_and_raise_error('--type must be one of the following: fqdn, service_tag, private_endpoint')

    try:
        set_result = ml_client.workspace_outbound_rules.begin_create(
            workspace_name=workspace_name,
            rule=rule,
            resource_group=resource_group_name
        )
        if not no_wait:
            set_result = LongRunningOperation(cmd.cli_ctx)(set_result)
            return _dump_entity_with_warnings(set_result)
        return set_result
    except Exception as err:  # pylint: disable=broad-exception-caught
        log_and_raise_error(err, debug)


def ml_workspace_outbound_rule_remove(cmd, resource_group_name, workspace_name, rule, no_wait=False):
    ml_client, debug = get_ml_client(cli_ctx=cmd.cli_ctx, resource_group_name=resource_group_name)

    try:
        del_result = ml_client.workspace_outbound_rules.begin_remove(
            workspace_name=workspace_name,
            outbound_rule_name=rule,
            resource_group=resource_group_name
        )
        if not no_wait:
            del_result = LongRunningOperation(cmd.cli_ctx)(del_result)
        return del_result
    except Exception as err:  # pylint: disable=broad-exception-caught
        log_and_raise_error(err, debug)
