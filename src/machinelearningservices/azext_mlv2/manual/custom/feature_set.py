# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------
import json
from itertools import islice
from typing import Optional, List

from knack.log import get_logger

from azure.ai.ml.entities import FeatureSet
from azure.ai.ml.entities._load_functions import load_feature_set, load_feature_set_backfill_request
from azure.ai.ml.exceptions import ErrorCategory, ErrorTarget, UserErrorException
from azure.cli.core.commands import LongRunningOperation
from azure.core.exceptions import ResourceNotFoundError

from .raise_error import log_and_raise_error
from .utils import _dump_entity_with_warnings, get_list_view_type, get_ml_client

module_logger = get_logger()


def ml_feature_set_list(
    cmd,
    resource_group_name=None,
    workspace_name=None,
    name=None,
    max_results=None,
    include_archived=False,
    archived_only=False,
):
    ml_client, debug = get_ml_client(
        cli_ctx=cmd.cli_ctx, resource_group_name=resource_group_name, workspace_name=workspace_name
    )
    try:
        list_view_type = get_list_view_type(include_archived=include_archived, archived_only=archived_only)
        if max_results:
            results = islice(
                ml_client.feature_sets.list(name=name, list_view_type=list_view_type),
                int(max_results),
            )
        else:
            results = ml_client.feature_sets.list(name=name, list_view_type=list_view_type)
        return [_dump_entity_with_warnings(x) for x in results]
    except Exception as err:  # pylint: disable=broad-exception-caught
        log_and_raise_error(err, debug)


def ml_feature_set_show(cmd, name, version, resource_group_name=None, workspace_name=None):
    ml_client, debug = get_ml_client(
        cli_ctx=cmd.cli_ctx, resource_group_name=resource_group_name, workspace_name=workspace_name
    )

    try:
        feature_set = ml_client.feature_sets.get(name=name, version=version)
        return _dump_entity_with_warnings(feature_set)
    except Exception as err:  # pylint: disable=broad-exception-caught
        log_and_raise_error(err, debug)


def ml_feature_set_create(
    cmd,
    resource_group_name: Optional[str] = None,
    workspace_name: Optional[str] = None,
    file: Optional[str] = None,
    name: Optional[str] = None,
    version: Optional[str] = None,
    description: Optional[str] = None,
    specification=None,
    materialization_settings=None,
    params_override: Optional[list] = None,
    no_wait: Optional[bool] = False,
):
    ml_client, debug = get_ml_client(
        cli_ctx=cmd.cli_ctx,
        resource_group_name=resource_group_name,
        workspace_name=workspace_name,
    )
    params_override = params_override or []
    if name:
        params_override.append({"name": name})
    if description:
        params_override.append({"description": description})
    if version:
        params_override.append({"version": version})
    if specification:
        params_override.append({"specification": json.loads(specification)})
    if materialization_settings:
        params_override.append({"materialization_settings": json.loads(materialization_settings)})

    try:
        feature_set = load_feature_set(source=file, params_override=params_override)
        feature_set_poller = ml_client.feature_sets.begin_create_or_update(feature_set)
        if not no_wait:
            feature_set = LongRunningOperation(cmd.cli_ctx)(feature_set_poller)
        else:
            module_logger.warning(
                "Feature set create request initiated. Status can be checked using "
                "`az ml feature-set show --name %s --version %s`", feature_set.name, feature_set.version
            )
        return _dump_entity_with_warnings(feature_set)
    except Exception as err:  # pylint: disable=broad-exception-caught
        yaml_operation = bool(file)
        log_and_raise_error(err, debug, yaml_operation=yaml_operation)


# This will only be used for generic update
def _ml_feature_set_show(cmd, resource_group_name, workspace_name, file=None, name=None, version=None):
    if not file and not (name or version):
        msg = 'One of "file" or "name/version" options are required. Set only one option and try again.'
        raise UserErrorException(
            message=msg,
            no_personal_data_message=msg,
            target=ErrorTarget.FEATURE_SET,
            error_category=ErrorCategory.USER_ERROR,
        )
    if file and (name or version):
        msg = '"file" and "name/version" options are mutually exclusive. Set only one option and try again.'
        raise UserErrorException(
            message=msg,
            no_personal_data_message=msg,
            target=ErrorTarget.FEATURE_SET,
            error_category=ErrorCategory.USER_ERROR,
        )

    if file:
        # Do not make a GET call when users provide a YAML file.
        return {}
    return ml_feature_set_show(cmd, name, version, resource_group_name, workspace_name)


def ml_feature_set_update(
    cmd, resource_group_name, workspace_name, file=None, name=None, version=None, no_wait=False, parameters=None
):
    ml_client, debug = get_ml_client(
        cli_ctx=cmd.cli_ctx, resource_group_name=resource_group_name, workspace_name=workspace_name
    )
    if file:
        feature_set_dict = load_feature_set(source=file, params_override=parameters)._to_dict()  # pylint: disable=protected-access
    else:
        feature_set_dict = parameters

    feature_set_obj = FeatureSet._load(data=feature_set_dict, yaml_path=file)  # pylint: disable=protected-access
    # Check if feature set exists
    if file:
        try:
            ml_client.feature_sets.get(name=feature_set_obj.name, version=feature_set_obj.version)
        except Exception as err:  # pylint: disable=broad-exception-caught
            if isinstance(err, ResourceNotFoundError):
                raise ValueError(
                    f"Feature set {feature_set_obj.name}:{feature_set_obj.version} does not exist"
                ) from err

    try:
        feature_set_poller = ml_client.feature_sets.begin_create_or_update(feature_set_obj)
        if not no_wait:
            feature_set = LongRunningOperation(cmd.cli_ctx)(feature_set_poller)
            return _dump_entity_with_warnings(feature_set)
        module_logger.warning(
            "Feature set update request initiated. Status can be checked using "
            "`az ml feature-set show --name %s --version %s`", name, version
        )
    except Exception as err:  # pylint: disable=broad-exception-caught
        log_and_raise_error(err, debug)


def ml_feature_set_archive(cmd, name, version, resource_group_name=None, workspace_name=None):
    ml_client, debug = get_ml_client(
        cli_ctx=cmd.cli_ctx, resource_group_name=resource_group_name, workspace_name=workspace_name
    )
    try:
        return ml_client.feature_sets.archive(name=name, version=version)
    except Exception as err:  # pylint: disable=broad-exception-caught
        log_and_raise_error(err, debug)


def ml_feature_set_restore(cmd, name, version, resource_group_name=None, workspace_name=None):
    ml_client, debug = get_ml_client(
        cli_ctx=cmd.cli_ctx, resource_group_name=resource_group_name, workspace_name=workspace_name
    )
    try:
        return ml_client.feature_sets.restore(name=name, version=version)
    except Exception as err:  # pylint: disable=broad-exception-caught
        log_and_raise_error(err, debug)


def ml_feature_set_backfill(
    cmd,
    name: Optional[str] = None,
    version: Optional[str] = None,
    feature_window_start_time: Optional[str] = None,
    feature_window_end_time: Optional[str] = None,
    resource_group_name=None,
    workspace_name=None,
    file: Optional[str] = None,
    display_name: Optional[str] = None,
    description: Optional[str] = None,
    tags=None,
    compute_resource=None,
    spark_configuration=None,
    by_data_status: Optional[List[str]] = None,
    by_job_id: Optional[str] = None,
):
    ml_client, debug = get_ml_client(
        cli_ctx=cmd.cli_ctx, resource_group_name=resource_group_name, workspace_name=workspace_name
    )

    params_override = []
    if name:
        params_override.append({"name": name})
    if version:
        params_override.append({"version": version})
    if description:
        params_override.append({"description": description})
    if feature_window_start_time or feature_window_end_time:
        feature_window = {
            "feature_window_end": feature_window_end_time,
            "feature_window_start": feature_window_start_time
        }
        params_override.append({"feature_window": feature_window})
    if tags:
        params_override.append({"tags": json.loads(tags)})
    if compute_resource:
        params_override.append({"Resource": compute_resource._to_rest_object()})  # pylint: disable=protected-access
    if spark_configuration:
        params_override.append({"spark_configuration": json.loads(spark_configuration)})
    if by_data_status:
        params_override.append({"data_status": json.loads(by_data_status)})
    if by_job_id:
        params_override.append({"job_id": by_job_id})

    try:
        feature_set_backfill_data = load_feature_set_backfill_request(source=file, params_override=params_override)
        return ml_client.feature_sets.begin_backfill(
            name=feature_set_backfill_data.name,
            version=version,
            feature_window_start_time=feature_set_backfill_data.feature_window["feature_window_start"]
            if feature_set_backfill_data.feature_window else None,
            feature_window_end_time=feature_set_backfill_data.feature_window["feature_window_end"]
            if feature_set_backfill_data.feature_window else None,
            display_name=display_name,
            description=feature_set_backfill_data.description,
            tags=feature_set_backfill_data.tags,
            compute_resource=feature_set_backfill_data.resource,
            spark_configuration=feature_set_backfill_data.spark_configuration,
            data_status=feature_set_backfill_data.data_status,
            job_id=feature_set_backfill_data.job_id)
    except Exception as err:  # pylint: disable=broad-exception-caught
        log_and_raise_error(err, debug)


def ml_feature_set_list_materialization_operation(
    cmd,
    name,
    version,
    feature_window_start_time=None,
    feature_window_end_time=None,
    resource_group_name=None,
    workspace_name=None,
    filters=None,
):
    ml_client, debug = get_ml_client(
        cli_ctx=cmd.cli_ctx, resource_group_name=resource_group_name, workspace_name=workspace_name
    )
    try:
        return ml_client.feature_sets.list_materialization_operations(
            name=name,
            version=version,
            feature_window_start_time=feature_window_start_time,
            feature_window_end_time=feature_window_end_time,
            filters=filters,
        )
    except Exception as err:  # pylint: disable=broad-exception-caught
        log_and_raise_error(err, debug)


def ml_feature_set_list_features(cmd, name, version, feature_name=None, resource_group_name=None, workspace_name=None):
    ml_client, debug = get_ml_client(
        cli_ctx=cmd.cli_ctx, resource_group_name=resource_group_name, workspace_name=workspace_name
    )
    try:
        return ml_client.feature_sets.list_features(feature_set_name=name, version=version, feature_name=feature_name)
    except Exception as err:  # pylint: disable=broad-exception-caught
        log_and_raise_error(err, debug)


def ml_feature_set_show_feature(cmd, name, version, feature_name, resource_group_name=None, workspace_name=None):
    ml_client, debug = get_ml_client(
        cli_ctx=cmd.cli_ctx, resource_group_name=resource_group_name, workspace_name=workspace_name
    )
    try:
        return ml_client.feature_sets.get_feature(feature_set_name=name, version=version, feature_name=feature_name)
    except Exception as err:  # pylint: disable=broad-exception-caught
        log_and_raise_error(err, debug)
