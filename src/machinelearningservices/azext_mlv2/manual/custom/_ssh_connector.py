# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------
# pylint: disable=protected-access

import asyncio
import concurrent
import concurrent.futures
import os
import os.path
import sys
import typing
from typing import TYPE_CHECKING

import websockets  # pylint: disable=import-error
import websockets.client  # pylint: disable=import-error
import websockets.exceptions  # pylint: disable=import-error

from azure.cli.core import get_default_cli


def run_az_cli(args):
    cli = get_default_cli()
    cli.invoke(args)
    if not cli.result:
        raise Exception("az cli failed")  # pylint: disable=broad-exception-raised
    if cli.result.result:
        return cli.result.result
    if cli.result.error:
        raise cli.result.error
    raise Exception("az cli failed")  # pylint: disable=broad-exception-raised


if TYPE_CHECKING:
    from azure.ai.ml.operations import DatastoreOperations


class SshConnector:  # pylint: disable=too-few-public-methods
    def connect_ssh(self) -> None:
        if os.name == "nt":
            # On Windows, the ProactorEventLoop is necessary to listen on pipes
            loop = asyncio.ProactorEventLoop()
            print("Detected Windows, using ProactorEventLoop", file=sys.stderr)
        else:
            loop = asyncio.new_event_loop()
            print("Detected non-Windows, using standard AsyncIO event loop", file=sys.stderr)
        asyncio.set_event_loop(loop)
        loop.run_until_complete(self._connect_ssh())

    async def _connect_ssh(self):
        if len(sys.argv) < 2 or not sys.argv[1] or not sys.argv[1].strip():
            msg = (
                "The command line argument to get proxy_endpoint is empty or whitespace. "
                "Example: python _ssh_connector.py <proxy_endpoint>"
            )
            raise Exception(msg)  # pylint: disable=broad-exception-raised
        proxy_endpoint = sys.argv[1]
        mgtScope = ["https://management.core.windows.net/.default"]

        aml_token = run_az_cli(["account", "get-access-token", "--scope", mgtScope[0]])["accessToken"]

        async with websockets.client.connect(
            uri=f"{proxy_endpoint}/nbip/v1.0/ws-tcp",
            extra_headers={"Authorization": f"Bearer {aml_token}"},
        ) as websocket:

            async def run_streams(thread_pool):
                loop = asyncio.get_event_loop()

                async def upstream_loop():
                    "Reads from stdin and pushes to websocket"
                    MAX_READ_BUFFER_LEN_BYTES = 4096

                    def blocking_read():
                        return os.read(0, MAX_READ_BUFFER_LEN_BYTES)

                    try:
                        while True:
                            # Read up to a maximum amount in one chunk...
                            # Run the blocking read task in another thread
                            # (TODO: On linux, just use asyncio to read from stdin)
                            buffer = await loop.run_in_executor(thread_pool, blocking_read)
                            if not buffer:
                                # An empty buffer indicates the connection has ended,
                                # otherwise we wait forever for any new content
                                print("Read stream emptied; closing read task", file=sys.stderr)
                                return  # connection lost
                            await websocket.send(buffer)
                    except Exception as e:
                        print(f"Reader threw error: {e}", file=sys.stderr)
                        raise

                async def downstream_loop():
                    "Reads from websocket and pushes to stdout"
                    try:
                        while websocket.open:  # and not writer_stdout.is_closing:
                            content = typing.cast(typing.Optional[bytes], await websocket.recv())

                            if content:
                                os.write(1, content)
                    except Exception as e:
                        print(f"Writer threw error: {e}", file=sys.stderr)
                        raise

                try:
                    await asyncio.gather(upstream_loop(), downstream_loop(), return_exceptions=True)
                except websockets.exceptions.ConnectionClosed:
                    # Connection lost while relaying to the websocket
                    print("Lost connection to websocket service", file=sys.stderr)

            # End of run_streams

            with concurrent.futures.ThreadPoolExecutor() as pool:
                await run_streams(pool)


SshConnector().connect_ssh()
