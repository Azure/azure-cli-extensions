# --------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
#
# Code generated by aaz-dev-tools
# --------------------------------------------------------------------------------------------

# pylint: disable=too-many-lines
# pylint: disable=too-many-statements


from knack.log import get_logger
from .aaz.latest.firmwareanalysis.firmware import CryptoCertificate as _CryptoCertificate
from .aaz.latest.firmwareanalysis.firmware import Cve as _Cve
from .aaz.latest.firmwareanalysis.firmware import Create
from .aaz.latest.firmwareanalysis.workspace import GenerateUploadUrl
from azure.storage.blob import BlobClient

logger = get_logger(__name__)


class CryptoCertificate(_CryptoCertificate):
    def _output(self, *args, **kwargs):
        from azure.cli.core.aaz import AAZUndefined
        from azure.cli.core.aaz import has_value

        # resolve flatten conflict
        # when the type field conflicts, the type in inner layer is ignored and the outer layer is applied
        for item in self.ctx.vars.instance.value:
            props = item.properties
            if has_value(props.name):
                props.name = AAZUndefined

        result = self.deserialize_output(self.ctx.vars.instance.value, client_flatten=True)
        next_link = self.deserialize_output(self.ctx.vars.instance.next_link)

        return result, next_link


class Cve(_Cve):
    def _output(self, *args, **kwargs):
        from azure.cli.core.aaz import AAZUndefined
        from azure.cli.core.aaz import has_value

        # resolve flatten conflict
        # when the type field conflicts, the type in inner layer is ignored and the outer layer is applied
        for item in self.ctx.vars.instance.value:
            props = item.properties
            if has_value(props.name):
                props.name = AAZUndefined

        result = self.deserialize_output(self.ctx.vars.instance.value, client_flatten=True)
        next_link = self.deserialize_output(self.ctx.vars.instance.next_link)

        return result, next_link

def firmware_upload(cmd, resource_group_name, workspace_name, firmware_id, file_path):
    Create(cli_ctx=cmd.cli_ctx)(command_args={
        "resource_group": resource_group_name,
        "workspace_name": workspace_name,
        "firmware_id": firmware_id
    })
    return GenerateUploadUrl(cli_ctx=cmd.cli_ctx)(command_args={
        "resource_group": resource_group_name,
        "workspace_name": workspace_name,
        "firmware_id": firmware_id
    })