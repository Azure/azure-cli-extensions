# --------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
#
# Code generated by aaz-dev-tools
# --------------------------------------------------------------------------------------------
# pylint: disable=too-many-lines
# pylint: disable=too-many-statements
# pylint: disable=line-too-long, logging-fstring-interpolation, broad-exception-caught
import os
import json

from azure.cli.core.aaz import AAZStrArg
from azure.cli.core.azclierror import ValidationError
from knack.log import get_logger

from .aaz.latest.arc_multicloud import GenerateAwsTemplate as _GenAwsTemplate
from .aaz.latest.arc_multicloud.public_cloud_connector import (
    Create as _PublicCloudConnectorCreate,
    Delete as _PublicCloudConnectorDelete,
    List as _PublicCloudConnectorList,
    Show as _PublicCloudConnectorShow,
    TestPermission as _PublicCloudConnectorTestPermission,
    Update as _PublicCloudConnectorUpdate
)
from .aaz.latest.arc_multicloud.solution_configuration import (
    Create as _SolutionConfigurationCreate,
    Delete as _SolutionConfigurationDelete,
    List as _SolutionConfigurationList,
    Show as _SolutionConfigurationShow,
    SyncNow as _SolutionConfigurationSyncNow,
    Update as _SolutionConfigurationUpdate
)
from .aaz.latest.arc_multicloud.solution_type import (
    List as _SolutionTypeList,
    Show as _SolutionTypeShow
)
from ._utils import register_providers_if_needed


logger = get_logger(__name__)


# Wrapper - Customization for GenerateAwsTemplate, add new argument and write the output to json file on disk
def customized_generate_aws_template(cmd, connector_id, output_directory=None):
    class OutputAwsTemplateToFile(_GenAwsTemplate):
        @classmethod
        def _build_arguments_schema(cls, *args, **kwargs):
            args_schema = super()._build_arguments_schema(*args, **kwargs)

            # Add the --output-directory argument to the schema with an optional argument
            args_schema.output_directory = AAZStrArg(
                options=["--output-directory"],
                help="Directory where the output AWS templated JSON file will be written. Defaults to './AzureArcMulticloudFolder/'.",
                nullable=True
            )

            return args_schema

        def pre_operations(self):
            register_providers_if_needed(cmd=self.ctx)
            super().pre_operations()

        def output_response_to_file(self):
            raw_response = super()._output()

            # Check if 'body' exists and flatten its contents into the parent dictionary
            if "body" in raw_response and isinstance(raw_response["body"], dict):
                # Merge 'body' contents into the parent structure
                body_content = raw_response.pop("body")
                raw_response.update(body_content)

            output_dir = self.ctx.args.output_directory

            # Convert AAZStrArg to a string
            if output_dir is not None:
                output_dir = output_dir.to_serialized_data()

            # Use default directory if the user doesn't provide --output-directory
            output_dir = output_dir or "./AzureArcMulticloudFolder"

            if not os.path.exists(output_dir):
                try:
                    os.makedirs(output_dir)
                    logger.info("successfully create the dir")
                except Exception as e:
                    raise ValidationError(f"Failed to create directory {output_directory}: {str(e)}")

            output_file_path = os.path.join(output_dir, 'aws_template.json')

            # Write the output in JSON file
            try:
                with open(output_file_path, 'w') as output_file:
                    json.dump(raw_response, output_file, indent=4)

                logger.debug(f"Response successfully written to {output_file_path}")
            except Exception as e:
                raise ValidationError(f"Failed to write response to file: {e}")

        def _output(self, *args, **kwargs):
            try:
                self.output_response_to_file()
                return {
                    "status": "success",
                    "message": "AWS template was generated and saved successfully. Please check your specified output directory or default to ./AzureArcMulticloudFolder",
                }
            except Exception as e:
                return {
                    "status": "error",
                    "message": f"An error occurred: {str(e)}"
                }

    return OutputAwsTemplateToFile(cli_ctx=cmd.cli_ctx)(command_args={
        "connector_id": connector_id,
        "output_directory": output_directory
    })


# Inheritance - Register required RPs before execute each command
class CustomizedPublicCloudConnectorCreate(_PublicCloudConnectorCreate):
    def pre_operations(self):
        register_providers_if_needed(cmd=self.ctx)
        super().pre_operations()


class CustomizedPublicCloudConnectorDelete(_PublicCloudConnectorDelete):
    def pre_operations(self):
        register_providers_if_needed(cmd=self.ctx)
        super().pre_operations()


class CustomizedPublicCloudConnectorList(_PublicCloudConnectorList):
    def pre_operations(self):
        register_providers_if_needed(cmd=self.ctx)
        super().pre_operations()


class CustomizedPublicCloudConnectorShow(_PublicCloudConnectorShow):
    def pre_operations(self):
        register_providers_if_needed(cmd=self.ctx)
        super().pre_operations()


class CustomizedPublicCloudConnectorTestPermission(_PublicCloudConnectorTestPermission):
    def pre_operations(self):
        register_providers_if_needed(cmd=self.ctx)
        super().pre_operations()


class CustomizedPublicCloudConnectorUpdate(_PublicCloudConnectorUpdate):
    def pre_operations(self):
        register_providers_if_needed(cmd=self.ctx)
        super().pre_operations()


class CustomizedSolutionConfigurationCreate(_SolutionConfigurationCreate):
    def pre_operations(self):
        register_providers_if_needed(cmd=self.ctx)
        super().pre_operations()


class CustomizedSolutionConfigurationDelete(_SolutionConfigurationDelete):
    def pre_operations(self):
        register_providers_if_needed(cmd=self.ctx)
        super().pre_operations()


class CustomizedSolutionConfigurationList(_SolutionConfigurationList):
    def pre_operations(self):
        register_providers_if_needed(cmd=self.ctx)
        super().pre_operations()


class CustomizedSolutionConfigurationShow(_SolutionConfigurationShow):
    def pre_operations(self):
        register_providers_if_needed(cmd=self.ctx)
        super().pre_operations()


class CustomizedSolutionConfigurationSyncNow(_SolutionConfigurationSyncNow):
    def pre_operations(self):
        register_providers_if_needed(cmd=self.ctx)
        super().pre_operations()


class CustomizedSolutionConfigurationUpdate(_SolutionConfigurationUpdate):
    def pre_operations(self):
        register_providers_if_needed(cmd=self.ctx)
        super().pre_operations()


class CustomizedSolutionTypeList(_SolutionTypeList):
    def pre_operations(self):
        register_providers_if_needed(cmd=self.ctx)
        super().pre_operations()


class CustomizedSolutionTypeShow(_SolutionTypeShow):
    def pre_operations(self):
        register_providers_if_needed(cmd=self.ctx)
        super().pre_operations()
