# --------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
#
# Code generated by aaz-dev-tools
# --------------------------------------------------------------------------------------------

# pylint: skip-file
# flake8: noqa

from azure.cli.core.aaz import *


class Show(AAZCommand):
    """Get metric values for a single metric
    """

    _aaz_info = {
        "version": "v1",
        "resources": [
            ["data-plane:microsoft.insights", "/apps/{}/metrics/{}", "v1"],
        ]
    }

    def _handler(self, command_args):
        super()._handler(command_args)
        self._execute_operations()
        return self._output()

    _args_schema = None

    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        if cls._args_schema is not None:
            return cls._args_schema
        cls._args_schema = super()._build_arguments_schema(*args, **kwargs)

        # define Arg Group ""

        _args_schema = cls._args_schema
        _args_schema.app_id = AAZStrArg(
            options=["--app-id"],
            help="ID of the application. This is Application ID from the API Access settings blade in the Azure portal.",
            required=True,
        )
        _args_schema.metric_id = AAZStrArg(
            options=["--metric-id"],
            help="ID of the metric. This is either a standard AI metric, or an application-specific custom metric.",
            required=True,
            enum={"availabilityResults/availabilityPercentage": "availabilityResults/availabilityPercentage", "availabilityResults/duration": "availabilityResults/duration", "billing/telemetryCount": "billing/telemetryCount", "client/networkDuration": "client/networkDuration", "client/processingDuration": "client/processingDuration", "client/receiveDuration": "client/receiveDuration", "client/sendDuration": "client/sendDuration", "client/totalDuration": "client/totalDuration", "customEvents/count": "customEvents/count", "dependencies/count": "dependencies/count", "dependencies/duration": "dependencies/duration", "dependencies/failed": "dependencies/failed", "exceptions/browser": "exceptions/browser", "exceptions/count": "exceptions/count", "exceptions/server": "exceptions/server", "pageViews/count": "pageViews/count", "pageViews/duration": "pageViews/duration", "performanceCounters/exceptionsPerSecond": "performanceCounters/exceptionsPerSecond", "performanceCounters/memoryAvailableBytes": "performanceCounters/memoryAvailableBytes", "performanceCounters/processCpuPercentage": "performanceCounters/processCpuPercentage", "performanceCounters/processIOBytesPerSecond": "performanceCounters/processIOBytesPerSecond", "performanceCounters/processPrivateBytes": "performanceCounters/processPrivateBytes", "performanceCounters/processorCpuPercentage": "performanceCounters/processorCpuPercentage", "performanceCounters/requestExecutionTime": "performanceCounters/requestExecutionTime", "performanceCounters/requestsInQueue": "performanceCounters/requestsInQueue", "performanceCounters/requestsPerSecond": "performanceCounters/requestsPerSecond", "requests/count": "requests/count", "requests/duration": "requests/duration", "requests/failed": "requests/failed", "sessions/count": "sessions/count", "users/authenticated": "users/authenticated", "users/count": "users/count"},
        )
        _args_schema.aggregation = AAZListArg(
            options=["--aggregation"],
            help="The aggregation to use when computing the metric values. To retrieve more than one aggregation at a time, separate them with a comma. If no aggregation is specified, then the default aggregation for the metric is used.",
            fmt=AAZListArgFormat(
                min_length=1,
            ),
        )
        _args_schema.filter = AAZStrArg(
            options=["--filter"],
            help="An expression used to filter the results.  This value should be a valid OData filter expression where the keys of each clause should be applicable dimensions for the metric you are retrieving.",
        )
        _args_schema.interval = AAZDurationArg(
            options=["--interval"],
            help="The time interval to use when retrieving metric values. This is an ISO8601 duration. If interval is omitted, the metric value is aggregated across the entire timespan. If interval is supplied, the server may adjust the interval to a more appropriate size based on the timespan used for the query. In all cases, the actual interval used for the query is included in the response.",
        )
        _args_schema.orderby = AAZStrArg(
            options=["--orderby"],
            help="The aggregation function and direction to sort the segments by.  This value is only valid when segment is specified.",
        )
        _args_schema.segment = AAZListArg(
            options=["--segment"],
            help="The name of the dimension to segment the metric values by. This dimension must be applicable to the metric you are retrieving. To segment by more than one dimension at a time, separate them with a comma (,). In this case, the metric data will be segmented in the order the dimensions are listed in the parameter.",
            fmt=AAZListArgFormat(
                min_length=1,
            ),
        )
        _args_schema.timespan = AAZStrArg(
            options=["--timespan"],
            help="The timespan over which to retrieve metric values. This is an ISO8601 time period value. If timespan is omitted, a default time range of `PT12H` (\"last 12 hours\") is used. The actual timespan that is queried may be adjusted by the server based. In all cases, the actual time span used for the query is included in the response.",
        )
        _args_schema.top = AAZIntArg(
            options=["--top"],
            help="The number of segments to return.  This value is only valid when segment is specified.",
        )

        aggregation = cls._args_schema.aggregation
        aggregation.Element = AAZStrArg(
            enum={"avg": "avg", "count": "count", "max": "max", "min": "min", "sum": "sum", "unique": "unique"},
        )

        segment = cls._args_schema.segment
        segment.Element = AAZStrArg(
            enum={"applicationBuild": "applicationBuild", "applicationVersion": "applicationVersion", "authenticatedOrAnonymousTraffic": "authenticatedOrAnonymousTraffic", "browser": "browser", "browserVersion": "browserVersion", "city": "city", "cloudRoleName": "cloudRoleName", "cloudServiceName": "cloudServiceName", "continent": "continent", "countryOrRegion": "countryOrRegion", "deploymentId": "deploymentId", "deploymentUnit": "deploymentUnit", "deviceType": "deviceType", "environment": "environment", "hostingLocation": "hostingLocation", "instanceName": "instanceName"},
        )
        return cls._args_schema

    def _execute_operations(self):
        self.pre_operations()
        self.MetricsGet(ctx=self.ctx)()
        self.post_operations()

    @register_callback
    def pre_operations(self):
        pass

    @register_callback
    def post_operations(self):
        pass

    def _output(self, *args, **kwargs):
        result = self.deserialize_output(self.ctx.vars.instance, client_flatten=True)
        return result

    class MetricsGet(AAZHttpOperation):
        CLIENT_TYPE = "AAZMicrosoftInsightsDataPlaneClient_application_insights"

        def __call__(self, *args, **kwargs):
            request = self.make_request()
            session = self.client.send_request(request=request, stream=False, **kwargs)
            if session.http_response.status_code in [200]:
                return self.on_200(session)

            return self.on_error(session.http_response)

        @property
        def url(self):
            return self.client.format_url(
                "/v1/apps/{appId}/metrics/{metricId}",
                **self.url_parameters
            )

        @property
        def method(self):
            return "GET"

        @property
        def error_format(self):
            return "ODataV4Format"

        @property
        def url_parameters(self):
            parameters = {
                **self.serialize_url_param(
                    "appId", self.ctx.args.app_id,
                    required=True,
                ),
                **self.serialize_url_param(
                    "metricId", self.ctx.args.metric_id,
                    required=True,
                ),
            }
            return parameters

        @property
        def query_parameters(self):
            parameters = {
                **self.serialize_query_param(
                    "aggregation", self.ctx.args.aggregation,
                ),
                **self.serialize_query_param(
                    "filter", self.ctx.args.filter,
                ),
                **self.serialize_query_param(
                    "interval", self.ctx.args.interval,
                ),
                **self.serialize_query_param(
                    "orderby", self.ctx.args.orderby,
                ),
                **self.serialize_query_param(
                    "segment", self.ctx.args.segment,
                ),
                **self.serialize_query_param(
                    "timespan", self.ctx.args.timespan,
                ),
                **self.serialize_query_param(
                    "top", self.ctx.args.top,
                ),
            }
            return parameters

        @property
        def header_parameters(self):
            parameters = {
                **self.serialize_header_param(
                    "Accept", "application/json",
                ),
            }
            return parameters

        def on_200(self, session):
            data = self.deserialize_http_content(session)
            self.ctx.set_var(
                "instance",
                data,
                schema_builder=self._build_schema_on_200
            )

        _schema_on_200 = None

        @classmethod
        def _build_schema_on_200(cls):
            if cls._schema_on_200 is not None:
                return cls._schema_on_200

            cls._schema_on_200 = AAZObjectType()

            _schema_on_200 = cls._schema_on_200
            _schema_on_200.value = AAZFreeFormDictType()

            return cls._schema_on_200


class _ShowHelper:
    """Helper class for Show"""

    _schema_metrics_segment_info_read = None

    @classmethod
    def _build_schema_metrics_segment_info_read(cls, _schema):
        if cls._schema_metrics_segment_info_read is not None:
            return

        cls._schema_metrics_segment_info_read = _schema_metrics_segment_info_read = AAZFreeFormDictType()



__all__ = ["Show"]
