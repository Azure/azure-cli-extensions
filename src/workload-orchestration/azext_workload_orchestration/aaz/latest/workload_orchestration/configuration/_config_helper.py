# --------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
#
# Code generated by aaz-dev-tools
# --------------------------------------------------------------------------------------------

# pylint: skip-file
# flake8: noqa

from azure.cli.core.aaz import *


class ConfigurationHelper:
    """Helper class for workload orchestration configuration operations"""
    
    def __init__(self):
        """Initialize the configuration helper"""
        pass
    
    @staticmethod
    def getConfigurationId(hierarchy_id, client):
        """
        Get configuration ID from hierarchy ID by calling configuration reference API
        
        Args:
            hierarchy_id (str): The hierarchy ID (ARM ID of site or target)
            client: HTTP client for making the request
            
        Returns:
            str: The configuration ID from configurationResourceId field
            
        Raises:
            CLIInternalError: If configuration reference is not found or configuration doesn't exist
        """
        from azure.cli.core.azclierror import CLIInternalError
        import json
        
        # Convert hierarchy_id to string if it's an AAZ type
        hierarchy_id_str = str(hierarchy_id) if hierarchy_id else ""
        
        def try_get_config_id(lookup_id, api_version = "2025-08-01"):
            """Helper function to try getting configuration ID for a given lookup ID"""
            config_ref_url = client.format_url(
                "{hierarchyId}/providers/Microsoft.Edge/configurationreferences/default",
                hierarchyId=lookup_id
            )
            
            request = client._request("GET", config_ref_url, {
                "api-version": api_version
            }, {
                "Accept": "application/json"
            }, None, {}, None)
            
            response = client.send_request(request=request, stream=False)
            
            if response.http_response.status_code != 200:
                return None
            
            response_text = response.http_response.text()
            data = json.loads(response_text)
            configuration_id = data.get("properties", {}).get("configurationResourceId")
            
            if not configuration_id:
                return None
            
            # Verify the configuration exists
            config_url = client.format_url(
                "{configurationId}",
                configurationId=configuration_id
            )
            config_request = client._request("GET", config_url, {
                "api-version": "2025-08-01"
            }, {
                "Accept": "application/json"
            }, None, {}, None)
            
            config_response = client.send_request(request=config_request, stream=False)
            
            if config_response.http_response.status_code == 200:
                return configuration_id
            
            return None
        
        # Check if hierarchy_id is a service group-based site ID
        service_group_id = None
        if "/providers/Microsoft.Management/serviceGroups/" in hierarchy_id_str and "/providers/Microsoft.Edge/sites/" in hierarchy_id_str:
            # Extract service group ID: everything before /providers/Microsoft.Edge/sites/
            parts = hierarchy_id_str.split("/providers/Microsoft.Edge/sites/")
            if len(parts) == 2:
                service_group_id = parts[0]
        
        # Try with service group ID if it's a service group-based site
        if service_group_id:
            # Try with the original hierarchy_id first
            try:
                configuration_id = try_get_config_id(hierarchy_id_str, "2025-06-01")
                if configuration_id:
                    return configuration_id
            except Exception:
                pass
            try:
                configuration_id = try_get_config_id(service_group_id)
                if configuration_id:
                    return configuration_id
            except Exception:
                pass
        else:
            try:
                configuration_id = try_get_config_id(hierarchy_id_str)
                if configuration_id:
                    return configuration_id
            except Exception:
                pass

        
        # If we reach here, no configuration was found
        raise CLIInternalError(f"No configuration linked to this hierarchy: {hierarchy_id_str}")
    
    @staticmethod
    def getTemplateUniqueIdentifier(subscription_id, template_resource_group_name, template_name, solution_flag, client):
        """
        Get template unique identifier from template ID
        
        Args:
            subscription_id (str): The subscription ID for the template
            template_resource_group_name (str): The resource group name for the template
            template_name (str): The template name
            solution_flag (bool): True for solution template, False for configuration template
            client: HTTP client for making the request
            
        Returns:
            str: The unique identifier from template properties or template name as fallback
            
        Raises:
            CLIInternalError: If template doesn't exist
        """
        from azure.cli.core.azclierror import CLIInternalError
        
        # Build template ID based on solution flag
        if solution_flag:
            template_type = "solutionTemplates"
        else:
            template_type = "configTemplates"
        
        template_id = f"/subscriptions/{subscription_id}/resourceGroups/{template_resource_group_name}/providers/Microsoft.Edge/{template_type}/{template_name}"
        
        try:
            # Make GET request to template using client.format_url
            template_url = client.format_url(
                "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/{templateType}/{templateName}",
                subscriptionId=subscription_id,
                resourceGroupName=template_resource_group_name,
                templateType=template_type,
                templateName=template_name
            )
            request = client._request("GET", template_url, {
                "api-version": "2025-08-01"
            }, {
                "Accept": "application/json"
            }, None, {}, None) 
            
            response = client.send_request(request=request, stream=False)
            
            if response.http_response.status_code == 404:
                raise CLIInternalError(f"Template doesn't exist with template ID: {template_id}")
            elif response.http_response.status_code != 200:
                raise CLIInternalError(f"Failed to get template with ID: {template_id}")
            
            # Parse JSON response
            import json
            response_text = response.http_response.text()
            data = json.loads(response_text)
            
            unique_identifier = data.get("properties", {}).get("uniqueIdentifier")
            
            # Return unique identifier if it exists and is not empty, otherwise return template name
            if unique_identifier and unique_identifier.strip():
                return unique_identifier
            else:
                return template_name
                
        except CLIInternalError:
            # Re-raise CLI errors as-is
            raise
        except Exception as e:
            raise CLIInternalError(f"Error getting template unique identifier for template {template_id}: {str(e)}")

    @staticmethod
    def getTemplateSchema(subscription_id, resource_group, template_name, version, solution_flag, client):
        """
        Get template schema
        
        Args:
            subscription_id (str): The subscription ID for the template
            resource_group (str): The resource group name for the template  
            template_name (str): The template name
            version (str): The template version
            solution_flag (bool): True for solution template, False for configuration template
            client: HTTP client for making the request
            
        Returns:
            str: Raw schema YAML string from the template
            
        Raises:
            CLIInternalError: If schema doesn't exist or request fails
        """
        from azure.cli.core.azclierror import CLIInternalError
        
        # Build template version ID
        if solution_flag:
            template_type = "solutionTemplates"
            schema_endpoint = "solutionSchemas/default"
        else:
            template_type = "configTemplates" 
            schema_endpoint = "configTemplateSchemas/default"
        
        template_version_id = f"/subscriptions/{subscription_id}/resourceGroups/{resource_group}/providers/Microsoft.Edge/{template_type}/{template_name}/versions/{version}"
        schema_url = template_version_id + "/" + schema_endpoint
        
        try:
            # Make GET request to schema endpoint
            request = client._request("GET", schema_url, {
                "api-version": "2025-08-01"
            }, {
                "Accept": "application/json"
            }, None, {}, None)  # Add missing parameters
            
            response = client.send_request(request=request, stream=False)
            
            if response.http_response.status_code == 404:
                raise CLIInternalError(f"No Editable configs. Schema doesn't exist for template: {template_version_id}")
            elif response.http_response.status_code != 200:
                raise CLIInternalError(f"Failed to get schema for template: {template_version_id}")
            
            import json
            response_text = response.http_response.text()
            data = json.loads(response_text)
            value = data.get("properties", {}).get("value")
            
            if value is None:
                raise CLIInternalError(f"No value field found in schema for template: {template_version_id}")
            
            # Return the raw schema YAML value
            return value
                
        except CLIInternalError:
            # Re-raise CLI errors as-is
            raise
        except Exception as e:
            raise CLIInternalError(f"Error getting schema for template {template_version_id}: {str(e)}")

    @staticmethod
    def validateTemplateVersion(subscription_id, resource_group, template_name, version, solution_flag, client):
        """
        Validate that a template version exists
        
        Args:
            subscription_id (str): The subscription ID for the template
            resource_group (str): The resource group name for the template  
            template_name (str): The template name
            version (str): The template version
            solution_flag (bool): True for solution template, False for configuration template
            client: HTTP client for making the request
            
        Raises:
            CLIInternalError: If template version doesn't exist or request fails
        """
        from azure.cli.core.azclierror import CLIInternalError
        
        # Build template version ID
        if solution_flag:
            template_type = "solutionTemplates"
        else:
            template_type = "configTemplates"
        
        template_version_id = f"/subscriptions/{subscription_id}/resourceGroups/{resource_group}/providers/Microsoft.Edge/{template_type}/{template_name}/versions/{version}"
        
        try:
            # Make GET request to template version endpoint
            request = client._request("GET", template_version_id, {
                "api-version": "2025-08-01"
            }, {
                "Accept": "application/json"
            }, None, {}, None)
            
            response = client.send_request(request=request, stream=False)
            
            if response.http_response.status_code == 404:
                raise CLIInternalError(f"Template version doesn't exist: {template_version_id}")
            elif response.http_response.status_code != 200:
                raise CLIInternalError(f"Failed to validate template version: {template_version_id}. Status code: {response.http_response.status_code}")
                
        except CLIInternalError:
            # Re-raise CLI errors as-is
            raise
        except Exception as e:
            raise CLIInternalError(f"Error validating template version {template_version_id}: {str(e)}")

    @staticmethod
    def matchCapabilities(hierarchy_id, subscription_id, resource_group, template_name, client):
        """
        Validate that solution template capabilities are a subset of target capabilities
        
        Args:
            hierarchy_id (str): The hierarchy ID (ARM ID of target)
            subscription_id (str): The subscription ID for the solution template
            resource_group (str): The resource group name for the solution template
            template_name (str): The solution template name
            client: HTTP client for making the request
            
        Raises:
            CLIInternalError: If capabilities don't match or request fails
        """
        from azure.cli.core.azclierror import CLIInternalError
        import json
        
        hierarchy_id_str = str(hierarchy_id) if hierarchy_id else ""
        
        try:
            # Get target capabilities
            target_request = client._request("GET", hierarchy_id_str, {
                "api-version": "2025-08-01"
            }, {
                "Accept": "application/json"
            }, None, {}, None)
            
            target_response = client.send_request(request=target_request, stream=False)
            
            if target_response.http_response.status_code != 200:
                raise CLIInternalError(f"Failed to get target: {hierarchy_id_str}. Status code: {target_response.http_response.status_code}")
            
            target_data = json.loads(target_response.http_response.text())
            target_capabilities = target_data.get("properties", {}).get("capabilities", [])
            
            # Get solution template capabilities
            solution_template_id = f"/subscriptions/{subscription_id}/resourceGroups/{resource_group}/providers/Microsoft.Edge/solutionTemplates/{template_name}"
            
            solution_request = client._request("GET", solution_template_id, {
                "api-version": "2025-08-01"
            }, {
                "Accept": "application/json"
            }, None, {}, None)
            
            solution_response = client.send_request(request=solution_request, stream=False)
            
            if solution_response.http_response.status_code != 200:
                raise CLIInternalError(f"Failed to get solution template: {solution_template_id}. Status code: {solution_response.http_response.status_code}")
            
            solution_data = json.loads(solution_response.http_response.text())
            solution_capabilities = solution_data.get("properties", {}).get("capabilities", [])
            
            # Check that solution capabilities are a subset of target capabilities (case-insensitive)
            target_capability_set = set(cap.lower() for cap in target_capabilities)
            solution_capability_set = set(cap.lower() for cap in solution_capabilities)
            
            if not solution_capability_set.issubset(target_capability_set):
                missing_capabilities = solution_capability_set - target_capability_set
                raise CLIInternalError(f"Solution template capabilities are not a subset of target capabilities. Missing capabilities: {', '.join(missing_capabilities)}")
                
        except CLIInternalError:
            # Re-raise CLI errors as-is
            raise
        except Exception as e:
            raise CLIInternalError(f"Error validating capabilities match: {str(e)}")

    @staticmethod
    def checkLinking(hierarchy_id, subscription_id, resource_group, template_name, client):
        """
        Check if the config template is linked to the provided hierarchy
        
        Args:
            hierarchy_id (str): The hierarchy ID to check for linking
            subscription_id (str): The subscription ID for the config template
            resource_group (str): The resource group name for the config template
            template_name (str): The config template name
            client: HTTP client for making the request
            
        Raises:
            CLIInternalError: If template is not linked to the hierarchy or request fails
        """
        from azure.cli.core.azclierror import CLIInternalError
        import json
        
        hierarchy_id_str = str(hierarchy_id) if hierarchy_id else ""
        
        try:
            # Build config template ID
            config_template_id = f"/subscriptions/{subscription_id}/resourceGroups/{resource_group}/providers/Microsoft.Edge/configTemplates/{template_name}"
            
            # Get all configTemplateMetadatas for this config template
            metadata_url = f"{config_template_id}/configTemplateMetadatas"
            
            metadata_request = client._request("GET", metadata_url, {
                "api-version": "2025-08-01"
            }, {
                "Accept": "application/json"
            }, None, {}, None)
            
            metadata_response = client.send_request(request=metadata_request, stream=False)
            
            if metadata_response.http_response.status_code != 200:
                raise CLIInternalError(f"Failed to get config template metadatas: {metadata_url}. Status code: {metadata_response.http_response.status_code}")
            
            metadata_data = json.loads(metadata_response.http_response.text())
            metadatas = metadata_data.get("value", [])
            
            # Check if hierarchy_id exists in any linkedHierarchies (case-insensitive)
            hierarchy_found = False
            hierarchy_id_lower = hierarchy_id_str.lower()
            for metadata in metadatas:
                linked_hierarchies = metadata.get("properties", {}).get("linkedHierarchies", [])
                for linked_hierarchy in linked_hierarchies:
                    hierarchy_ids = linked_hierarchy.get("hierarchyIds", [])
                    if any(hid.lower() == hierarchy_id_lower for hid in hierarchy_ids):
                        hierarchy_found = True
                        break
                if hierarchy_found:
                    break
            
            if not hierarchy_found:
                raise CLIInternalError(f"Config template '{template_name}' is not linked to hierarchy: {hierarchy_id_str}. Please link the config template to this hierarchy first using the 'az workload-orchestration config-template link' command.")
                
        except CLIInternalError:
            # Re-raise CLI errors as-is
            raise
        except Exception as e:
            raise CLIInternalError(f"Error checking config template linking: {str(e)}")

    # Add your helper methods here


__all__ = ["ConfigurationHelper"]