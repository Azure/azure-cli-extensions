# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------
# pylint: disable=too-many-lines
# pylint: disable=unused-argument
# pylint: disable=protected-access
from knack.util import CLIError
from azure.cli.core.aaz import register_callback
from .aaz.latest.network.manager.group.static_member import Create as _GroupStaticMemberCreate
from .aaz.latest.network.manager.scope_connection import Create as _ScopeConnectionCreate
from .aaz.latest.network.manager.connection.management_group import Create as _ConnectionManagementGroupCreate
from .aaz.latest.network.manager.connection.subscription import Create as _ConnectionSubscriptionCreate
from .aaz.latest.network.manager.connect_config import Create as _ConnectConfigCreate
from .aaz.latest.network.manager.connect_config import Update as _ConnectConfigUpdate
from .aaz.latest.network.manager.ipam_pool.static_cidr import Update as _StaticCidrUpdate


def network_manager_create(cmd,
                           resource_group_name,
                           network_manager_name,
                           location,
                           network_manager_scopes,
                           network_manager_scope_accesses,
                           id_=None,
                           tags=None,
                           description=None):
    from .aaz.latest.network.manager import Create as _NetworkManagerCreate
    parameters = {}
    parameters['resource_group'] = resource_group_name
    parameters['network_manager_name'] = network_manager_name
    parameters['id'] = id_
    parameters['location'] = location
    parameters['tags'] = tags
    parameters['description'] = description
    parameters['network_manager_scopes'] = network_manager_scopes
    parameters['network_manager_scope_accesses'] = network_manager_scope_accesses
    return _NetworkManagerCreate(cli_ctx=cmd.cli_ctx)(command_args=parameters)


def network_manager_update(cmd,
                           resource_group_name,
                           network_manager_name,
                           id_=None,
                           location=None,
                           tags=None,
                           description=None,
                           network_manager_scopes=None,
                           network_manager_scope_accesses=None):
    from .aaz.latest.network.manager import Update as _NetworkManagerUpdate
    parameters = {}
    parameters['resource_group'] = resource_group_name
    parameters['network_manager_name'] = network_manager_name
    if id_ is not None:
        parameters['id'] = id_
    if location is not None:
        parameters['location'] = location
    if tags is not None:
        parameters['tags'] = tags
    if description is not None:
        parameters['description'] = description
    if network_manager_scopes is not None:
        parameters['network_manager_scopes'] = network_manager_scopes
    if network_manager_scope_accesses is not None:
        parameters['network_manager_scope_accesses'] = network_manager_scope_accesses
    return _NetworkManagerUpdate(cli_ctx=cmd.cli_ctx)(command_args=parameters)


def network_manager_connect_config_create(cmd,
                                          resource_group_name,
                                          network_manager_name,
                                          configuration_name,
                                          applies_to_groups,
                                          connectivity_topology,
                                          description=None,
                                          hub=None,
                                          is_global=None,
                                          delete_existing_peering=None):
    if connectivity_topology == 'HubAndSpoke' and hub is None:
        raise CLIError("if 'HubAndSpoke' is the topolopy seleted,'--hub' is required")
    connectivity_configuration = {}
    connectivity_configuration['resource_group'] = resource_group_name
    connectivity_configuration['network_manager_name'] = network_manager_name
    connectivity_configuration['configuration_name'] = configuration_name
    connectivity_configuration['description'] = description
    connectivity_configuration['connectivity_topology'] = connectivity_topology
    connectivity_configuration['hubs'] = hub
    if is_global is not None:
        connectivity_configuration['is_global'] = 'True' if is_global else 'False'
    connectivity_configuration['applies_to_groups'] = applies_to_groups
    if delete_existing_peering is not None:
        connectivity_configuration['delete_existing_peering'] = 'True' if delete_existing_peering else 'False'
    return ConnectConfigCreate(cli_ctx=cmd.cli_ctx)(command_args=connectivity_configuration)


def network_manager_connect_config_update(cmd,
                                          resource_group_name,
                                          network_manager_name,
                                          configuration_name,
                                          description=None,
                                          hub=None,
                                          is_global=None,
                                          applies_to_groups=None,
                                          delete_existing_peering=None):
    connectivity_configuration = {}
    connectivity_configuration['resource_group'] = resource_group_name
    connectivity_configuration['network_manager_name'] = network_manager_name
    connectivity_configuration['configuration_name'] = configuration_name
    if description is not None:
        connectivity_configuration['description'] = description
    if hub is not None:
        connectivity_configuration['hubs'] = hub
    if is_global is not None:
        connectivity_configuration['is_global'] = 'True' if is_global else 'False'
    if applies_to_groups is not None:
        connectivity_configuration['applies_to_groups'] = applies_to_groups
    if delete_existing_peering is not None:
        connectivity_configuration['delete_existing_peering'] = 'True' if delete_existing_peering else 'False'
    return ConnectConfigUpdate(cli_ctx=cmd.cli_ctx)(command_args=connectivity_configuration)


def network_manager_admin_rule_collection_create(cmd,
                                                 resource_group_name,
                                                 network_manager_name,
                                                 configuration_name,
                                                 rule_collection_name,
                                                 applies_to_groups,
                                                 description=None):
    from .aaz.latest.network.manager.security_admin_config.rule_collection import Create as _RuleCollectionCreate
    rule_collection = {}
    rule_collection['resource_group'] = resource_group_name
    rule_collection['network_manager_name'] = network_manager_name
    rule_collection['configuration_name'] = configuration_name
    rule_collection['rule_collection_name'] = rule_collection_name
    rule_collection['description'] = description
    rule_collection['applies_to_groups'] = applies_to_groups
    return _RuleCollectionCreate(cli_ctx=cmd.cli_ctx)(command_args=rule_collection)


def network_manager_admin_rule_collection_update(cmd,
                                                 resource_group_name,
                                                 network_manager_name,
                                                 configuration_name,
                                                 rule_collection_name,
                                                 description=None,
                                                 applies_to_groups=None):
    from .aaz.latest.network.manager.security_admin_config.rule_collection import Update as _RuleCollectionUpdate
    rule_collection = {}
    rule_collection['resource_group'] = resource_group_name
    rule_collection['network_manager_name'] = network_manager_name
    rule_collection['configuration_name'] = configuration_name
    rule_collection['rule_collection_name'] = rule_collection_name
    if description is not None:
        rule_collection["description"] = description
    if applies_to_groups is not None:
        rule_collection["applies_to_groups"] = applies_to_groups
    return _RuleCollectionUpdate(cli_ctx=cmd.cli_ctx)(command_args=rule_collection)


def network_manager_admin_rule_create(cmd,
                                      resource_group_name,
                                      network_manager_name,
                                      configuration_name,
                                      rule_collection_name,
                                      rule_name,
                                      protocol,
                                      access,
                                      priority,
                                      direction,
                                      kind="Custom",
                                      description=None,
                                      sources=None,
                                      destinations=None,
                                      source_port_ranges=None,
                                      destination_port_ranges=None,
                                      flag=None):
    from .aaz.latest.network.manager.security_admin_config.rule_collection.rule import Create as _RuleCreate
    rule = {}
    rule['resource_group'] = resource_group_name
    rule['network_manager_name'] = network_manager_name
    rule['configuration_name'] = configuration_name
    rule['rule_collection_name'] = rule_collection_name
    rule['rule_name'] = rule_name
    if kind == "Default" or flag is not None:
        rule['default'] = {}
        rule['default']['flag'] = flag
    else:
        rule['custom'] = {}
        rule['custom']['description'] = description
        rule['custom']['protocol'] = protocol
        rule['custom']['sources'] = sources
        rule['custom']['destinations'] = destinations
        rule['custom']['source_port_ranges'] = source_port_ranges
        rule['custom']['destination_port_ranges'] = destination_port_ranges
        rule['custom']['access'] = access
        rule['custom']['priority'] = priority
        rule['custom']['direction'] = direction
    return _RuleCreate(cli_ctx=cmd.cli_ctx)(command_args=rule)


def network_manager_admin_rule_update(cmd,
                                      resource_group_name,
                                      network_manager_name,
                                      configuration_name,
                                      rule_collection_name,
                                      rule_name,
                                      kind=None,
                                      description=None,
                                      protocol=None,
                                      sources=None,
                                      destinations=None,
                                      source_port_ranges=None,
                                      destination_port_ranges=None,
                                      access=None,
                                      priority=None,
                                      direction=None,
                                      flag=None):
    from .aaz.latest.network.manager.security_admin_config.rule_collection.rule import Update as _RuleUpdate
    rule = {}
    rule['resource_group'] = resource_group_name
    rule['network_manager_name'] = network_manager_name
    rule['configuration_name'] = configuration_name
    rule['rule_collection_name'] = rule_collection_name
    rule['rule_name'] = rule_name
    if kind == "Default" or flag is not None:
        rule['default'] = {}
        if flag is not None:
            rule['default']['flag'] = flag
    else:
        rule['custom'] = {}
        if description is not None:
            rule['custom']['description'] = description
        if protocol is not None:
            rule['custom']['protocol'] = protocol
        if sources is not None:
            rule['custom']['sources'] = sources
        if destinations is not None:
            rule['custom']['destinations'] = destinations
        if source_port_ranges is not None:
            rule['custom']['source_port_ranges'] = source_port_ranges
        if destination_port_ranges is not None:
            rule['custom']['destination_port_ranges'] = destination_port_ranges
        if access is not None:
            rule['custom']['access'] = access
        if priority is not None:
            rule['custom']['priority'] = priority
        if direction is not None:
            rule['custom']['direction'] = direction
    return _RuleUpdate(cli_ctx=cmd.cli_ctx)(command_args=rule)


class GroupStaticMemberCreate(_GroupStaticMemberCreate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZResourceIdArgFormat
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.resource_id._fmt = AAZResourceIdArgFormat(
            template="/subscriptions/{subscription}/resourceGroups/{resource_group}/providers/Microsoft.Network/"
                     "virtualNetworks/{}",
        )
        args_schema.resource_id._required = True
        return args_schema


class ScopeConnectionCreate(_ScopeConnectionCreate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.resource_id._required = True
        args_schema.tenant_id._required = True
        return args_schema


class ConnectionSubscriptionCreate(_ConnectionSubscriptionCreate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.network_manager_id._required = True
        return args_schema


class ConnectionManagementGroupCreate(_ConnectionManagementGroupCreate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.network_manager_id._required = True
        return args_schema


class ConnectConfigCreate(_ConnectConfigCreate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZResourceIdArgFormat
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.hubs._element.resource_id._fmt = AAZResourceIdArgFormat(
            template="/subscriptions/{subscription}/resourceGroups/{resource_group}/providers/Microsoft.Network/"
                     "virtualNetworks/{}",
        )
        return args_schema


class ConnectConfigUpdate(_ConnectConfigUpdate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZResourceIdArgFormat
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.hubs._element.resource_id._fmt = AAZResourceIdArgFormat(
            template="/subscriptions/{subscription}/resourceGroups/{resource_group}/providers/Microsoft.Network/"
                     "virtualNetworks/{}",
        )
        return args_schema


class StaticCidrUpdate(_StaticCidrUpdate):
    """Custom Static CIDR Update command with conflict resolution logic"""
    
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        """Make arguments nullable for proper conflict resolution"""
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        return args_schema

    class InstanceUpdateByJson(_StaticCidrUpdate.InstanceUpdateByJson):
        """Custom instance update logic that only sets properties provided by the user"""
        
        def _update_instance(self, instance):
            from azure.cli.core.aaz import AAZObjectType, AAZListType, AAZStrType
            
            _instance_value, _builder = self.new_content_builder(
                self.ctx.args,
                value=instance,
                typ=AAZObjectType
            )
            _builder.set_prop("properties", AAZObjectType)

            properties = _builder.get(".properties")
            if properties is not None:
                address_prefixes_provided = (
                    self.ctx.args.address_prefixes is not None and 
                    len(self.ctx.args.address_prefixes) > 0
                )
                print(f"DEBUG: address_prefixes value: {self.ctx.args.address_prefixes}")
                print(f"DEBUG: address_prefixes_provided: {address_prefixes_provided}")
                address_prefixes_undefined = str(self.ctx.args.address_prefixes).strip() == "Undefined"
                print(f"DEBUG: address_prefixes_undefined: {address_prefixes_undefined}")

                num_ip_provided = (
                    self.ctx.args.number_of_ip_addresses_to_allocate is not None and
                    str(self.ctx.args.number_of_ip_addresses_to_allocate).strip() != ""
                )
                print(f"DEBUG: number_of_ip_addresses_to_allocate value: {self.ctx.args.number_of_ip_addresses_to_allocate}")
                print(f"DEBUG: number_of_ip_addresses_to_allocate type: {type(self.ctx.args.number_of_ip_addresses_to_allocate)}")
                print(f"DEBUG: number_of_ip_addresses_to_allocate str: '{str(self.ctx.args.number_of_ip_addresses_to_allocate)}'")
                print(f"DEBUG: num_ip_provided: {num_ip_provided}")
                
                # Check if the value is not provided by user
                num_ip_is_undefined = str(self.ctx.args.number_of_ip_addresses_to_allocate).strip() == "Undefined"
                print(f"DEBUG: num_ip_is_undefined: {num_ip_is_undefined}")
                
                num_ip_is_zero_or_empty = (
                    num_ip_is_undefined or
                    self.ctx.args.number_of_ip_addresses_to_allocate is None or
                    str(self.ctx.args.number_of_ip_addresses_to_allocate).strip() in ["", "0"]
                )
                print(f"DEBUG: num_ip_is_zero_or_empty: {num_ip_is_zero_or_empty}")
                
                address_prefixes_is_empty = (
                    self.ctx.args.address_prefixes is None or
                    len(self.ctx.args.address_prefixes) == 0 or
                    (len(self.ctx.args.address_prefixes) == 1 and str(self.ctx.args.address_prefixes[0]).strip() == "")
                )
                print(f"DEBUG: address_prefixes_is_empty: {address_prefixes_is_empty}")
                
                # Simplified logic: only set the property that was actually provided by the user
                if address_prefixes_provided and (num_ip_is_undefined or num_ip_is_zero_or_empty):
                    print("DEBUG: Taking Logic 1 - User provided address_prefixes, num_ip is Undefined")
                    properties.set_prop("addressPrefixes", AAZListType, ".address_prefixes")
                    self.ctx.args.number_of_ip_addresses_to_allocate = "0"
                    properties.set_prop("numberOfIPAddressesToAllocate", AAZStrType, ".number_of_ip_addresses_to_allocate")
           
                elif num_ip_provided and (address_prefixes_undefined or address_prefixes_is_empty):
                    print("DEBUG: Taking Logic 2 - User provided number_of_ip_addresses_to_allocate only")
                    properties.set_prop("numberOfIPAddressesToAllocate", AAZStrType, ".number_of_ip_addresses_to_allocate")
                    self.ctx.args.address_prefixes = []
                    properties.set_prop("addressPrefixes", AAZListType, ".address_prefixes")

                elif address_prefixes_provided and num_ip_provided:
                    print("DEBUG: Taking Logic 3 - User provided both (will fail as expected)")
                    properties.set_prop("addressPrefixes", AAZListType, ".address_prefixes")
                    properties.set_prop("numberOfIPAddressesToAllocate", AAZStrType, ".number_of_ip_addresses_to_allocate")
                
                # Always allow description updates
                properties.set_prop("description", AAZStrType, ".description")

            address_prefixes = _builder.get(".properties.addressPrefixes")
            if address_prefixes is not None:
                address_prefixes.set_elements(AAZStrType, ".")

            #print value of address_prefixes
            print(f"DEBUG: address_prefixes: {address_prefixes}")

            return _instance_value
            
    class InstanceUpdateByGeneric(_StaticCidrUpdate.InstanceUpdateByGeneric):
        """Override generic update to prevent it from overriding our custom logic"""
        
        def __call__(self, *args, **kwargs):
            # Do nothing - our custom InstanceUpdateByJson already handled everything
            print("DEBUG: InstanceUpdateByGeneric - doing nothing (custom logic already applied)")
            pass
