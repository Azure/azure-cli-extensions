# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------
# pylint: disable=too-many-lines
# pylint: disable=unused-argument
# pylint: disable=protected-access
from knack.util import CLIError
from .aaz.latest.network.manager.group.static_member import Create as _GroupStaticMemberCreate
from .aaz.latest.network.manager.scope_connection import Create as _ScopeConnectionCreate
from .aaz.latest.network.manager.connection.management_group import Create as _ConnectionManagementGroupCreate
from .aaz.latest.network.manager.connection.subscription import Create as _ConnectionSubscriptionCreate
from .aaz.latest.network.manager.connect_config import Create as _ConnectConfigCreate
from .aaz.latest.network.manager.connect_config import Update as _ConnectConfigUpdate


def network_manager_create(cmd,
                           resource_group_name,
                           network_manager_name,
                           location,
                           network_manager_scopes,
                           network_manager_scope_accesses,
                           id_=None,
                           tags=None,
                           description=None):
    from .aaz.latest.network.manager import Create as _NetworkManagerCreate
    parameters = {}
    parameters['resource_group'] = resource_group_name
    parameters['network_manager_name'] = network_manager_name
    parameters['id'] = id_
    parameters['location'] = location
    parameters['tags'] = tags
    parameters['description'] = description
    parameters['network_manager_scopes'] = network_manager_scopes
    parameters['network_manager_scope_accesses'] = network_manager_scope_accesses
    return _NetworkManagerCreate(cli_ctx=cmd.cli_ctx)(command_args=parameters)


def network_manager_update(cmd,
                           resource_group_name,
                           network_manager_name,
                           id_=None,
                           location=None,
                           tags=None,
                           description=None,
                           network_manager_scopes=None,
                           network_manager_scope_accesses=None):
    from .aaz.latest.network.manager import Update as _NetworkManagerUpdate
    parameters = {}
    parameters['resource_group'] = resource_group_name
    parameters['network_manager_name'] = network_manager_name
    if id_ is not None:
        parameters['id'] = id_
    if location is not None:
        parameters['location'] = location
    if tags is not None:
        parameters['tags'] = tags
    if description is not None:
        parameters['description'] = description
    if network_manager_scopes is not None:
        parameters['network_manager_scopes'] = network_manager_scopes
    if network_manager_scope_accesses is not None:
        parameters['network_manager_scope_accesses'] = network_manager_scope_accesses
    return _NetworkManagerUpdate(cli_ctx=cmd.cli_ctx)(command_args=parameters)


def network_manager_connect_config_create(cmd,
                                          resource_group_name,
                                          network_manager_name,
                                          configuration_name,
                                          applies_to_groups,
                                          connectivity_topology,
                                          description=None,
                                          hub=None,
                                          is_global=None,
                                          delete_existing_peering=None):
    if connectivity_topology == 'HubAndSpoke' and hub is None:
        raise CLIError("if 'HubAndSpoke' is the topolopy seleted,'--hub' is required")
    connectivity_configuration = {}
    connectivity_configuration['resource_group'] = resource_group_name
    connectivity_configuration['network_manager_name'] = network_manager_name
    connectivity_configuration['configuration_name'] = configuration_name
    connectivity_configuration['description'] = description
    connectivity_configuration['connectivity_topology'] = connectivity_topology
    connectivity_configuration['hubs'] = hub
    if is_global is not None:
        connectivity_configuration['is_global'] = 'True' if is_global else 'False'
    connectivity_configuration['applies_to_groups'] = applies_to_groups
    if delete_existing_peering is not None:
        connectivity_configuration['delete_existing_peering'] = 'True' if delete_existing_peering else 'False'
    return ConnectConfigCreate(cli_ctx=cmd.cli_ctx)(command_args=connectivity_configuration)


def network_manager_connect_config_update(cmd,
                                          resource_group_name,
                                          network_manager_name,
                                          configuration_name,
                                          description=None,
                                          hub=None,
                                          is_global=None,
                                          applies_to_groups=None,
                                          delete_existing_peering=None):
    connectivity_configuration = {}
    connectivity_configuration['resource_group'] = resource_group_name
    connectivity_configuration['network_manager_name'] = network_manager_name
    connectivity_configuration['configuration_name'] = configuration_name
    if description is not None:
        connectivity_configuration['description'] = description
    if hub is not None:
        connectivity_configuration['hubs'] = hub
    if is_global is not None:
        connectivity_configuration['is_global'] = 'True' if is_global else 'False'
    if applies_to_groups is not None:
        connectivity_configuration['applies_to_groups'] = applies_to_groups
    if delete_existing_peering is not None:
        connectivity_configuration['delete_existing_peering'] = 'True' if delete_existing_peering else 'False'
    return ConnectConfigUpdate(cli_ctx=cmd.cli_ctx)(command_args=connectivity_configuration)


def network_manager_admin_rule_collection_create(cmd,
                                                 resource_group_name,
                                                 network_manager_name,
                                                 configuration_name,
                                                 rule_collection_name,
                                                 applies_to_groups,
                                                 description=None):
    from .aaz.latest.network.manager.security_admin_config.rule_collection import Create as _RuleCollectionCreate
    rule_collection = {}
    rule_collection['resource_group'] = resource_group_name
    rule_collection['network_manager_name'] = network_manager_name
    rule_collection['configuration_name'] = configuration_name
    rule_collection['rule_collection_name'] = rule_collection_name
    rule_collection['description'] = description
    rule_collection['applies_to_groups'] = applies_to_groups
    return _RuleCollectionCreate(cli_ctx=cmd.cli_ctx)(command_args=rule_collection)


def network_manager_admin_rule_collection_update(cmd,
                                                 resource_group_name,
                                                 network_manager_name,
                                                 configuration_name,
                                                 rule_collection_name,
                                                 description=None,
                                                 applies_to_groups=None):
    from .aaz.latest.network.manager.security_admin_config.rule_collection import Update as _RuleCollectionUpdate
    rule_collection = {}
    rule_collection['resource_group'] = resource_group_name
    rule_collection['network_manager_name'] = network_manager_name
    rule_collection['configuration_name'] = configuration_name
    rule_collection['rule_collection_name'] = rule_collection_name
    if description is not None:
        rule_collection["description"] = description
    if applies_to_groups is not None:
        rule_collection["applies_to_groups"] = applies_to_groups
    return _RuleCollectionUpdate(cli_ctx=cmd.cli_ctx)(command_args=rule_collection)


def network_manager_admin_rule_create(cmd,
                                      resource_group_name,
                                      network_manager_name,
                                      configuration_name,
                                      rule_collection_name,
                                      rule_name,
                                      kind,
                                      protocol,
                                      access,
                                      priority,
                                      direction,
                                      description=None,
                                      sources=None,
                                      destinations=None,
                                      source_port_ranges=None,
                                      destination_port_ranges=None,
                                      flag=None):
    from .aaz.latest.network.manager.security_admin_config.rule_collection.rule import Create as _RuleCreate
    rule = {}
    rule['resource_group'] = resource_group_name
    rule['network_manager_name'] = network_manager_name
    rule['configuration_name'] = configuration_name
    rule['rule_collection_name'] = rule_collection_name
    rule['rule_name'] = rule_name
    if kind == "Default" or flag is not None:
        rule['default'] = {}
        rule['default']['flag'] = flag
    else:
        rule['custom'] = {}
        rule['custom']['description'] = description
        rule['custom']['protocol'] = protocol
        rule['custom']['sources'] = sources
        rule['custom']['destinations'] = destinations
        rule['custom']['source_port_ranges'] = source_port_ranges
        rule['custom']['destination_port_ranges'] = destination_port_ranges
        rule['custom']['access'] = access
        rule['custom']['priority'] = priority
        rule['custom']['direction'] = direction
    return _RuleCreate(cli_ctx=cmd.cli_ctx)(command_args=rule)


def network_manager_admin_rule_update(cmd,
                                      resource_group_name,
                                      network_manager_name,
                                      configuration_name,
                                      rule_collection_name,
                                      rule_name,
                                      kind=None,
                                      description=None,
                                      protocol=None,
                                      sources=None,
                                      destinations=None,
                                      source_port_ranges=None,
                                      destination_port_ranges=None,
                                      access=None,
                                      priority=None,
                                      direction=None,
                                      flag=None):
    from .aaz.latest.network.manager.security_admin_config.rule_collection.rule import Update as _RuleUpdate
    rule = {}
    rule['resource_group'] = resource_group_name
    rule['network_manager_name'] = network_manager_name
    rule['configuration_name'] = configuration_name
    rule['rule_collection_name'] = rule_collection_name
    rule['rule_name'] = rule_name
    if kind == "Default" or flag is not None:
        rule['default'] = {}
        if flag is not None:
            rule['default']['flag'] = flag
    else:
        rule['custom'] = {}
        if description is not None:
            rule['custom']['description'] = description
        if protocol is not None:
            rule['custom']['protocol'] = protocol
        if sources is not None:
            rule['custom']['sources'] = sources
        if destinations is not None:
            rule['custom']['destinations'] = destinations
        if source_port_ranges is not None:
            rule['custom']['source_port_ranges'] = source_port_ranges
        if destination_port_ranges is not None:
            rule['custom']['destination_port_ranges'] = destination_port_ranges
        if access is not None:
            rule['custom']['access'] = access
        if priority is not None:
            rule['custom']['priority'] = priority
        if direction is not None:
            rule['custom']['direction'] = direction
    return _RuleUpdate(cli_ctx=cmd.cli_ctx)(command_args=rule)


class GroupStaticMemberCreate(_GroupStaticMemberCreate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZResourceIdArgFormat
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.resource_id._fmt = AAZResourceIdArgFormat(
            template="/subscriptions/{subscription}/resourceGroups/{resource_group}/providers/Microsoft.Network/"
                     "virtualNetworks/{}",
        )
        args_schema.resource_id._required = True
        return args_schema


class ScopeConnectionCreate(_ScopeConnectionCreate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.resource_id._required = True
        args_schema.tenant_id._required = True
        return args_schema


class ConnectionSubscriptionCreate(_ConnectionSubscriptionCreate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.network_manager_id._required = True
        return args_schema


class ConnectionManagementGroupCreate(_ConnectionManagementGroupCreate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.network_manager_id._required = True
        return args_schema


class ConnectConfigCreate(_ConnectConfigCreate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZResourceIdArgFormat
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.hubs._element.resource_id._fmt = AAZResourceIdArgFormat(
            template="/subscriptions/{subscription}/resourceGroups/{resource_group}/providers/Microsoft.Network/"
                     "virtualNetworks/{}",
        )
        return args_schema


class ConnectConfigUpdate(_ConnectConfigUpdate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZResourceIdArgFormat
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.hubs._element.resource_id._fmt = AAZResourceIdArgFormat(
            template="/subscriptions/{subscription}/resourceGroups/{resource_group}/providers/Microsoft.Network/"
                     "virtualNetworks/{}",
        )
        return args_schema
