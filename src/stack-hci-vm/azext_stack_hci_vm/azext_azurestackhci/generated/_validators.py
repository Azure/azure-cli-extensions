# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------
from knack.util import CLIError
from msrestazure.tools import parse_resource_id
import re
import ipaddress
from ._client_factory import cf_galleryimage, cf_virtualnetwork

default_ip_allocation_method = "Dynamic"
all_digits_regex = "^[0-9]+$"
windows_not_allowed_chars_regex = "[\\\\`~!@#$%^&*()=+_\[\]\{\}|;:.'\",<>/?]"
linux_not_allowed_chars_regex = "[\\\\`~!@#$%^&*()=+_\[\]\{\}|;:'\",<>/?]"
windows_computername_maxlength = 15
linux_computername_maxlength = 64

def vm_create_validator(cmd, namespace):
	"""
	Validates parameters for vm creation operation
	"""
	os_profile = namespace.os_profile or dict()	
	enable_gm_flag_set = False
	if 'linuxConfiguration' in os_profile and os_profile['linuxConfiguration'] is not None:
		if 'provisionVMAgent' in os_profile['linuxConfiguration']:
			enable_gm_flag_set = enable_gm_flag_set or bool(os_profile['linuxConfiguration']['provisionVMAgent'])
	if 'windowsConfiguration' in os_profile and os_profile['windowsConfiguration'] is not None:
		if 'provisionVMAgent' in os_profile['windowsConfiguration']:
			enable_gm_flag_set = enable_gm_flag_set or bool(os_profile['windowsConfiguration']['provisionVMAgent'])

	enable_gm_flag_set = enable_gm_flag_set or not bool(namespace.disable_vm_management)

	is_username_provided = bool(os_profile.get('adminUsername', None) or namespace.admin_username)
	is_password_provided = bool(os_profile.get('adminPassword', None) or namespace.admin_password)

	if enable_gm_flag_set == True and not (is_username_provided and is_password_provided):
		raise CLIError('Admin username and password must be provided for enabling Guest Mangement. For disabling Guest Management, use --disable-vm-management')

	osprofile_ostype = os_profile.get('osType', None)
	osdisk_id = namespace.os_disk
	computer_name = namespace.computer_name
	ostype = osprofile_ostype

	if osdisk_id and osprofile_ostype is None:
			raise CLIError("Os type must be provided if --os-disk is provided. "
					"To provide os type, use this format, --os-profile '{\\\"osType\\\":\\\"Windows\\\"}'")

	if namespace.image_reference:
		res = parse_resource_id(namespace.image_reference)
		# Use resource_group of image if full resource id is provided; otherwise use the global one
		galleryimage = _fetch_galleryimage(cmd.cli_ctx, res.get('resource_group', namespace.resource_group_name), res['name'])
		galleryimage_os_type = galleryimage.properties.os_type		

		if osprofile_ostype and galleryimage_os_type:
			if osprofile_ostype.lower() != galleryimage_os_type.lower():
				raise CLIError("The os type provided is not the correct os type of the gallery image, "
						"the os type of this virtual machine should be {}".format(galleryimage_os_type))

		ostype = galleryimage_os_type or osprofile_ostype
		if ostype:
			ostype = ostype.lower()

	if enable_gm_flag_set and not namespace.allow_password_auth:
		if ostype is None:
			raise CLIError("Please provide osType if you are enabling VM Management. To provide osType, use this format --os-profile '{\\\"osType\\\":\\\"Windows\\\"}")
		elif ostype == 'linux':
			raise CLIError("Guest Management for Azure Stack HCI VMs is currently in Preview. "
				"This command needs password-based authentication for the created Linux VM. Use --allow-password-auth"
				"\nFor disabling Guest Management, use --disable-vm-management")

	_validate_computer_name(computer_name, ostype)

def _fetch_galleryimage(cli_ctx, resource_group, name):
	image_client = cf_galleryimage(cli_ctx=cli_ctx)

	img = image_client.retrieve(resource_group, name)
	return img

def _validate_computer_name(computer_name, ostype):
	if computer_name and ostype:
		ostype = ostype.lower()
		if ostype == 'windows':
			if len(computer_name) > windows_computername_maxlength or re.search(all_digits_regex, computer_name) or re.search(windows_not_allowed_chars_regex, computer_name):
				raise CLIError("Windows computer name cannot be more than 15 characters long, be entirely numeric, or contain these characters: ` ~ ! @ # $ % ^ & * ( ) = + _ [ ] { } \\ | ; : ' . \" , < > / ?")
		elif ostype == 'linux':
			if len(computer_name) > linux_computername_maxlength or re.search(linux_not_allowed_chars_regex, computer_name):
				raise CLIError("Linux host name cannot exceed 64 characters in length or contain these characters: ` ~ ! @ # $ % ^ & * ( ) = + _ [ ] { } \\ | ; : ' \" , < > / ?")


def vnet_create_validator(cmd, namespace):
	"""
	Validates parameters for vnic creation operation
	"""

	routes = namespace.routes or dict()
	if routes:
		default_gateway = _get_default_gateway_from_routes_dict(routes)
		if default_gateway and namespace.gateway:
			raise CLIError("Please provide either --gateway or a route with address_prefix 0.0.0.0/0, not both")
	_validate_vnet_parameters(namespace)


def _validate_vnet_parameters(namespace):
	"""
	Validates conditions for Static/Dynamic allocation for virtualnetwork
	"""


	if namespace.subnets:
		for subnet in namespace.subnets:
			_validate_subnet(subnet)

	if namespace.ip_allocation_method == "Static":
		# Validate Static-IP conditions
		if not (bool(namespace.address_prefix) | bool(namespace.subnets)):
			raise CLIError("Address-prefix must be provided if --ip-allocation-method is Static. Please use --address-prefix or --subnets to provide address prefix for virtualnetwork")

		if namespace.address_prefix and not any((namespace.ip_pools, namespace.ip_pool_start, namespace.ip_pool_end)):
			# Validate only address-prefix when ip-pools is not provided
			_validate_cidr(namespace.address_prefix)

		# Validate IP-Pools from --ip-pools parameter
		_validate_ip_pools(namespace.address_prefix, namespace.ip_pools)

		# Validate IP-Pools from --ip-pool-start / --ip-pool-end parameters
		if namespace.ip_pool_start and namespace.ip_pool_end:
			ip_pools = [{'start' : namespace.ip_pool_start, 'end': namespace.ip_pool_end}]
			_validate_ip_pools(namespace.address_prefix, ip_pools)
		elif bool(namespace.ip_pool_start) ^ bool(namespace.ip_pool_end):
				raise CLIError("Missing --ip-pool-start or --ip-pool-end. Both the parameters need to be provided together")

		_validate_dns_servers(namespace.dns_servers)
	else:
		# Validate Dynamic-IP conditions
		if any((namespace.address_prefix, namespace.ip_pools,  namespace.ip_pool_start,  namespace.ip_pool_end, namespace.dns_servers)):
			raise CLIError("Unsupported configuration. --address-prefix / --ip-pools / --ip-pool-start / --ip-pool-end / dns-servers can only be used when --ip-allocation-method is 'Static'")


def _validate_subnet(subnet):
	"""
	Validate subnet fields
	"""

	subnet_properties = subnet.get('properties', {})
	address_prefix = subnet_properties.get('addressPrefix', None)
	ip_allocation_method = subnet_properties.get('ipAllocationMethod', None)
	ip_pools = subnet_properties.get('ipPools', None)

	if ip_allocation_method == "Static":
		# Validate Static-IP conditions
		if not address_prefix:
			raise CLIError("Missing 'addressPrefix' field in subnets json string/file. 'addressPrefix' must be provided when 'ipAllocationMethod' is Static.")
		elif address_prefix and not ip_pools:
			# Validate only address-prefix when IP-Pools is not provided
			_validate_cidr(address_prefix)
		else:
			# Validate IP-Pools
			_validate_ip_pools(address_prefix, ip_pools)
	else:
		# Validate Dynamic-IP conditions
		if any((address_prefix, ip_pools)):
			raise CLIError("'addressPrefix' or 'ipPools' fields cannot be used in subnet when 'ipAllocationMethod' is Dynamic")


def _validate_ip_pools(address_prefix, ip_pools):
	"""
	Validates if the start or end IP address is within the cidr range
	"""

	# Validate only if both address-prefix and ip-pools are present
	if address_prefix and ip_pools:
		address_prefix = _validate_cidr(address_prefix)
		for ip_pool in ip_pools:
			if ip_pool.get('start') and ip_pool.get('end'):
				start = _validate_ip_address(ip_pool.get('start'))
				end = _validate_ip_address(ip_pool.get('end'))
			else:
				raise CLIError("Missing start/end IP address in --ip-pools or --subnets. Please provide both start and end IP addresses.")

			# Validation for start/end IP range
			if start not in address_prefix or end not in address_prefix:
				raise CLIError("Invalid Input: Range {} {} is not within subnet address prefix {}".format(start, end, address_prefix))


def _validate_cidr(cidr):
    """
    Validates the network CIDR
    """

    try:
        net_cidr = ipaddress.ip_network(cidr)
    except:
        raise CLIError("Invalid CIDR provided: {}".format(cidr))
    return net_cidr


def _validate_dns_servers(dnsservers):
	"""
	Validates DNS-Servers
	"""
	if dnsservers:
		[_validate_ip_address(dnsserver) for dnsserver in dnsservers]


def _validate_ip_address(ip):
	"""
	Validates the IP address
	"""

	try:
		net_ip = ipaddress.ip_address(ip)
	except:
		raise CLIError("Invalid IP address: {}".format(ip))
	return net_ip


def _get_default_gateway_from_routes_dict(routes):
	for route in routes:
		address_prefix = route.get('properties', None).get('address_prefix', None)
		next_hop_ip = route.get('properties', None).get('next_hop_ip_address', None)
		if address_prefix == "0.0.0.0/0":
			return next_hop_ip


def vnic_create_validator(cmd, namespace):
	"""
	Validates parameters for vnic creation operation
	"""

	subnet_ip_allocation_method = default_ip_allocation_method
	subnet_properties = None

	res = parse_resource_id(namespace.subnet_id)
	vnet = _fetch_virtualnetwork(cmd.cli_ctx, res.get('resource_group', namespace.resource_group_name), res['name'])

	if len(vnet.properties.subnets):
		# MOC supports only 1 subnet
		subnet_properties = vnet.properties.subnets[0].properties
		if subnet_properties:
			subnet_ip_allocation_method = subnet_properties.ip_allocation_method or default_ip_allocation_method
			subnet_address_prefix = subnet_properties.address_prefix
			if subnet_address_prefix and namespace.ip_address:
				_validate_vnic_static_ip_address(subnet_address_prefix, namespace.ip_address)

	if subnet_ip_allocation_method != "Static" and any((namespace.ip_address, namespace.gateway)):
		raise CLIError("--ip-address and --gateway can be provided only if the associated virtualNetwork's --ip-allocation-method is Static")

	if subnet_ip_allocation_method == "Static" and namespace.gateway is None:
		# Use the default gateway set in the vnet
		if subnet_properties.route_table and subnet_properties.route_table.properties:
			namespace.gateway = _get_default_gateway_from_routes_list(subnet_properties.route_table.properties.routes)

def _get_default_gateway_from_routes_list(routes):
	if routes is None:
		return
	for route in routes:
		if route.properties and route.properties.address_prefix == "0.0.0.0/0":
			return route.properties.next_hop_ip_address


def _fetch_virtualnetwork(cli_ctx, resource_group, name):
	vnet_client = cf_virtualnetwork(cli_ctx=cli_ctx)

	vnet = vnet_client.retrieve(resource_group, name)
	return vnet

def _validate_vnic_static_ip_address(subnet_address_prefix, ip_address):
	"""
	Validates if the IP-Address provided by the user is within the subnet range
	"""
	ip = ipaddress.ip_address(ip_address)
	network = ipaddress.ip_network(subnet_address_prefix)
	if ip not in network:
		raise CLIError("ip-address provided is not within the associated virtualnetwork's(or subnet's) address-prefix range. Please provide an IP address within the range of address-prefix.")
