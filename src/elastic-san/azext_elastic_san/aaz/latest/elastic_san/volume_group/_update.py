# --------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
#
# Code generated by aaz-dev-tools
# --------------------------------------------------------------------------------------------

# pylint: skip-file
# flake8: noqa

from azure.cli.core.aaz import *


@register_command(
    "elastic-san volume-group update",
    is_preview=True,
)
class Update(AAZCommand):
    """Update a Volume Group.

    :example: Update a Volume Group.
        az elastic-san volume-group update -e "san_name" -n "vg_name" -g "rg" --protocol-type None --network-acls '{virtual-network-rules:[{id:"subnet_id_2",action:Allow}]}'

    :example: Update volume group to use CustomerManagedKey with keyvault details
        az elastic-san volume-group update -e "san_name" -n "vg_name" -g "rg" --encryption EncryptionAtRestWithCustomerManagedKey --encryption-properties '{key-vault-properties:{key-name:"key_name",key-vault-uri:"vault_uri"}}'

    :example: Update volume group to use another UserAssignedIdentity
        az elastic-san volume-group update -e "san_name" -n "vg_name" -g "rg" --identity '{type:UserAssigned,user-assigned-identity:"uai_2_id"}' --encryption-properties '{key-vault-properties:{key-name:"key_name",key-vault-uri:"vault_uri"},identity:{user-assigned-identity:"uai_2_id"}}'

    :example: Update volume group back to PlatformManagedKey
        az elastic-san volume-group update -e "san_name" -n "vg_name" -g "rg" --encryption EncryptionAtRestWithPlatformKey

    :example: Update volume group back to SystemAssignedIdentity
        az elastic-san volume-group update -e "san_name" -n "vg_name" -g "rg" --identity '{type:SystemAssigned}'
    """

    _aaz_info = {
        "version": "2023-01-01",
        "resources": [
            ["mgmt-plane", "/subscriptions/{}/resourcegroups/{}/providers/microsoft.elasticsan/elasticsans/{}/volumegroups/{}", "2023-01-01"],
        ]
    }

    AZ_SUPPORT_NO_WAIT = True

    AZ_SUPPORT_GENERIC_UPDATE = True

    def _handler(self, command_args):
        super()._handler(command_args)
        return self.build_lro_poller(self._execute_operations, self._output)

    _args_schema = None

    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        if cls._args_schema is not None:
            return cls._args_schema
        cls._args_schema = super()._build_arguments_schema(*args, **kwargs)

        # define Arg Group ""

        _args_schema = cls._args_schema
        _args_schema.elastic_san_name = AAZStrArg(
            options=["-e", "--elastic-san", "--elastic-san-name"],
            help="The name of the ElasticSan.",
            required=True,
            id_part="name",
            fmt=AAZStrArgFormat(
                pattern="^[A-Za-z0-9]+((-|_)[a-z0-9A-Z]+)*$",
                max_length=24,
                min_length=3,
            ),
        )
        _args_schema.resource_group = AAZResourceGroupNameArg(
            required=True,
        )
        _args_schema.volume_group_name = AAZStrArg(
            options=["-n", "--name", "--volume-group-name"],
            help="The name of the VolumeGroup.",
            required=True,
            id_part="child_name_1",
            fmt=AAZStrArgFormat(
                pattern="^[A-Za-z0-9]+((-|_)[a-z0-9A-Z]+)*$",
                max_length=63,
                min_length=3,
            ),
        )

        # define Arg Group "Parameters"

        _args_schema = cls._args_schema
        _args_schema.identity = AAZObjectArg(
            options=["--identity"],
            arg_group="Parameters",
            help="The identity of the resource.",
            nullable=True,
        )

        identity = cls._args_schema.identity
        identity.type = AAZStrArg(
            options=["type"],
            help="The identity type.",
            enum={"None": "None", "SystemAssigned": "SystemAssigned", "UserAssigned": "UserAssigned"},
        )
        identity.user_assigned_identities = AAZDictArg(
            options=["user-assigned-identities"],
            help="Gets or sets a list of key value pairs that describe the set of User Assigned identities that will be used with this volume group. The key is the ARM resource identifier of the identity.",
            nullable=True,
        )

        user_assigned_identities = cls._args_schema.identity.user_assigned_identities
        user_assigned_identities.Element = AAZObjectArg(
            nullable=True,
            blank={},
        )

        # define Arg Group "Properties"

        _args_schema = cls._args_schema
        _args_schema.encryption = AAZStrArg(
            options=["--encryption"],
            arg_group="Properties",
            help="Type of encryption",
            nullable=True,
            enum={"EncryptionAtRestWithCustomerManagedKey": "EncryptionAtRestWithCustomerManagedKey", "EncryptionAtRestWithPlatformKey": "EncryptionAtRestWithPlatformKey"},
        )
        _args_schema.encryption_properties = AAZObjectArg(
            options=["--encryption-properties"],
            arg_group="Properties",
            help="Encryption Properties describing Key Vault and Identity information",
            nullable=True,
        )
        _args_schema.network_acls = AAZObjectArg(
            options=["--network-acls"],
            arg_group="Properties",
            help="A collection of rules governing the accessibility from specific network locations.",
            nullable=True,
        )
        _args_schema.protocol_type = AAZStrArg(
            options=["--protocol-type"],
            arg_group="Properties",
            help="Type of storage target",
            nullable=True,
            enum={"Iscsi": "Iscsi", "None": "None"},
        )

        encryption_properties = cls._args_schema.encryption_properties
        encryption_properties.identity = AAZObjectArg(
            options=["identity"],
            help="The identity to be used with service-side encryption at rest.",
            nullable=True,
        )
        encryption_properties.key_vault_properties = AAZObjectArg(
            options=["key-vault-properties"],
            help="Properties provided by key vault.",
            nullable=True,
        )

        identity = cls._args_schema.encryption_properties.identity
        identity.user_assigned_identity = AAZStrArg(
            options=["user-assigned-identity"],
            help="Resource identifier of the UserAssigned identity to be associated with server-side encryption on the volume group.",
            nullable=True,
        )

        key_vault_properties = cls._args_schema.encryption_properties.key_vault_properties
        key_vault_properties.key_name = AAZStrArg(
            options=["key-name"],
            help="The name of KeyVault key.",
            nullable=True,
        )
        key_vault_properties.key_vault_uri = AAZStrArg(
            options=["key-vault-uri"],
            help="The Uri of KeyVault.",
            nullable=True,
        )
        key_vault_properties.key_version = AAZStrArg(
            options=["key-version"],
            help="The version of KeyVault key.",
            nullable=True,
        )

        network_acls = cls._args_schema.network_acls
        network_acls.virtual_network_rules = AAZListArg(
            options=["virtual-network-rules"],
            help="The list of virtual network rules.",
            nullable=True,
        )

        virtual_network_rules = cls._args_schema.network_acls.virtual_network_rules
        virtual_network_rules.Element = AAZObjectArg(
            nullable=True,
        )

        _element = cls._args_schema.network_acls.virtual_network_rules.Element
        _element.action = AAZStrArg(
            options=["action"],
            help="The action of virtual network rule.",
            nullable=True,
            enum={"Allow": "Allow"},
        )
        _element.id = AAZStrArg(
            options=["id"],
            help="Resource ID of a subnet, for example: /subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}.",
        )
        return cls._args_schema

    def _execute_operations(self):
        self.pre_operations()
        self.VolumeGroupsGet(ctx=self.ctx)()
        self.pre_instance_update(self.ctx.vars.instance)
        self.InstanceUpdateByJson(ctx=self.ctx)()
        self.InstanceUpdateByGeneric(ctx=self.ctx)()
        self.post_instance_update(self.ctx.vars.instance)
        yield self.VolumeGroupsCreate(ctx=self.ctx)()
        self.post_operations()

    @register_callback
    def pre_operations(self):
        pass

    @register_callback
    def post_operations(self):
        pass

    @register_callback
    def pre_instance_update(self, instance):
        pass

    @register_callback
    def post_instance_update(self, instance):
        pass

    def _output(self, *args, **kwargs):
        result = self.deserialize_output(self.ctx.vars.instance, client_flatten=True)
        return result

    class VolumeGroupsGet(AAZHttpOperation):
        CLIENT_TYPE = "MgmtClient"

        def __call__(self, *args, **kwargs):
            request = self.make_request()
            session = self.client.send_request(request=request, stream=False, **kwargs)
            if session.http_response.status_code in [200]:
                return self.on_200(session)

            return self.on_error(session.http_response)

        @property
        def url(self):
            return self.client.format_url(
                "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ElasticSan/elasticSans/{elasticSanName}/volumegroups/{volumeGroupName}",
                **self.url_parameters
            )

        @property
        def method(self):
            return "GET"

        @property
        def error_format(self):
            return "MgmtErrorFormat"

        @property
        def url_parameters(self):
            parameters = {
                **self.serialize_url_param(
                    "elasticSanName", self.ctx.args.elastic_san_name,
                    required=True,
                ),
                **self.serialize_url_param(
                    "resourceGroupName", self.ctx.args.resource_group,
                    required=True,
                ),
                **self.serialize_url_param(
                    "subscriptionId", self.ctx.subscription_id,
                    required=True,
                ),
                **self.serialize_url_param(
                    "volumeGroupName", self.ctx.args.volume_group_name,
                    required=True,
                ),
            }
            return parameters

        @property
        def query_parameters(self):
            parameters = {
                **self.serialize_query_param(
                    "api-version", "2023-01-01",
                    required=True,
                ),
            }
            return parameters

        @property
        def header_parameters(self):
            parameters = {
                **self.serialize_header_param(
                    "Accept", "application/json",
                ),
            }
            return parameters

        def on_200(self, session):
            data = self.deserialize_http_content(session)
            self.ctx.set_var(
                "instance",
                data,
                schema_builder=self._build_schema_on_200
            )

        _schema_on_200 = None

        @classmethod
        def _build_schema_on_200(cls):
            if cls._schema_on_200 is not None:
                return cls._schema_on_200

            cls._schema_on_200 = AAZObjectType()
            _UpdateHelper._build_schema_volume_group_read(cls._schema_on_200)

            return cls._schema_on_200

    class VolumeGroupsCreate(AAZHttpOperation):
        CLIENT_TYPE = "MgmtClient"

        def __call__(self, *args, **kwargs):
            request = self.make_request()
            session = self.client.send_request(request=request, stream=False, **kwargs)
            if session.http_response.status_code in [202]:
                return self.client.build_lro_polling(
                    self.ctx.args.no_wait,
                    session,
                    self.on_200_201,
                    self.on_error,
                    lro_options={"final-state-via": "location"},
                    path_format_arguments=self.url_parameters,
                )
            if session.http_response.status_code in [200, 201]:
                return self.client.build_lro_polling(
                    self.ctx.args.no_wait,
                    session,
                    self.on_200_201,
                    self.on_error,
                    lro_options={"final-state-via": "location"},
                    path_format_arguments=self.url_parameters,
                )

            return self.on_error(session.http_response)

        @property
        def url(self):
            return self.client.format_url(
                "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ElasticSan/elasticSans/{elasticSanName}/volumegroups/{volumeGroupName}",
                **self.url_parameters
            )

        @property
        def method(self):
            return "PUT"

        @property
        def error_format(self):
            return "MgmtErrorFormat"

        @property
        def url_parameters(self):
            parameters = {
                **self.serialize_url_param(
                    "elasticSanName", self.ctx.args.elastic_san_name,
                    required=True,
                ),
                **self.serialize_url_param(
                    "resourceGroupName", self.ctx.args.resource_group,
                    required=True,
                ),
                **self.serialize_url_param(
                    "subscriptionId", self.ctx.subscription_id,
                    required=True,
                ),
                **self.serialize_url_param(
                    "volumeGroupName", self.ctx.args.volume_group_name,
                    required=True,
                ),
            }
            return parameters

        @property
        def query_parameters(self):
            parameters = {
                **self.serialize_query_param(
                    "api-version", "2023-01-01",
                    required=True,
                ),
            }
            return parameters

        @property
        def header_parameters(self):
            parameters = {
                **self.serialize_header_param(
                    "Content-Type", "application/json",
                ),
                **self.serialize_header_param(
                    "Accept", "application/json",
                ),
            }
            return parameters

        @property
        def content(self):
            _content_value, _builder = self.new_content_builder(
                self.ctx.args,
                value=self.ctx.vars.instance,
            )

            return self.serialize_content(_content_value)

        def on_200_201(self, session):
            data = self.deserialize_http_content(session)
            self.ctx.set_var(
                "instance",
                data,
                schema_builder=self._build_schema_on_200_201
            )

        _schema_on_200_201 = None

        @classmethod
        def _build_schema_on_200_201(cls):
            if cls._schema_on_200_201 is not None:
                return cls._schema_on_200_201

            cls._schema_on_200_201 = AAZObjectType()
            _UpdateHelper._build_schema_volume_group_read(cls._schema_on_200_201)

            return cls._schema_on_200_201

    class InstanceUpdateByJson(AAZJsonInstanceUpdateOperation):

        def __call__(self, *args, **kwargs):
            self._update_instance(self.ctx.vars.instance)

        def _update_instance(self, instance):
            _instance_value, _builder = self.new_content_builder(
                self.ctx.args,
                value=instance,
                typ=AAZObjectType
            )
            _builder.set_prop("identity", AAZObjectType, ".identity")
            _builder.set_prop("properties", AAZObjectType, typ_kwargs={"flags": {"client_flatten": True}})

            identity = _builder.get(".identity")
            if identity is not None:
                identity.set_prop("type", AAZStrType, ".type", typ_kwargs={"flags": {"required": True}})
                identity.set_prop("userAssignedIdentities", AAZDictType, ".user_assigned_identities")

            user_assigned_identities = _builder.get(".identity.userAssignedIdentities")
            if user_assigned_identities is not None:
                user_assigned_identities.set_elements(AAZObjectType, ".")

            properties = _builder.get(".properties")
            if properties is not None:
                properties.set_prop("encryption", AAZStrType, ".encryption")
                properties.set_prop("encryptionProperties", AAZObjectType, ".encryption_properties")
                properties.set_prop("networkAcls", AAZObjectType, ".network_acls")
                properties.set_prop("protocolType", AAZStrType, ".protocol_type")

            encryption_properties = _builder.get(".properties.encryptionProperties")
            if encryption_properties is not None:
                encryption_properties.set_prop("identity", AAZObjectType, ".identity")
                encryption_properties.set_prop("keyVaultProperties", AAZObjectType, ".key_vault_properties")

            identity = _builder.get(".properties.encryptionProperties.identity")
            if identity is not None:
                identity.set_prop("userAssignedIdentity", AAZStrType, ".user_assigned_identity")

            key_vault_properties = _builder.get(".properties.encryptionProperties.keyVaultProperties")
            if key_vault_properties is not None:
                key_vault_properties.set_prop("keyName", AAZStrType, ".key_name")
                key_vault_properties.set_prop("keyVaultUri", AAZStrType, ".key_vault_uri")
                key_vault_properties.set_prop("keyVersion", AAZStrType, ".key_version")

            network_acls = _builder.get(".properties.networkAcls")
            if network_acls is not None:
                network_acls.set_prop("virtualNetworkRules", AAZListType, ".virtual_network_rules")

            virtual_network_rules = _builder.get(".properties.networkAcls.virtualNetworkRules")
            if virtual_network_rules is not None:
                virtual_network_rules.set_elements(AAZObjectType, ".")

            _elements = _builder.get(".properties.networkAcls.virtualNetworkRules[]")
            if _elements is not None:
                _elements.set_prop("action", AAZStrType, ".action")
                _elements.set_prop("id", AAZStrType, ".id", typ_kwargs={"flags": {"required": True}})

            return _instance_value

    class InstanceUpdateByGeneric(AAZGenericInstanceUpdateOperation):

        def __call__(self, *args, **kwargs):
            self._update_instance_by_generic(
                self.ctx.vars.instance,
                self.ctx.generic_update_args
            )


class _UpdateHelper:
    """Helper class for Update"""

    _schema_system_data_read = None

    @classmethod
    def _build_schema_system_data_read(cls, _schema):
        if cls._schema_system_data_read is not None:
            _schema.created_at = cls._schema_system_data_read.created_at
            _schema.created_by = cls._schema_system_data_read.created_by
            _schema.created_by_type = cls._schema_system_data_read.created_by_type
            _schema.last_modified_at = cls._schema_system_data_read.last_modified_at
            _schema.last_modified_by = cls._schema_system_data_read.last_modified_by
            _schema.last_modified_by_type = cls._schema_system_data_read.last_modified_by_type
            return

        cls._schema_system_data_read = _schema_system_data_read = AAZObjectType(
            flags={"read_only": True}
        )

        system_data_read = _schema_system_data_read
        system_data_read.created_at = AAZStrType(
            serialized_name="createdAt",
        )
        system_data_read.created_by = AAZStrType(
            serialized_name="createdBy",
        )
        system_data_read.created_by_type = AAZStrType(
            serialized_name="createdByType",
        )
        system_data_read.last_modified_at = AAZStrType(
            serialized_name="lastModifiedAt",
        )
        system_data_read.last_modified_by = AAZStrType(
            serialized_name="lastModifiedBy",
        )
        system_data_read.last_modified_by_type = AAZStrType(
            serialized_name="lastModifiedByType",
        )

        _schema.created_at = cls._schema_system_data_read.created_at
        _schema.created_by = cls._schema_system_data_read.created_by
        _schema.created_by_type = cls._schema_system_data_read.created_by_type
        _schema.last_modified_at = cls._schema_system_data_read.last_modified_at
        _schema.last_modified_by = cls._schema_system_data_read.last_modified_by
        _schema.last_modified_by_type = cls._schema_system_data_read.last_modified_by_type

    _schema_volume_group_read = None

    @classmethod
    def _build_schema_volume_group_read(cls, _schema):
        if cls._schema_volume_group_read is not None:
            _schema.id = cls._schema_volume_group_read.id
            _schema.identity = cls._schema_volume_group_read.identity
            _schema.name = cls._schema_volume_group_read.name
            _schema.properties = cls._schema_volume_group_read.properties
            _schema.system_data = cls._schema_volume_group_read.system_data
            _schema.type = cls._schema_volume_group_read.type
            return

        cls._schema_volume_group_read = _schema_volume_group_read = AAZObjectType()

        volume_group_read = _schema_volume_group_read
        volume_group_read.id = AAZStrType(
            flags={"read_only": True},
        )
        volume_group_read.identity = AAZObjectType()
        volume_group_read.name = AAZStrType(
            flags={"read_only": True},
        )
        volume_group_read.properties = AAZObjectType(
            flags={"client_flatten": True},
        )
        volume_group_read.system_data = AAZObjectType(
            serialized_name="systemData",
            flags={"read_only": True},
        )
        cls._build_schema_system_data_read(volume_group_read.system_data)
        volume_group_read.type = AAZStrType(
            flags={"read_only": True},
        )

        identity = _schema_volume_group_read.identity
        identity.principal_id = AAZStrType(
            serialized_name="principalId",
            flags={"read_only": True},
        )
        identity.tenant_id = AAZStrType(
            serialized_name="tenantId",
            flags={"read_only": True},
        )
        identity.type = AAZStrType(
            flags={"required": True},
        )
        identity.user_assigned_identities = AAZDictType(
            serialized_name="userAssignedIdentities",
        )

        user_assigned_identities = _schema_volume_group_read.identity.user_assigned_identities
        user_assigned_identities.Element = AAZObjectType()

        _element = _schema_volume_group_read.identity.user_assigned_identities.Element
        _element.client_id = AAZStrType(
            serialized_name="clientId",
            flags={"read_only": True},
        )
        _element.principal_id = AAZStrType(
            serialized_name="principalId",
            flags={"read_only": True},
        )

        properties = _schema_volume_group_read.properties
        properties.encryption = AAZStrType()
        properties.encryption_properties = AAZObjectType(
            serialized_name="encryptionProperties",
        )
        properties.network_acls = AAZObjectType(
            serialized_name="networkAcls",
        )
        properties.private_endpoint_connections = AAZListType(
            serialized_name="privateEndpointConnections",
            flags={"read_only": True},
        )
        properties.protocol_type = AAZStrType(
            serialized_name="protocolType",
        )
        properties.provisioning_state = AAZStrType(
            serialized_name="provisioningState",
            flags={"read_only": True},
        )

        encryption_properties = _schema_volume_group_read.properties.encryption_properties
        encryption_properties.identity = AAZObjectType()
        encryption_properties.key_vault_properties = AAZObjectType(
            serialized_name="keyVaultProperties",
        )

        identity = _schema_volume_group_read.properties.encryption_properties.identity
        identity.user_assigned_identity = AAZStrType(
            serialized_name="userAssignedIdentity",
        )

        key_vault_properties = _schema_volume_group_read.properties.encryption_properties.key_vault_properties
        key_vault_properties.current_versioned_key_expiration_timestamp = AAZStrType(
            serialized_name="currentVersionedKeyExpirationTimestamp",
            flags={"read_only": True},
        )
        key_vault_properties.current_versioned_key_identifier = AAZStrType(
            serialized_name="currentVersionedKeyIdentifier",
            flags={"read_only": True},
        )
        key_vault_properties.key_name = AAZStrType(
            serialized_name="keyName",
        )
        key_vault_properties.key_vault_uri = AAZStrType(
            serialized_name="keyVaultUri",
        )
        key_vault_properties.key_version = AAZStrType(
            serialized_name="keyVersion",
        )
        key_vault_properties.last_key_rotation_timestamp = AAZStrType(
            serialized_name="lastKeyRotationTimestamp",
            flags={"read_only": True},
        )

        network_acls = _schema_volume_group_read.properties.network_acls
        network_acls.virtual_network_rules = AAZListType(
            serialized_name="virtualNetworkRules",
        )

        virtual_network_rules = _schema_volume_group_read.properties.network_acls.virtual_network_rules
        virtual_network_rules.Element = AAZObjectType()

        _element = _schema_volume_group_read.properties.network_acls.virtual_network_rules.Element
        _element.action = AAZStrType()
        _element.id = AAZStrType(
            flags={"required": True},
        )

        private_endpoint_connections = _schema_volume_group_read.properties.private_endpoint_connections
        private_endpoint_connections.Element = AAZObjectType()

        _element = _schema_volume_group_read.properties.private_endpoint_connections.Element
        _element.id = AAZStrType(
            flags={"read_only": True},
        )
        _element.name = AAZStrType(
            flags={"read_only": True},
        )
        _element.properties = AAZObjectType(
            flags={"required": True, "client_flatten": True},
        )
        _element.system_data = AAZObjectType(
            serialized_name="systemData",
            flags={"read_only": True},
        )
        cls._build_schema_system_data_read(_element.system_data)
        _element.type = AAZStrType(
            flags={"read_only": True},
        )

        properties = _schema_volume_group_read.properties.private_endpoint_connections.Element.properties
        properties.group_ids = AAZListType(
            serialized_name="groupIds",
        )
        properties.private_endpoint = AAZObjectType(
            serialized_name="privateEndpoint",
        )
        properties.private_link_service_connection_state = AAZObjectType(
            serialized_name="privateLinkServiceConnectionState",
            flags={"required": True},
        )
        properties.provisioning_state = AAZStrType(
            serialized_name="provisioningState",
            flags={"read_only": True},
        )

        group_ids = _schema_volume_group_read.properties.private_endpoint_connections.Element.properties.group_ids
        group_ids.Element = AAZStrType()

        private_endpoint = _schema_volume_group_read.properties.private_endpoint_connections.Element.properties.private_endpoint
        private_endpoint.id = AAZStrType(
            flags={"read_only": True},
        )

        private_link_service_connection_state = _schema_volume_group_read.properties.private_endpoint_connections.Element.properties.private_link_service_connection_state
        private_link_service_connection_state.actions_required = AAZStrType(
            serialized_name="actionsRequired",
        )
        private_link_service_connection_state.description = AAZStrType()
        private_link_service_connection_state.status = AAZStrType()

        _schema.id = cls._schema_volume_group_read.id
        _schema.identity = cls._schema_volume_group_read.identity
        _schema.name = cls._schema_volume_group_read.name
        _schema.properties = cls._schema_volume_group_read.properties
        _schema.system_data = cls._schema_volume_group_read.system_data
        _schema.type = cls._schema_volume_group_read.type


__all__ = ["Update"]
