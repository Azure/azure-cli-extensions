# --------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
#
# Code generated by aaz-dev-tools
# --------------------------------------------------------------------------------------------

# pylint: skip-file
# flake8: noqa

from azure.cli.core.aaz import *


@register_command(
    "elastic-san volume-group create",
    is_preview=True,
)
class Create(AAZCommand):
    """Create a Volume Group.

    :example: Create a Volume Group with PlaformManagedkey and SystemAssignedIdentity
        az elastic-san volume-group create -e "san_name" -n "vg_name" -g "rg" --tags '{key1910:bbbb}' --encryption EncryptionAtRestWithPlatformKey --protocol-type Iscsi --network-acls '{virtual-network-rules:[{id:"subnet_id",action:Allow}]}' --identity '{type:SystemAssigned}'

    :example: Create a volume group with CustomerManagedKey and UserAssignedIdentity
        az elastic-san volume-group create -e "san_name" -n "vg_name" -g "rg" --encryption EncryptionAtRestWithCustomerManagedKey --protocol-type Iscsi --identity '{type:UserAssigned,user-assigned-identity:"uai_id"}' --encryption-properties '{key-vault-properties:{key-name:"key_name",key-vault-uri:"vault_uri"},identity:{user-assigned-identity:"uai_id"}}'
    """

    _aaz_info = {
        "version": "2023-01-01",
        "resources": [
            ["mgmt-plane", "/subscriptions/{}/resourcegroups/{}/providers/microsoft.elasticsan/elasticsans/{}/volumegroups/{}", "2023-01-01"],
        ]
    }

    AZ_SUPPORT_NO_WAIT = True

    def _handler(self, command_args):
        super()._handler(command_args)
        return self.build_lro_poller(self._execute_operations, self._output)

    _args_schema = None

    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        if cls._args_schema is not None:
            return cls._args_schema
        cls._args_schema = super()._build_arguments_schema(*args, **kwargs)

        # define Arg Group ""

        _args_schema = cls._args_schema
        _args_schema.elastic_san_name = AAZStrArg(
            options=["-e", "--elastic-san", "--elastic-san-name"],
            help="The name of the ElasticSan.",
            required=True,
            fmt=AAZStrArgFormat(
                pattern="^[A-Za-z0-9]+((-|_)[a-z0-9A-Z]+)*$",
                max_length=24,
                min_length=3,
            ),
        )
        _args_schema.resource_group = AAZResourceGroupNameArg(
            required=True,
        )
        _args_schema.volume_group_name = AAZStrArg(
            options=["-n", "--name", "--volume-group-name"],
            help="The name of the VolumeGroup.",
            required=True,
            fmt=AAZStrArgFormat(
                pattern="^[A-Za-z0-9]+((-|_)[a-z0-9A-Z]+)*$",
                max_length=63,
                min_length=3,
            ),
        )

        # define Arg Group "Parameters"

        _args_schema = cls._args_schema
        _args_schema.identity = AAZObjectArg(
            options=["--identity"],
            arg_group="Parameters",
            help="The identity of the resource.",
        )

        identity = cls._args_schema.identity
        identity.type = AAZStrArg(
            options=["type"],
            help="The identity type.",
            required=True,
            enum={"None": "None", "SystemAssigned": "SystemAssigned", "UserAssigned": "UserAssigned"},
        )
        identity.user_assigned_identities = AAZDictArg(
            options=["user-assigned-identities"],
            help="Gets or sets a list of key value pairs that describe the set of User Assigned identities that will be used with this volume group. The key is the ARM resource identifier of the identity.",
        )

        user_assigned_identities = cls._args_schema.identity.user_assigned_identities
        user_assigned_identities.Element = AAZObjectArg(
            blank={},
        )

        # define Arg Group "Properties"

        _args_schema = cls._args_schema
        _args_schema.encryption = AAZStrArg(
            options=["--encryption"],
            arg_group="Properties",
            help="Type of encryption",
            enum={"EncryptionAtRestWithCustomerManagedKey": "EncryptionAtRestWithCustomerManagedKey", "EncryptionAtRestWithPlatformKey": "EncryptionAtRestWithPlatformKey"},
        )
        _args_schema.encryption_properties = AAZObjectArg(
            options=["--encryption-properties"],
            arg_group="Properties",
            help="Encryption Properties describing Key Vault and Identity information",
        )
        _args_schema.network_acls = AAZObjectArg(
            options=["--network-acls"],
            arg_group="Properties",
            help="A collection of rules governing the accessibility from specific network locations.",
        )
        _args_schema.protocol_type = AAZStrArg(
            options=["--protocol-type"],
            arg_group="Properties",
            help="Type of storage target",
            enum={"Iscsi": "Iscsi", "None": "None"},
        )

        encryption_properties = cls._args_schema.encryption_properties
        encryption_properties.identity = AAZObjectArg(
            options=["identity"],
            help="The identity to be used with service-side encryption at rest.",
        )
        encryption_properties.key_vault_properties = AAZObjectArg(
            options=["key-vault-properties"],
            help="Properties provided by key vault.",
        )

        identity = cls._args_schema.encryption_properties.identity
        identity.user_assigned_identity = AAZStrArg(
            options=["user-assigned-identity"],
            help="Resource identifier of the UserAssigned identity to be associated with server-side encryption on the volume group.",
        )

        key_vault_properties = cls._args_schema.encryption_properties.key_vault_properties
        key_vault_properties.key_name = AAZStrArg(
            options=["key-name"],
            help="The name of KeyVault key.",
        )
        key_vault_properties.key_vault_uri = AAZStrArg(
            options=["key-vault-uri"],
            help="The Uri of KeyVault.",
        )
        key_vault_properties.key_version = AAZStrArg(
            options=["key-version"],
            help="The version of KeyVault key.",
        )

        network_acls = cls._args_schema.network_acls
        network_acls.virtual_network_rules = AAZListArg(
            options=["virtual-network-rules"],
            help="The list of virtual network rules.",
        )

        virtual_network_rules = cls._args_schema.network_acls.virtual_network_rules
        virtual_network_rules.Element = AAZObjectArg()

        _element = cls._args_schema.network_acls.virtual_network_rules.Element
        _element.action = AAZStrArg(
            options=["action"],
            help="The action of virtual network rule.",
            default="Allow",
            enum={"Allow": "Allow"},
        )
        _element.id = AAZStrArg(
            options=["id"],
            help="Resource ID of a subnet, for example: /subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}.",
            required=True,
        )
        return cls._args_schema

    def _execute_operations(self):
        self.pre_operations()
        yield self.VolumeGroupsCreate(ctx=self.ctx)()
        self.post_operations()

    @register_callback
    def pre_operations(self):
        pass

    @register_callback
    def post_operations(self):
        pass

    def _output(self, *args, **kwargs):
        result = self.deserialize_output(self.ctx.vars.instance, client_flatten=True)
        return result

    class VolumeGroupsCreate(AAZHttpOperation):
        CLIENT_TYPE = "MgmtClient"

        def __call__(self, *args, **kwargs):
            request = self.make_request()
            session = self.client.send_request(request=request, stream=False, **kwargs)
            if session.http_response.status_code in [202]:
                return self.client.build_lro_polling(
                    self.ctx.args.no_wait,
                    session,
                    self.on_200_201,
                    self.on_error,
                    lro_options={"final-state-via": "location"},
                    path_format_arguments=self.url_parameters,
                )
            if session.http_response.status_code in [200, 201]:
                return self.client.build_lro_polling(
                    self.ctx.args.no_wait,
                    session,
                    self.on_200_201,
                    self.on_error,
                    lro_options={"final-state-via": "location"},
                    path_format_arguments=self.url_parameters,
                )

            return self.on_error(session.http_response)

        @property
        def url(self):
            return self.client.format_url(
                "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ElasticSan/elasticSans/{elasticSanName}/volumegroups/{volumeGroupName}",
                **self.url_parameters
            )

        @property
        def method(self):
            return "PUT"

        @property
        def error_format(self):
            return "MgmtErrorFormat"

        @property
        def url_parameters(self):
            parameters = {
                **self.serialize_url_param(
                    "elasticSanName", self.ctx.args.elastic_san_name,
                    required=True,
                ),
                **self.serialize_url_param(
                    "resourceGroupName", self.ctx.args.resource_group,
                    required=True,
                ),
                **self.serialize_url_param(
                    "subscriptionId", self.ctx.subscription_id,
                    required=True,
                ),
                **self.serialize_url_param(
                    "volumeGroupName", self.ctx.args.volume_group_name,
                    required=True,
                ),
            }
            return parameters

        @property
        def query_parameters(self):
            parameters = {
                **self.serialize_query_param(
                    "api-version", "2023-01-01",
                    required=True,
                ),
            }
            return parameters

        @property
        def header_parameters(self):
            parameters = {
                **self.serialize_header_param(
                    "Content-Type", "application/json",
                ),
                **self.serialize_header_param(
                    "Accept", "application/json",
                ),
            }
            return parameters

        @property
        def content(self):
            _content_value, _builder = self.new_content_builder(
                self.ctx.args,
                typ=AAZObjectType,
                typ_kwargs={"flags": {"required": True, "client_flatten": True}}
            )
            _builder.set_prop("identity", AAZObjectType, ".identity")
            _builder.set_prop("properties", AAZObjectType, typ_kwargs={"flags": {"client_flatten": True}})

            identity = _builder.get(".identity")
            if identity is not None:
                identity.set_prop("type", AAZStrType, ".type", typ_kwargs={"flags": {"required": True}})
                identity.set_prop("userAssignedIdentities", AAZDictType, ".user_assigned_identities")

            user_assigned_identities = _builder.get(".identity.userAssignedIdentities")
            if user_assigned_identities is not None:
                user_assigned_identities.set_elements(AAZObjectType, ".")

            properties = _builder.get(".properties")
            if properties is not None:
                properties.set_prop("encryption", AAZStrType, ".encryption")
                properties.set_prop("encryptionProperties", AAZObjectType, ".encryption_properties")
                properties.set_prop("networkAcls", AAZObjectType, ".network_acls")
                properties.set_prop("protocolType", AAZStrType, ".protocol_type")

            encryption_properties = _builder.get(".properties.encryptionProperties")
            if encryption_properties is not None:
                encryption_properties.set_prop("identity", AAZObjectType, ".identity")
                encryption_properties.set_prop("keyVaultProperties", AAZObjectType, ".key_vault_properties")

            identity = _builder.get(".properties.encryptionProperties.identity")
            if identity is not None:
                identity.set_prop("userAssignedIdentity", AAZStrType, ".user_assigned_identity")

            key_vault_properties = _builder.get(".properties.encryptionProperties.keyVaultProperties")
            if key_vault_properties is not None:
                key_vault_properties.set_prop("keyName", AAZStrType, ".key_name")
                key_vault_properties.set_prop("keyVaultUri", AAZStrType, ".key_vault_uri")
                key_vault_properties.set_prop("keyVersion", AAZStrType, ".key_version")

            network_acls = _builder.get(".properties.networkAcls")
            if network_acls is not None:
                network_acls.set_prop("virtualNetworkRules", AAZListType, ".virtual_network_rules")

            virtual_network_rules = _builder.get(".properties.networkAcls.virtualNetworkRules")
            if virtual_network_rules is not None:
                virtual_network_rules.set_elements(AAZObjectType, ".")

            _elements = _builder.get(".properties.networkAcls.virtualNetworkRules[]")
            if _elements is not None:
                _elements.set_prop("action", AAZStrType, ".action")
                _elements.set_prop("id", AAZStrType, ".id", typ_kwargs={"flags": {"required": True}})

            return self.serialize_content(_content_value)

        def on_200_201(self, session):
            data = self.deserialize_http_content(session)
            self.ctx.set_var(
                "instance",
                data,
                schema_builder=self._build_schema_on_200_201
            )

        _schema_on_200_201 = None

        @classmethod
        def _build_schema_on_200_201(cls):
            if cls._schema_on_200_201 is not None:
                return cls._schema_on_200_201

            cls._schema_on_200_201 = AAZObjectType()

            _schema_on_200_201 = cls._schema_on_200_201
            _schema_on_200_201.id = AAZStrType(
                flags={"read_only": True},
            )
            _schema_on_200_201.identity = AAZObjectType()
            _schema_on_200_201.name = AAZStrType(
                flags={"read_only": True},
            )
            _schema_on_200_201.properties = AAZObjectType(
                flags={"client_flatten": True},
            )
            _schema_on_200_201.system_data = AAZObjectType(
                serialized_name="systemData",
                flags={"read_only": True},
            )
            _CreateHelper._build_schema_system_data_read(_schema_on_200_201.system_data)
            _schema_on_200_201.type = AAZStrType(
                flags={"read_only": True},
            )

            identity = cls._schema_on_200_201.identity
            identity.principal_id = AAZStrType(
                serialized_name="principalId",
                flags={"read_only": True},
            )
            identity.tenant_id = AAZStrType(
                serialized_name="tenantId",
                flags={"read_only": True},
            )
            identity.type = AAZStrType(
                flags={"required": True},
            )
            identity.user_assigned_identities = AAZDictType(
                serialized_name="userAssignedIdentities",
            )

            user_assigned_identities = cls._schema_on_200_201.identity.user_assigned_identities
            user_assigned_identities.Element = AAZObjectType()

            _element = cls._schema_on_200_201.identity.user_assigned_identities.Element
            _element.client_id = AAZStrType(
                serialized_name="clientId",
                flags={"read_only": True},
            )
            _element.principal_id = AAZStrType(
                serialized_name="principalId",
                flags={"read_only": True},
            )

            properties = cls._schema_on_200_201.properties
            properties.encryption = AAZStrType()
            properties.encryption_properties = AAZObjectType(
                serialized_name="encryptionProperties",
            )
            properties.network_acls = AAZObjectType(
                serialized_name="networkAcls",
            )
            properties.private_endpoint_connections = AAZListType(
                serialized_name="privateEndpointConnections",
                flags={"read_only": True},
            )
            properties.protocol_type = AAZStrType(
                serialized_name="protocolType",
            )
            properties.provisioning_state = AAZStrType(
                serialized_name="provisioningState",
                flags={"read_only": True},
            )

            encryption_properties = cls._schema_on_200_201.properties.encryption_properties
            encryption_properties.identity = AAZObjectType()
            encryption_properties.key_vault_properties = AAZObjectType(
                serialized_name="keyVaultProperties",
            )

            identity = cls._schema_on_200_201.properties.encryption_properties.identity
            identity.user_assigned_identity = AAZStrType(
                serialized_name="userAssignedIdentity",
            )

            key_vault_properties = cls._schema_on_200_201.properties.encryption_properties.key_vault_properties
            key_vault_properties.current_versioned_key_expiration_timestamp = AAZStrType(
                serialized_name="currentVersionedKeyExpirationTimestamp",
                flags={"read_only": True},
            )
            key_vault_properties.current_versioned_key_identifier = AAZStrType(
                serialized_name="currentVersionedKeyIdentifier",
                flags={"read_only": True},
            )
            key_vault_properties.key_name = AAZStrType(
                serialized_name="keyName",
            )
            key_vault_properties.key_vault_uri = AAZStrType(
                serialized_name="keyVaultUri",
            )
            key_vault_properties.key_version = AAZStrType(
                serialized_name="keyVersion",
            )
            key_vault_properties.last_key_rotation_timestamp = AAZStrType(
                serialized_name="lastKeyRotationTimestamp",
                flags={"read_only": True},
            )

            network_acls = cls._schema_on_200_201.properties.network_acls
            network_acls.virtual_network_rules = AAZListType(
                serialized_name="virtualNetworkRules",
            )

            virtual_network_rules = cls._schema_on_200_201.properties.network_acls.virtual_network_rules
            virtual_network_rules.Element = AAZObjectType()

            _element = cls._schema_on_200_201.properties.network_acls.virtual_network_rules.Element
            _element.action = AAZStrType()
            _element.id = AAZStrType(
                flags={"required": True},
            )

            private_endpoint_connections = cls._schema_on_200_201.properties.private_endpoint_connections
            private_endpoint_connections.Element = AAZObjectType()

            _element = cls._schema_on_200_201.properties.private_endpoint_connections.Element
            _element.id = AAZStrType(
                flags={"read_only": True},
            )
            _element.name = AAZStrType(
                flags={"read_only": True},
            )
            _element.properties = AAZObjectType(
                flags={"required": True, "client_flatten": True},
            )
            _element.system_data = AAZObjectType(
                serialized_name="systemData",
                flags={"read_only": True},
            )
            _CreateHelper._build_schema_system_data_read(_element.system_data)
            _element.type = AAZStrType(
                flags={"read_only": True},
            )

            properties = cls._schema_on_200_201.properties.private_endpoint_connections.Element.properties
            properties.group_ids = AAZListType(
                serialized_name="groupIds",
            )
            properties.private_endpoint = AAZObjectType(
                serialized_name="privateEndpoint",
            )
            properties.private_link_service_connection_state = AAZObjectType(
                serialized_name="privateLinkServiceConnectionState",
                flags={"required": True},
            )
            properties.provisioning_state = AAZStrType(
                serialized_name="provisioningState",
                flags={"read_only": True},
            )

            group_ids = cls._schema_on_200_201.properties.private_endpoint_connections.Element.properties.group_ids
            group_ids.Element = AAZStrType()

            private_endpoint = cls._schema_on_200_201.properties.private_endpoint_connections.Element.properties.private_endpoint
            private_endpoint.id = AAZStrType(
                flags={"read_only": True},
            )

            private_link_service_connection_state = cls._schema_on_200_201.properties.private_endpoint_connections.Element.properties.private_link_service_connection_state
            private_link_service_connection_state.actions_required = AAZStrType(
                serialized_name="actionsRequired",
            )
            private_link_service_connection_state.description = AAZStrType()
            private_link_service_connection_state.status = AAZStrType()

            return cls._schema_on_200_201


class _CreateHelper:
    """Helper class for Create"""

    _schema_system_data_read = None

    @classmethod
    def _build_schema_system_data_read(cls, _schema):
        if cls._schema_system_data_read is not None:
            _schema.created_at = cls._schema_system_data_read.created_at
            _schema.created_by = cls._schema_system_data_read.created_by
            _schema.created_by_type = cls._schema_system_data_read.created_by_type
            _schema.last_modified_at = cls._schema_system_data_read.last_modified_at
            _schema.last_modified_by = cls._schema_system_data_read.last_modified_by
            _schema.last_modified_by_type = cls._schema_system_data_read.last_modified_by_type
            return

        cls._schema_system_data_read = _schema_system_data_read = AAZObjectType(
            flags={"read_only": True}
        )

        system_data_read = _schema_system_data_read
        system_data_read.created_at = AAZStrType(
            serialized_name="createdAt",
        )
        system_data_read.created_by = AAZStrType(
            serialized_name="createdBy",
        )
        system_data_read.created_by_type = AAZStrType(
            serialized_name="createdByType",
        )
        system_data_read.last_modified_at = AAZStrType(
            serialized_name="lastModifiedAt",
        )
        system_data_read.last_modified_by = AAZStrType(
            serialized_name="lastModifiedBy",
        )
        system_data_read.last_modified_by_type = AAZStrType(
            serialized_name="lastModifiedByType",
        )

        _schema.created_at = cls._schema_system_data_read.created_at
        _schema.created_by = cls._schema_system_data_read.created_by
        _schema.created_by_type = cls._schema_system_data_read.created_by_type
        _schema.last_modified_at = cls._schema_system_data_read.last_modified_at
        _schema.last_modified_by = cls._schema_system_data_read.last_modified_by
        _schema.last_modified_by_type = cls._schema_system_data_read.last_modified_by_type


__all__ = ["Create"]
