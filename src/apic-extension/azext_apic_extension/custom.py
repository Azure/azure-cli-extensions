# --------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
#
# Code generated by aaz-dev-tools
# --------------------------------------------------------------------------------------------

# pylint: disable=too-many-lines
# pylint: disable=too-many-statements
# pylint: disable=line-too-long
# pylint: disable=too-many-locals

import os
import sys
import json
import yaml
import requests
from knack.log import get_logger
from knack.util import CLIError
import chardet
from azure.cli.core.aaz._arg import AAZStrArg, AAZBoolArg
from .command_patches import ImportAPIDefinitionExtension
from .command_patches import ExportAPIDefinitionExtension
from .command_patches import ExportMetadataExtension

from azure.cli.core.azclierror import InvalidArgumentValueError, UserFault

logger = get_logger(__name__)


class ImportSpecificationExtension(ImportAPIDefinitionExtension):
    def pre_operations(self):
        super().pre_operations()
        args = self.ctx.args

        # Check the size of 'value' if format is inline and raise error if value is greater than 3 mb
        if args.format == 'inline':
            value_size_bytes = sys.getsizeof(str(args.value))
            value_size_mb = value_size_bytes / (1024 * 1024)  # Convert bytes to megabytes
            if value_size_mb > 3:
                raise CLIError(
                    'The size of "value" is greater than 3 MB. '
                    'Please use --format "link" to import the specification from a URL for size greater than 3 mb.'
                )


class ExportSpecificationExtension(ExportAPIDefinitionExtension):

    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.source_profile = AAZStrArg(
            options=["--file-name"],
            help='Name of the file where to export the spec to.',
            required=True,
            registered=True
        )
        return args_schema

    def _output(self, *args, **kwargs):
        result = self.deserialize_output(self.ctx.vars.instance, client_flatten=True)
        arguments = self.ctx.args

        if result:
            response_format = result['format']
            exportedResults = result['value']

            if response_format == 'link':
                logger.warning('Fetching specification from: %s', exportedResults)
                getReponse = requests.get(exportedResults, timeout=10)
                if getReponse.status_code == 200:
                    exportedResults = getReponse.content.decode()
                else:
                    logger.error('Error while fetching the results from the link.'
                                 'Status code: %s', getReponse.status_code)

            if arguments.source_profile:
                try:
                    self.writeResultsToFile(results=exportedResults, file_name=str(arguments.source_profile))
                    logger.warning('Results exported to %s', arguments.source_profile)
                except Exception as e:  # pylint: disable=broad-except
                    logger.error('Error while writing the results to the file. Error: %s', e)
            else:
                logger.error('Please provide the --file-name to exports the results to.')
        else:
            logger.error('No results found.')

    def writeResultsToFile(self, results, file_name):
        if file_name:
            with open(file_name, 'w', encoding='utf-8') as f:
                if os.path.splitext(file_name)[1] == '.json':
                    if isinstance(results, str):
                        results = json.loads(results)
                    json.dump(results, f, indent=4, separators=(',', ':'))
                else:
                    f.write(results)


class ExportMetadataSchemaExtension(ExportMetadataExtension):

    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.source_profile = AAZStrArg(
            options=["--file-name"],
            help='Name of the file where to export the metadata schema to.',
            required=True,
            registered=True
        )
        args_schema.custom_metadata_only = AAZBoolArg(
            options=["--custom-metadata-only"],
            help='Export only custom metadata.',
            required=False,
            blank=True
        )
        return args_schema

    def _output(self, *args, **kwargs):
        result = self.deserialize_output(self.ctx.vars.instance, client_flatten=True)
        arguments = self.ctx.args

        if result:
            response_format = result['format']
            exportedResults = result['value']

            if response_format == 'link':
                getReponse = requests.get(exportedResults, timeout=10)
                if getReponse.status_code == 200:
                    content = json.loads(getReponse.content.decode())
                    # Check if custom metadata only
                    exportedResults = content.get('properties').get('customProperties', {}) if arguments.custom_metadata_only else content
                else:
                    logger.error('Error while fetching the results from the link. Status code: %s', getReponse.status_code)
            else:
                # Check if custom metadata only
                exportedResults = json.loads(exportedResults).get('properties').get('customProperties', {}) if arguments.custom_metadata_only else exportedResults

            if arguments.source_profile:
                try:
                    self.writeResultsToFile(results=exportedResults, file_name=str(arguments.source_profile))
                    logger.warning('Results exported to %s', arguments.source_profile)

                except Exception as e:  # pylint: disable=broad-except
                    logger.error('Error while writing the results to the file. Error: %s', e)
            else:
                logger.error('Please provide the --file-name to exports the results to.')
        else:
            logger.error('No results found.')

    def writeResultsToFile(self, results, file_name):
        if file_name:
            with open(file_name, 'w', encoding='utf-8') as f:
                if os.path.splitext(file_name)[1] == '.json':
                    if isinstance(results, str):
                        results = json.loads(results)
                    json.dump(results, f, indent=4, separators=(',', ':'))
                else:
                    f.write(results)


class CustomCommandInternalError(UserFault):
    """ Internal error in custom command. """
    def __init__(self, error_msg, code=None):
        error_msg = f'Code: {code}\nMessage: {error_msg}'
        super(CustomCommandInternalError, self).__init__(error_msg)


# Quick Import
def register_apic(cmd, api_location, resource_group, service_name, environment_id=None):

    # Load the JSON file
    if api_location:

        value = None
        custom_format = 'inline'
        # Read the spec content from URL
        if str(api_location).startswith('https://') or str(api_location).startswith('http://'):
            try:
                # Fetch the content from the URL
                response = requests.get(api_location)
                # Raise an error for bad status codes
                response.raise_for_status()
                # Try to parse the content as JSON
                try:
                    data = json.loads(response.content)
                except json.JSONDecodeError:
                    try:
                        # If JSON parsing fails, try to parse as YAML
                        data = yaml.safe_load(response.content)
                    except yaml.YAMLError as e:
                        data = None
                        value = None
                        raise InvalidArgumentValueError(error_msg=f"Error parsing data from {api_location}: {e}")
                        # sys.exit(-1)
                # If we could parse the content(json or yaml), set format to link
                value = str(api_location) if data else None
                custom_format = 'link' if data else 'inline'
            except requests.exceptions.RequestException as e:
                data = None
                value = None
                raise InvalidArgumentValueError(error_msg=f"Error fetching data from invalid url {api_location}: {e}")
                # sys.exit(-1)
        else:
            # Confirm its a file and not link
            with open(str(api_location), 'rb') as f:
                rawdata = f.read()
                result = chardet.detect(rawdata)
                encoding = result['encoding']

            # TODO - read other file types later
            if str(api_location).endswith('.yaml') or str(api_location).endswith('.yml'):
                with open(str(api_location), 'r', encoding=encoding) as f:
                    content = f.read()
                    data = yaml.safe_load(content)
                    value = content if data else None
            if (str(api_location).endswith('.json')):
                with open(str(api_location), 'r', encoding=encoding) as f:
                    content = f.read()
                    data = json.loads(content)
                    value = content if data else None

        # If we could not read the file, return error
        if value is None:
            logger.error('Could not load spec file')
            return

        # Check if the first field is 'swagger', 'openapi', or something else and get the definition name and version
        first_key, first_value = list(data.items())[0]
        if first_key in ['swagger', 'openapi']:
            extracted_definition_name = 'openapi'
            extracted_definition_version = first_value.lower()
            extracted_api_kind = 'rest'  # TODO determine kind from spec
        else:
            extracted_definition_name = 'default'
            extracted_definition_version = 'v1'
            extracted_api_kind = 'rest'
            # TODO how to determine other kinds - enum={"graphql": "graphql", "grpc": "grpc", "rest": "rest", "soap": "soap", "webhook": "webhook", "websocket": "websocket"}

        # Create API and Create API Version
        try:
            info = data['info']
            if info:
                # Create API and Create API Version
                extracted_api_name = _generate_api_id(info.get('title', 'Default-API')).lower()
                extracted_api_description = info.get('description', 'API Description')[:1000]
                extracted_api_title = info.get('title', 'API Title')
                extracted_api_version = info.get('version', 'v1').replace(".", "-").lower()
                extracted_api_version_title = info.get('version', 'v1').replace(".", "-").lower()
                # TODO -Create API Version lifecycle_stage

                # Create API - Get the contact details from info in spec
                contacts = None
                contact = info.get('contact')
                if contact:
                    extracted_api_contact_email = contact.get('email')
                    extracted_api_contact_name = contact.get('name')
                    extracted_api_contact_url = contact.get('url')
                    contacts = [{'email': extracted_api_contact_email, 'name': extracted_api_contact_name, 'url': extracted_api_contact_url}]

                # Create API - Get the license details from info in spec
                extracted_api_license = None
                licenseDetails = info.get('license')
                if licenseDetails:
                    extracted_api_license_identifier = licenseDetails.get('identifier')
                    extracted_api_license_name = licenseDetails.get('name')
                    extracted_api_license_url = licenseDetails.get('url')
                    extracted_api_license = {'identifier': extracted_api_license_identifier, 'name': extracted_api_license_name, 'url': extracted_api_license_url}

                # Create API - Get the terms of service from info in spec
                extracted_api_terms_of_service = {'url': None}
                extracted_api_terms_of_service_value = info.get('termsOfService')
                if extracted_api_terms_of_service_value:
                    extracted_api_terms_of_service = {'url': extracted_api_terms_of_service_value}

                # Create API - Get the external documentation in spec
                extracted_api_external_documentation = []
                external_documentation = data.get('externalDocs')
                if external_documentation:
                    extracted_api_external_documentation_description = external_documentation.get('description')
                    extracted_api_external_documentation_url = external_documentation.get('url')
                    extracted_api_external_documentation.append({'description': extracted_api_external_documentation_description, 'title': 'Title', 'url': extracted_api_external_documentation_url})

                # TODO: Create API - custom-properties
                # "The custom metadata defined for API catalog entities. #1

                # Create API -------------------------------------------------------------------------------------
                from .aaz.latest.apic.api import Create as CreateAPI

                api_args = {
                    'api_id': extracted_api_name,
                    'resource_group': resource_group,
                    'service_name': service_name,
                    'workspace_name': 'default',
                    'title': extracted_api_title,
                    'type': extracted_api_kind,
                    'contacts': contacts,
                    'license': extracted_api_license,
                    'terms_of_service': extracted_api_terms_of_service,
                    'external_documentation': extracted_api_external_documentation,
                    'description': extracted_api_description,
                }

                CreateAPI(cli_ctx=cmd.cli_ctx)(command_args=api_args)
                logger.warning('API was created successfully')

                # Create API Version -----------------------------------------------------------------------------
                from .aaz.latest.apic.api.version import Create as CreateAPIVersion

                api_version_args = {
                    'api_id': extracted_api_name,
                    'resource_group': resource_group,
                    'service_name': service_name,
                    'version_id': extracted_api_version,
                    'workspace_name': 'default',
                    'lifecycle_stage': 'design',  # TODO: Extract from spec or not pass. was it required?
                    'title': extracted_api_version_title
                }

                CreateAPIVersion(cli_ctx=cmd.cli_ctx)(command_args=api_version_args)
                logger.warning('API version was created successfully')

                # Create API Definition -----------------------------------------------------------------------------
                from .aaz.latest.apic.api.definition import Create as CreateAPIDefinition

                api_definition_args = {
                    'api_id': extracted_api_name,
                    'resource_group': resource_group,
                    'service_name': service_name,
                    'version_id': extracted_api_version,
                    'workspace_name': 'default',
                    'definition_id': extracted_definition_name,
                    'title': extracted_definition_name,  # TODO Extract from spec
                    'description': extracted_api_description,  # TODO Extract from spec
                }

                CreateAPIDefinition(cli_ctx=cmd.cli_ctx)(command_args=api_definition_args)
                logger.warning('API definition was created successfully')

                # Import Specification -----------------------------------------------------------------------------
                from azure.cli.core.commands import LongRunningOperation

                # uses customized ImportSpecificationExtension class
                specification_details = {'name': extracted_definition_name, 'version': extracted_definition_version}
                # TODO format - Link - what if the link is just pasted in the value?
                # TODO format - inline - what if spec is just pasted in the value?
                # TODO - other non json spec formats

                api_specification_args = {
                    'resource_group': resource_group,
                    'service_name': service_name,
                    'workspace_name': 'default',
                    'api_id': extracted_api_name,
                    'version_id': extracted_api_version,
                    'definition_id': extracted_definition_name,
                    'format': custom_format,
                    'specification': specification_details,  # TODO write the correct spec object
                    'value': value
                }

                importAPISpecificationResults = ImportSpecificationExtension(cli_ctx=cmd.cli_ctx)(command_args=api_specification_args)
                LongRunningOperation(cmd.cli_ctx)(importAPISpecificationResults)
                logger.warning('API specification was created successfully')

                # Create API Deployment -----------------------------------------------------------------------------
                from .aaz.latest.apic.api.deployment import Create as CreateAPIDeployment

                servers = data.get('servers')
                if environment_id and servers:
                    for server in servers:
                        default_deployment_title = (extracted_api_name + "deployment").replace("-", "")
                        extracted_deployment_name = server.get('name', default_deployment_title).replace(" ", "-")
                        extracted_deployment_title = server.get('title', default_deployment_title).replace(" ", "-")
                        extracted_deployment_description = server.get('description', default_deployment_title)
                        extracted_definition_id = '/workspaces/default/apis/' + extracted_api_name + '/versions/' + extracted_api_version + '/definitions/' + extracted_definition_name
                        extracted_environment_id = '/workspaces/default/environments/' + environment_id
                        extracted_state = server.get('state', 'active')

                        extracted_server_urls = []
                        extracted_server_url = server.get('url')
                        extracted_server_urls.append(extracted_server_url)
                        extracted_server = {'runtime_uri': extracted_server_urls}

                        api_deployment_args = {
                            'resource_group': resource_group,
                            'service_name': service_name,
                            'workspace_name': 'default',
                            'api_id': extracted_api_name,
                            'deployment_id': extracted_deployment_name,
                            'description': extracted_deployment_description,
                            'title': extracted_deployment_title,
                            'definition_id': extracted_definition_id,
                            'environment_id': extracted_environment_id,
                            'server': extracted_server,
                            'state': extracted_state
                            # TODO custom properties
                        }

                        CreateAPIDeployment(cli_ctx=cmd.cli_ctx)(command_args=api_deployment_args)
                        logger.warning('API deployment was created successfully')
        except Exception as e:
            raise CustomCommandInternalError(error_msg=f'Error while creating API. Field missing: {e}', code='KeyError') if type(e).__name__ == 'KeyError' else e


def _generate_api_id(title: str) -> str:
    import re
    # Remove invalid characters
    api_id = re.sub('[^a-zA-Z0-9-]', '', title)
    # Remove leading and trailing hyphens
    api_id = api_id.strip('-')
    return api_id
