# --------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
#
# Code generated by aaz-dev-tools
# --------------------------------------------------------------------------------------------

# pylint: disable=too-many-lines
# pylint: disable=too-many-statements

from knack.log import get_logger
from azure.cli.core.aaz import has_value, AAZAnyType, AAZListArg, AAZStrArg
from azure.cli.core.aaz._arg_action import AAZArgActionOperations, AAZPromptInputOperation, _ELEMENT_APPEND_KEY
from azure.cli.core.azclierror import InvalidArgumentValueError
from azext_change_state.aaz.latest.change_safety.change_state import Create as _ChangeStateCreate, Update as _ChangeStateUpdate, Show as _ChangeStateShow, Delete as _ChangeStateDelete
from azure.cli.core.aaz import AAZObjectType, AAZStrType, AAZListType


logger = get_logger(__name__)


def _inject_change_definition_into_content(content, ctx):
    """Attach the computed changeDefinition payload to the serialized request content."""
    change_definition_value = getattr(ctx.vars, "change_definition", None)
    if change_definition_value is None:
        return content

    change_definition = change_definition_value.to_serialized_data()
    if not change_definition:
        return content

    if content is None:
        content = {}
    properties = content.setdefault("properties", {})
    properties["changeDefinition"] = change_definition
    return content


def _normalize_targets_arg(raw_targets):
    """Return a list of raw target strings from the parsed CLI argument."""
    if raw_targets is None:
        return []

    if isinstance(raw_targets, AAZArgActionOperations):
        elements = []
        for keys, data in raw_targets._ops:
            logger.debug("Processing target op keys=%s data=%s", keys, data)
            if isinstance(data, AAZPromptInputOperation):
                data = data()

            normalized_value = ''
            if isinstance(data, (list, tuple)):
                normalized_value = ','.join(str(v) for v in data if v is not None)
            elif data is not None:
                normalized_value = str(data)

            idx = None
            key_name = None
            for key in keys:
                if key == _ELEMENT_APPEND_KEY:
                    idx = len(elements)
                elif isinstance(key, int):
                    idx = key
                elif isinstance(key, str):
                    key_name = key

            if idx is None:
                idx = len(elements) - 1 if elements else 0
            while len(elements) <= idx:
                elements.append('')

            if key_name:
                combined = f"{key_name}={normalized_value}" if normalized_value else key_name
                elements[idx] = f"{elements[idx]},{combined}" if elements[idx] else combined
            else:
                elements[idx] = normalized_value

        return [value for value in elements if value]

    if hasattr(raw_targets, 'to_serialized_data'):
        values = raw_targets.to_serialized_data()
    elif isinstance(raw_targets, list):
        values = raw_targets
    else:
        values = [raw_targets]

    return [str(v) for v in values if v is not None]


def _inject_targets_into_result(data, targets):
    """Ensure changeDefinition.details.targets is present in the command output."""
    if not targets or data is None:
        return

    def process(item):
        if not isinstance(item, dict):
            return
        containers = []
        if isinstance(item.get('properties'), dict):
            containers.append(item['properties'])
        containers.append(item)
        for container in containers:
            change_def = container.get('changeDefinition')
            if isinstance(change_def, dict):
                details = change_def.setdefault('details', {})
                if isinstance(details, dict) and not details.get('targets'):
                    details['targets'] = targets

    if isinstance(data, list):
        for entry in data:
            process(entry)
    else:
        process(data)

def _custom_show_schema_builder():
    # Import the generated Show class
    from azext_change_state.aaz.latest.change_safety.change_state._show import Show as GeneratedShow

    # Get the base schema from the generated code
    base_schema = GeneratedShow.ChangeStatesGet._build_schema_on_200()

    # Inject/override the targets schema
    change_definition = base_schema.properties.change_definition
    details = change_definition.details
    details.targets = AAZListType(flags={"read_only": True})
    details.targets.Element = AAZObjectType()
    details.targets.Element.resourceId = AAZStrType()
    details.targets.Element.subscriptionId = AAZStrType()
    details.targets.Element.resourceGroupName = AAZStrType()
    details.targets.Element.resourceType = AAZStrType()
    details.targets.Element.resourceName = AAZStrType()
    details.targets.Element.httpMethod = AAZStrType()

    return base_schema


class ChangeStateCreate(_ChangeStateCreate):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._raw_targets = []
        self._parsed_targets = None

    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        schema = super()._build_arguments_schema(*args, **kwargs)
        if not hasattr(schema, "targets"):
            schema.targets = AAZListArg(
                options=["--targets"],
                help=(
                    "Target definitions expressed as key=value pairs separated by commas or semicolons. "
                    "Example: --targets \"resourceId=<id>,operation=delete\""
                ),
            )
            schema.targets.Element = AAZStrArg()
        return schema

    def _handler(self, command_args):
        # Extract targets before calling parent handler so we can accept flexible input formats.
        command_args = dict(command_args) if command_args else {}
        raw_targets = command_args.pop('targets', None)
        if raw_targets is not None:
            self._raw_targets = _normalize_targets_arg(raw_targets)
        return super()._handler(command_args)

    def pre_operations(self):
        super().pre_operations()

        if not self._raw_targets:
            raise InvalidArgumentValueError('--targets is required and must include key=value pairs.')

        # Build and set the changeDefinition with targets
        change_definition = self._build_change_definition()
        logger.debug("Final changeDefinition for create: %s", change_definition)
        self.ctx.set_var('change_definition', change_definition, schema_builder=lambda: AAZAnyType())

    def _build_change_definition(self):
        """Build the changeDefinition object with targets"""
        targets = self._parse_targets(self._raw_targets)
        self._parsed_targets = targets
        change_name = self.ctx.args.change_state_name.to_serialized_data() if has_value(self.ctx.args.change_state_name) else "Change Definition"

        return {
            'kind': 'Targets',
            'name': change_name,
            'details': {
                'targets': targets
            }
        }

    @staticmethod
    def _parse_targets(raw_targets):
        if raw_targets is None:
            raise InvalidArgumentValueError('--targets is required and must include key=value pairs.')
        if not raw_targets:
            raise InvalidArgumentValueError('--targets is required and must include key=value pairs.')
        parsed_targets = []
        for token in raw_targets:
            if token is None:
                continue
            segments = []
            for part in str(token).split(';'):
                segments.extend(segment.strip() for segment in part.split(',') if segment.strip())
            if not segments:
                continue
            target_entry = {}
            for segment in segments:
                if '=' not in segment:
                    raise InvalidArgumentValueError('Each --targets entry must be in key=value format.')
                key, value = segment.split('=', 1)
                key = key.strip()
                value = value.strip()
                if not key or not value:
                    raise InvalidArgumentValueError('Each --targets entry must include a non-empty key and value.')
                key_mapping = {
                    'resourceid': 'resourceId',
                    'subscriptionid': 'subscriptionId',
                    'resourcegroupname': 'resourceGroupName',
                    'resourcegroup': 'resourceGroupName',
                    'rg': 'resourceGroupName',
                    'resourcetype': 'resourceType',
                    'resourcename': 'resourceName',
                    'httpmethod': 'httpMethod',
                    'method': 'httpMethod',
                    'operation': 'httpMethod'
                }
                normalized_key = key.lower()
                if normalized_key in key_mapping:
                    mapped_key = key_mapping[normalized_key]
                    if mapped_key == 'httpMethod' and value:
                        value = value.upper()
                    target_entry[mapped_key] = value
                else:
                    target_entry[key] = value
            if not target_entry:
                continue
            parsed_targets.append(target_entry)
        if not parsed_targets:
            raise InvalidArgumentValueError('--targets must include at least one key=value pair.')
        return parsed_targets

    def _output(self, *args, **kwargs):
        result = super()._output(*args, **kwargs)
        _inject_targets_into_result(result, self._parsed_targets)
        return result

    def pre_instance_create(self):
        """Set the changeDefinition in the request body before creating the instance"""
        change_definition = getattr(self.ctx.vars, 'change_definition', None)
        if change_definition is not None:
            # The changeDefinition will be set in the content property of the HTTP operations
            pass

    class ChangeStatesCreateOrUpdateAtSubscriptionLevel(_ChangeStateCreate.ChangeStatesCreateOrUpdateAtSubscriptionLevel):
        @property
        def content(self):
            content = super().content
            return _inject_change_definition_into_content(content, self.ctx)

    class ChangeStatesCreateOrUpdate(_ChangeStateCreate.ChangeStatesCreateOrUpdate):
        @property
        def content(self):
            content = super().content
            return _inject_change_definition_into_content(content, self.ctx)


class ChangeStateUpdate(_ChangeStateUpdate):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._raw_targets = []
        self._parsed_targets = None

    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        schema = super()._build_arguments_schema(*args, **kwargs)
        if not hasattr(schema, "targets"):
            schema.targets = AAZListArg(
                options=["--targets"],
                help=(
                    "Optional target definitions expressed as key=value pairs separated by commas or semicolons. "
                    "Example: --targets \"resourceId=<id>,operation=delete\""
                ),
            )
            schema.targets.Element = AAZStrArg()
        return schema

    def _handler(self, command_args):
        # Extract targets before calling parent handler so we can accept flexible input formats.
        command_args = dict(command_args) if command_args else {}
        raw_targets = command_args.pop('targets', None)
        if raw_targets is not None:
            self._raw_targets = _normalize_targets_arg(raw_targets)
        return super()._handler(command_args)

    def pre_operations(self):
        super().pre_operations()

        # Build and set the changeDefinition with targets if targets are provided
        if self._raw_targets:
            change_definition = self._build_change_definition()
            logger.debug("Final changeDefinition for update: %s", change_definition)
            self.ctx.set_var('change_definition', change_definition, schema_builder=lambda: AAZAnyType())

    def _build_change_definition(self):
        """Build the changeDefinition object with targets"""
        targets = self._parse_targets(self._raw_targets)
        self._parsed_targets = targets
        change_name = self.ctx.args.change_state_name.to_serialized_data() if has_value(self.ctx.args.change_state_name) else "Change Definition"

        return {
            'kind': 'Targets',
            'name': change_name,
            'details': {
                'targets': targets
            }
        }

    def _parse_targets(self, raw_targets):
        """Parse target strings into structured objects"""
        if not raw_targets:
            return None  # For update, targets may be optional

        parsed_targets = []
        for token in raw_targets:
            if not token:
                continue

            # Split by semicolon or comma to handle multiple key-value pairs in one token
            segments = []
            for part in str(token).replace(';', ',').split(','):
                segment = part.strip()
                if segment:
                    segments.append(segment)

            if not segments:
                continue

            target_entry = {}
            for segment in segments:
                if '=' not in segment:
                    raise InvalidArgumentValueError(f"Each --targets entry must be in key=value format. Invalid: '{segment}'")

                key, value = segment.split('=', 1)
                key = key.strip()
                value = value.strip()

                if not key or not value:
                    raise InvalidArgumentValueError('Each --targets entry must include a non-empty key and value.')

                # Map keys to the correct property names
                key_mapping = {
                    'resourceid': 'resourceId',
                    'subscriptionid': 'subscriptionId',
                    'resourcegroupname': 'resourceGroupName',
                    'resourcegroup': 'resourceGroupName',  # Allow shorter alias
                    'rg': 'resourceGroupName',  # Allow shorter alias
                    'resourcetype': 'resourceType',
                    'resourcename': 'resourceName',
                    'httpmethod': 'httpMethod',
                    'method': 'httpMethod',  # Allow shorter alias
                    'operation': 'httpMethod'  # Allow 'operation' as alias for httpMethod
                }

                normalized_key = key.lower()
                if normalized_key in key_mapping:
                    mapped_key = key_mapping[normalized_key]
                    # Normalize HTTP method values to uppercase
                    if mapped_key == 'httpMethod' and value:
                        value = value.upper()
                    target_entry[mapped_key] = value
                else:
                    target_entry[key] = value

            if target_entry:
                parsed_targets.append(target_entry)

        return parsed_targets if parsed_targets else None

    def _output(self, *args, **kwargs):
        result = super()._output(*args, **kwargs)
        _inject_targets_into_result(result, self._parsed_targets)
        return result

    def pre_instance_update(self):
        """Set the changeDefinition in the request body before updating the instance"""
        change_definition = getattr(self.ctx.vars, 'change_definition', None)
        if change_definition is not None:
            # The changeDefinition will be set in the content property of the HTTP operations
            pass

    class ChangeStatesCreateOrUpdateAtSubscriptionLevel(_ChangeStateUpdate.ChangeStatesCreateOrUpdateAtSubscriptionLevel):
        @property
        def content(self):
            content = super().content
            return _inject_change_definition_into_content(content, self.ctx)

    class ChangeStatesCreateOrUpdate(_ChangeStateUpdate.ChangeStatesCreateOrUpdate):
        @property
        def content(self):
            content = super().content
            return _inject_change_definition_into_content(content, self.ctx)

class ChangeStateShow(_ChangeStateShow):
    def _output(self, *args, **kwargs):
        result = super()._output(*args, **kwargs)
        # Optionally inject targets schema into result if needed
        return result

    class ChangeStatesGetAtSubscriptionLevel(_ChangeStateShow.ChangeStatesGetAtSubscriptionLevel):
        def on_200(self, session):
            data = self.deserialize_http_content(session)
            self.ctx.set_var(
                "instance",
                data,
                schema_builder=_custom_show_schema_builder
            )

    class ChangeStatesGet(_ChangeStateShow.ChangeStatesGet):
        def on_200(self, session):
            data = self.deserialize_http_content(session)
            self.ctx.set_var(
                "instance",
                data,
                schema_builder=_custom_show_schema_builder
            )

class ChangeStateDelete(_ChangeStateDelete):
    pass
