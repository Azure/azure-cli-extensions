# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------
# pylint: disable=protected-access

import argparse
import json
from collections import defaultdict
from knack.util import CLIError


def generate_list(inputStr):
    if inputStr is None:
        return None
    return [word.strip() for word in inputStr.split(',')]


class AddDefaultRolloutROW2(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.rest_of_the_world_group_two = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError(
                'usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'wait-duration':
                d['wait_duration'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter rest_of_the_world_group_two. All possible keys are: wait-duration'.
                               format(k))
        return d


class AddProviderAuthentication(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.provider_authentication = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError(
                'usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'allowed-audiences':
                d['allowed_audiences'] = v
            else:
                raise CLIError('Unsupported Key {} is provided for parameter provider_authentication. All possible '
                               'keys are: allowed-audiences'.format(k))
        return d


class AddProviderHubMetadataAuthentication(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.providerhub_metadata_authentication = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError(
                'usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'allowed-audiences':
                d['allowed_audiences'] = v
            else:
                raise CLIError('Unsupported Key {} is provided for parameter providerhub_metadata_rp_authentication. '
                               ' All possible keys are: allowed-audiences'.format(k))
        return d


class AddProviderAuthorizations(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddProviderAuthorizations, self).__call__(
            parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError(
                'usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'application-id':
                d['application_id'] = v[0]
            elif kl == 'role-definition-id':
                d['role_definition_id'] = v[0]
            elif kl == 'managed-by-role-definition-id':
                d['managed_by_role_definition_id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter provider_authorizations. All possible '
                               'keys are: application-id, role-definition-id, managed-by-role-definition-id'.format(k))
        return d


class AddCapabilities(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddCapabilities, self).__call__(
            parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError(
                'usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'quota-id':
                d['quota_id'] = v[0]
            elif kl == 'effect':
                d['effect'] = v[0]
            elif kl == 'required-features':
                d['required_features'] = v
            else:
                raise CLIError('Unsupported Key {} is provided for parameter capabilities. All possible keys are: '
                               'quota-id, effect, required-features'.format(k))
        return d


class AddSkipRegions(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values)
        namespace.skip_regions = action

    def get_action(self, values):  # pylint: disable=no-self-use
        return generate_list(values[0])


class AddRequiredFeatures(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values)
        namespace.required_features = action

    def get_action(self, values):  # pylint: disable=no-self-use
        return values


class AddTemplateDeploymentOptions(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.template_deployment_options = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError(
                'usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'preflight-supported':
                d['preflight_supported'] = v[0]
            elif kl == 'preflight-options':
                d['preflight_options'] = v
            else:
                raise CLIError('Unsupported Key {} is provided for parameter template_deployment_options. All possible '
                               'keys are: preflight-supported, preflight-options'.format(k))
        return d


class AddServiceTreeInfos(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super().__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError(
                'usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'service-id':
                d['service_id'] = v[0]
            elif kl == 'component-id':
                d['component_id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter service_tree_infos. All possible keys '
                               'are: service-id, component-id'.format(k))
        return d


class AddResourceTypeEndpointProperties(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super().__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError(
                'usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {
            'extensions': [
                {}
            ]
        }
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'api-versions':
                d['api_versions'] = generate_list(v[0])
            elif kl == 'locations':
                d['locations'] = generate_list(v[0])
            elif kl == 'required-features':
                d['required_features'] = v
            elif kl == 'extensions':
                d['extensions'] = json.loads(v[0])
            elif kl == 'extension-endpoint-uri':
                d['extensions'][0]['endpointUri'] = v[0]
            elif kl == 'extension-categories':
                d['extensions'][0]['extensionCategories'] = v
            elif kl == 'extension-timeout':
                d['extensions'][0]['timeout'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter endpoints. All possible keys '
                               'are: api-versions, locations, required-features, extension-endpoint-uri, extension-categories, extension-timeout'.format(k))
        return d


class AddExtensionOptions(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.resource_creation_begin = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError(
                'usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'request':
                d['request'] = v
            elif kl == 'response':
                d['response'] = v
            else:
                raise CLIError('Unsupported Key {} is provided for parameter resource_creation_begin. '
                               'All possible keys are: request, response'.format(k))
        return d


class AddResourcePatchBegin(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.resource_patch_begin = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError(
                'usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'request':
                d['request'] = v
            elif kl == 'response':
                d['response'] = v
            else:
                raise CLIError('Unsupported Key {} is provided for parameter resource_patch_begin. '
                               'All possible keys are: request, response'.format(k))
        return d


class AddSubscriptionStateOverrideActions(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddSubscriptionStateOverrideActions, self).__call__(
            parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError(
                'usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'state':
                d['state'] = v[0]
            elif kl == 'action':
                d['action'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter subscription_state_override_actions. All '
                               'possible keys are: state, action'.format(k))
        return d


class AddProviderHubMetadataProviderAuthorizations(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddProviderHubMetadataProviderAuthorizations, self).__call__(
            parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError(
                'usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'application-id':
                d['application_id'] = v[0]
            elif kl == 'role-definition-id':
                d['role_definition_id'] = v[0]
            elif kl == 'managed-by-role-definition-id':
                d['managed_by_role_definition_id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter provider_hub_metadata_provider_authorizati'
                               'ons. All possible keys are: application-id, role-definition-id, '
                               'managed-by-role-definition-id'.format(k))
        return d


class AddAuthorizations(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddAuthorizations, self).__call__(
            parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError(
                'usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'principal-id':
                d['principal_id'] = v[0]
            elif kl == 'role-definition-id':
                d['role_definition_id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter authorizations. All possible keys are: '
                               'principal-id, role-definition-id'.format(k))
        return d


class AddCanaryRegion(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.canary = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError(
                'usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'skip-regions':
                d['skip_regions'] = v
            elif kl == 'regions':
                d['regions'] = v
            else:
                raise CLIError('Unsupported Key {} is provided for parameter canary. All possible keys are: '
                               'skip-regions, regions'.format(k))
        return d


class AddNotificationEndpoints(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddNotificationEndpoints, self).__call__(
            parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError(
                'usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'notification-destination':
                d['notification_destination'] = v[0]
            elif kl == 'locations':
                d['locations'] = v
            else:
                raise CLIError('Unsupported Key {} is provided for parameter notification_endpoints. All possible keys '
                               'are: notification-destination, locations'.format(k))
        return d


class AddSwaggerSpecifications(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddSwaggerSpecifications, self).__call__(
            parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError(
                'usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'api-versions':
                d['api_versions'] = generate_list(v[0])
            elif kl == 'swagger-spec-folder-uri':
                d['swagger_spec_folder_uri'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter swagger_specifications. All possible keys '
                               'are: api-versions, swagger-spec-folder-uri'.format(k))
        return d


class AddAuthorizationActionMappings(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddAuthorizationActionMappings, self).__call__(
            parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError(
                'usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'original':
                d['original'] = v[0]
            elif kl == 'desired':
                d['desired'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter authorization_action_mappings. All '
                               'possible keys are: original, desired'.format(k))
        return d


class AddLinkedAccessChecks(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddLinkedAccessChecks, self).__call__(
            parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError(
                'usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'action-name':
                d['action_name'] = v[0]
            elif kl == 'linked-property':
                d['linked_property'] = v[0]
            elif kl == 'linked-action':
                d['linked_action'] = v[0]
            elif kl == 'linked-action-verb':
                d['linked_action_verb'] = v[0]
            elif kl == 'linked-type':
                d['linked_type'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter linked_access_checks. All possible keys '
                               'are: action-name, linked-property, linked-action, linked-action-verb, linked-type'.
                               format(k))
        return d


class AddLoggingRules(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super().__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError(
                'usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'action':
                d['action'] = v[0]
            elif kl == 'direction':
                d['direction'] = v
            elif kl == 'detail-level':
                d['detail_level'] = v
            else:
                raise CLIError('Unsupported Key {} is provided for parameter logging_rules. All possible keys are: '
                               'action, metrics, detail-level'.format(k))
        return d


class AddThrottlingRules(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddThrottlingRules, self).__call__(
            parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError(
                'usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'action':
                d['action'] = v[0]
            elif kl == 'metrics':
                d['metrics'] = v
            elif kl == 'required-features':
                d['required_features'] = v
            else:
                raise CLIError('Unsupported Key {} is provided for parameter throttling_rules. All possible keys are: '
                               'action, metrics, required-features'.format(k))
        return d


class AddIdentityManagement(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.identity_management = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError(
                'usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'type':
                d['type'] = v[0]
            elif kl == 'application-id':
                d['application_id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter identity_management. All possible keys '
                               'are: type, application-id'.format(k))
        return d


class AddCheckNameAvailabilitySpecifications(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.check_name_availability_specifications = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError(
                'usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'enable-default-validation':
                d['enable_default_validation'] = v[0]
            elif kl == 'resource-types-with-custom-validation':
                d['resource_types_with_custom_validation'] = v
            else:
                raise CLIError('Unsupported Key {} is provided for parameter check_name_availability_specifications. '
                               'All possible keys are: enable-default-validation, resource-types-with-custom-validation'
                               ''.format(k))
        return d


class AddSubscriptionStateRules(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddSubscriptionStateRules, self).__call__(
            parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError(
                'usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'state':
                d['state'] = v[0]
            elif kl == 'allowed-actions':
                d['allowed_actions'] = v
            else:
                raise CLIError('Unsupported Key {} is provided for parameter subscription_state_rules. All possible '
                               'keys are: state, allowed-actions'.format(k))
        return d


class AddExtendedLocations(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddExtendedLocations, self).__call__(
            parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError(
                'usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'type':
                d['type'] = v[0]
            elif kl == 'supported-policy':
                d['supported_policy'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter extended_locations. All possible keys '
                               'are: type, supported-policy'.format(k))
        return d


class AddResourceMovePolicy(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.resource_move_policy = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError(
                'usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'validation-required':
                d['validation_required'] = v[0]
            elif kl == 'cross-resource-group-move-enabled':
                d['cross_resource_group_move_enabled'] = v[0]
            elif kl == 'cross-subscription-move-enabled':
                d['cross_subscription_move_enabled'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter resource_move_policy. All possible keys '
                               'are: validation-required, cross-resource-group-move-enabled, '
                               'cross-subscription-move-enabled'.format(k))
        return d


class AddResourceCreationBegin(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.resource_creation_begin = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError(
                'usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'request':
                d['request'] = v
            elif kl == 'response':
                d['response'] = v
            else:
                raise CLIError('Unsupported Key {} is provided for parameter resource_creation_begin. All possible '
                               'keys are: request, response'.format(k))
        return d
